<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Materiaali, osa 2 (nodeadline) | MOOC</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/sites/mooc.cs.helsinki.fi/files/acquia_marina_favicon.png" type="image/x-icon" />
  <link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system-menus.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/modules/cck/theme/content-module.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/modules/ckeditor/ckeditor.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/modules/ctools/css/ctools.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/modules/date/date.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/modules/pan/css/panels.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/modules/views/css/views.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/style.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/typography.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/superfish.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/superfish-navbar.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/superfish-vertical.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/fusion-acquia-marina-style.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/custom.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/common.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/exercises.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/menu.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/shjs/sh_style.css?B" />
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/grid16-960.css?B"/>
  <!--[if IE 8]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie8-fixes.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie8-fixes.css?B" />
  <![endif]-->
  <!--[if IE 7]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie7-fixes.css?B" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie7-fixes.css?B" />
  <![endif]-->
  <!--[if lte IE 6]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie6-fixes.css?B"/>
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie6-fixes.css?B"/>
  <![endif]-->
    <script type="text/javascript" src="/misc/jquery.js?B"></script>
<script type="text/javascript" src="/misc/drupal.js?B"></script>
<script type="text/javascript" src="/sites/all/modules/pan/js/panels.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/fusion/fusion_core/js/jquery.bgiframe.min.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/fusion/fusion_core/js/hoverIntent.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/fusion/fusion_core/js/supposition.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/fusion/fusion_core/js/supersubs.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/fusion/fusion_core/js/superfish.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/fusion/fusion_core/js/script.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/jquery.corner.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/acquia-marina-script.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/util-functions.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/clear-default-text.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/shjs/sh_java.min.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/shjs/sh_main.min.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/shjs/sh_ruby.min.js?B"></script>
<script type="text/javascript" src="/sites/all/themes/acquia_marina/js/shjs/sh_scala.min.js?B"></script>
<script type="text/javascript">
<!--//--><![CDATA[//><!--
jQuery.extend(Drupal.settings, { "basePath": "/" });
//--><!]]>
</script>
</head>

<body id="pid-nodeadline-materiaali-osa-2" class="not-front not-logged-in page-node node-type-page no-sidebars full-node layout-main sidebars-split font-family-lucida font-size-13 grid-type-960 grid-width-16">
  <div id="page" class="page">
    <div id="page-inner" class="page-inner">
      <div id="skip">
        <a href="#main-content-area">Skip to Main Content Area</a>
      </div>

      <!-- header-top row: width = grid_width -->
      
      <!-- header-group row: width = grid_width -->
      <div id="header-group-wrapper" class="header-group-wrapper full-width">
        <div id="header-group" class="header-group row grid16-16">
          <div id="header-group-inner" class="header-group-inner inner clearfix">
                                    <div id="primary-menu" class="primary-menu block">
<div id="primary-menu-inner" class="primary-menu-inner inner clearfix">
<ul class="menu sf-menu"><li class="leaf first"><a href="/" title="">Etusivu</a></li>
<li class="expanded"><a href="/content/mik%C3%A4-mooc" title="Mikä on MOOC?">Mikä on MOOC?</a><ul class="menu"><li class="leaf first"><a href="http://mooc.cs.helsinki.fi/content/mik%C3%A4-mooc" title="">Mikä on MOOC?</a></li>
<li class="leaf"><a href="/content/tiedoksi-lukio-opettajille" title="Tiedoksi lukio-opettajille">Lukio-opettajille</a></li>
<li class="leaf last"><a href="/mahdollisuus-p%C3%A4%C3%A4st%C3%A4-yliopistolle-opiskelemaan" title="MOOC on väylä yliopistoon ilman pääsykoetta!">Väylä yliopistoon</a></li>
</ul></li>
<li class="leaf"><a href="/content/ilmoittautuminen" title="Ilmoittautuminen">Ilmoittautuminen</a></li>
<li class="expanded active-trail"><a href="/content/materiaali-osa-1" title="Materiaali">Materiaali</a><ul class="menu"><li class="leaf first"><a href="/nodeadline/materiaali-osa-1" title="">Osa 1</a></li>
<li class="leaf last active-trail"><a href="/nodeadline/materiaali-osa-2" title="" class="active">Osa 2</a></li>
</ul></li>
<li class="expanded"><a href="http://mooc.cs.helsinki.fi/content/suorittaminen" title="">Suorittaminen</a><ul class="menu"><li class="leaf first"><a href="/content/suorittaminen" title="Suorittaminen">Suorittaminen</a></li>
<li class="leaf last"><a href="http://tmc.mooc.fi/mooc/courses/3/points?bare_layout=1" title="Tulostaulu">Tulostaulu</a></li>
</ul></li>
<li class="expanded last"><a href="http://mooc.cs.helsinki.fi/content/teht%C3%A4v%C3%A4t-ja-ohjeet" title="">Ohjeet</a><ul class="menu"><li class="expanded first"><a href="/content/ohjelmoinnin-aloitus-netbeansia-k%C3%A4ytt%C3%A4en" title="Ohjelmoinnin aloitus NetBeansia käyttäen">Ohjelmoinnin aloitus NetBeansia käyttäen</a><ul class="menu"><li class="leaf first"><a href="/content/netbeans.html" title="NetBeans-vinkkejä">NetBeans-vinkkejä</a></li>
<li class="leaf last"><a href="/content/netbeansin-asennus" title="NetBeansin asennus">NetBeansin asennus</a></li>
</ul></li>
<li class="leaf"><a href="/content/cheatsheet" title="Cheatsheet">Cheatsheet</a></li>
<li class="expanded"><a href="/content/irc-ohjeet" title="IRC-ohjeet">IRC-ohjeet</a><ul class="menu"><li class="leaf first last"><a href="http://tmc.mooc.fi/irclogs" title="">#mooc.fi IRC-logit</a></li>
</ul></li>
<li class="leaf last"><a href="https://sourceforge.net/p/mooc-issues/tickets/" title="">Virheraportit</a></li>
</ul></li>
</ul></div><!-- /primary-menu-inner -->
</div><!-- /primary-menu -->
          </div><!-- /header-group-inner -->
        </div><!-- /header-group -->
      </div><!-- /header-group-wrapper -->

      <!-- preface-top row: width = grid_width -->
        
<!--            <div id="preface-top-wrapper" class="preface-top-wrapper full-width">
        <div id="preface-top" class="preface-top row grid16-16">
          <div id="preface-top-inner" class="preface-top-inner inner clearfix"> 
-->
          </div><!-- /preface-top-inner -->
        </div><!-- /preface-top -->
      </div><!-- /preface-top-wrapper -->
      
    <!-- main row: width = grid_width -->
    <div id="main-wrapper" class="main-wrapper full-width">
      <div id="main" class="main row grid16-16">
        <div id="main-inner" class="main-inner inner clearfix">
          
          <!-- main group: width = grid_width - sidebar_first_width -->
          <div id="main-group" class="main-group row nested grid16-16">
            <div id="main-group-inner" class="main-group-inner inner clearfix">
              
              <div id="main-content" class="main-content row nested">
                <div id="main-content-inner" class="main-content-inner inner clearfix">
                  <!-- content group: width = grid_width - (sidebar_first_width + sidebar_last_width) -->
                    <div id="content-group" class="content-group row nested grid16-16">
                      <div id="content-group-inner" class="content-group-inner inner clearfix">
                        
                        
                        <div id="content-region" class="content-region row nested">
                          <div id="content-region-inner" class="content-region-inner inner clearfix">
                            <a name="main-content-area" id="main-content-area"></a>
                                                        <div id="content-inner" class="content-inner block">
                              <div id="content-inner-inner" class="content-inner-inner inner clearfix">
                                                                <h1 class="title">Materiaali, osa 2 (nodeadline)</h1>
                                                                                                <div id="content-content" class="content-content">
                                  
<div id="node-139" class="node odd full-node node-type-page">
  <div class="inner">
    
    
    
    
    <div class="content clearfix">
      <script type="text/javascript" src="http://www.cs.helsinki.fi/group/java/k12/ohpe/javascripts/jquery-1.7.1.min.js"></script><script type="text/javascript" src="http://www.cs.helsinki.fi/group/java/k12/ohpe/javascripts/exercises.js"></script><script type="text/javascript" src="http://www.cs.helsinki.fi/group/java/k12/ohpe/javascripts/common.js"></script><script type="text/javascript" src="http://www.cs.helsinki.fi/group/java/k12/ohpe/javascripts/shjs/sh_main.min.js"></script><script type="text/javascript" src="http://www.cs.helsinki.fi/group/java/k12/ohpe/javascripts/shjs/sh_java.min.js"></script>
<p><a href="materiaali-osa-1">Materiaali, osa 1 (nodeadline)&nbsp;&raquo;</a></p>
<div class="menu" data-first-chapter-index="38" data-first-exercise-index="115" id="toc">
	<div style="width: 49%; float:left;">
		<p><strong>Materiaali</strong></p>
		<div id="materiaali_toc">
			&nbsp;</div>
	</div>
	<div style="width: 50%; float:left;">
		<p><strong>Teht&auml;v&auml;t</strong></p>
		<div id="tehtavat_toc">
			&nbsp;</div>
	</div>
</div>
<p><strong><big>Huomautus lukijalle</big></strong></p>
<p>T&auml;m&auml; materiaali on tarkoitettu Helsingin Yliopiston Tietojenk&auml;sittelytieteen laitoksen kev&auml;&auml;n 2012 Ohjelmoinnin perusteet- ja jatkokurssille sek&auml; koko maailmalle avoimelle <a href="http://mooc.fi">MOOC-ohjelmointikurssille</a>. Materiaali pohjautuu kev&auml;&auml;n 2011 ja 2010 kurssimateriaaleihin, joiden sis&auml;lt&ouml;&ouml;n ovat vaikuttaneet Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju ja Martin P&auml;rtel.</p>
<p>Lue materiaalia siten, ett&auml; teet samalla itse kaikki lukemasi esimerkit. Esimerkkeihin kannattaa tehd&auml; pieni&auml; muutoksia ja tarkkailla, miten muutokset vaikuttavat ohjelman toimintaan. &Auml;kkiselt&auml;&auml;n voisi luulla, ett&auml; esimerkkien tekeminen my&ouml;s itse ja niiden muokkaaminen hidastaa opiskelua. T&auml;m&auml; ei kuitenkaan pid&auml; ollenkaan paikkansa. Ohjelmoimaan ei ole viel&auml; tiet&auml;&auml;ksemme kukaan ihminen oppinut lukemalla (tai esim. luentoa kuuntelemalla). Oppiminen perustuu oleellisesti aktiiviseen tekemiseen ja rutiinin kasvattamiseen. Esimerkkien ja erityisesti erilaisten omien kokeilujen tekeminen on parhaita tapoja &quot;sis&auml;ist&auml;&auml;&quot; luettua teksti&auml;.</p>
<p>Pyri tekem&auml;&auml;n tai ainakin yritt&auml;m&auml;&auml;n teht&auml;vi&auml; sit&auml; mukaa kuin luet teksti&auml;. Jos et osaa heti tehd&auml; jotain teht&auml;v&auml;&auml;, &auml;l&auml; masennu, sill&auml; saat ohjausta teht&auml;v&auml;n tekemiseen pajassa (tai MOOC-kurssilaisena verkossa).</p>
<p>Teksti&auml; ei ole tarkoitettu vain kertaalleen luettavaksi. Joudut varmasti my&ouml;hemmin palaamaan jo aiemmin lukemiisi kohtiin tai aiemmin tekemiisi teht&auml;viin. T&auml;m&auml; teksti ei sis&auml;ll&auml; kaikkea oleellista ohjelmointiin liittyv&auml;&auml;. Itse asiassa ei ole olemassa mit&auml;&auml;n kirjaa josta l&ouml;ytyisi kaikki oleellinen. Eli joudut joka tapauksessa ohjelmoijan urallasi etsim&auml;&auml;n tietoa my&ouml;s omatoimisesti. Kurssin harjoitukset sis&auml;lt&auml;v&auml;t jo jonkun verran ohjeita, mist&auml; suunnista ja miten hy&ouml;dyllist&auml; tietoa on mahdollista l&ouml;yt&auml;&auml;.</p>
<p>Muutamiin kohtiin olemme my&ouml;s liitt&auml;neet screencasteja joita katsomalla voi pelk&auml;n valmiin koodin lukemisen sijaan seurata miten ohjelma muodostuu.</p>
<p>&nbsp;</p>
<p><em>Huom!</em> K&auml;yt&auml;mme t&auml;ll&auml; kurssilla <a href="http://netbeans.org/">NetBeans</a>-nimist&auml; ohjelmointiymp&auml;rist&ouml;&auml;. Ohjeet NetBeansin ja kurssilla k&auml;ytett&auml;v&auml;n teht&auml;v&auml;automaatin k&auml;ytt&ouml;&ouml;n l&auml;yd&auml;t <a href="netbeans.html">t&auml;&auml;lt&auml;</a>.</p>
<!--

VK1:

- Kertaus
- Luokat
- Oliot
- Viittaustyyppiset muuttujat vs. alkeistyyppiset muuttujat
- Static vs. Ei-static
- HashMap alustus
- JAVA-API: ohjeita käyttöön ja tehtäviä

  -->
<div class="week" data-week-number="7">
	<h2>
		Ohjelmoinnin perusteiden kertausta</h2>
	<h3>
		Ohjelma, k&auml;skyt ja muuttujat</h3>
	<p>Tietokoneohjelma koostuu joukosta k&auml;skyj&auml;, joita tietokone suorittaa yksi kerrallaan, ylh&auml;&auml;lt&auml; alasp&auml;in. K&auml;skyill&auml; on aina m&auml;&auml;r&auml;tty rakenne ja semantiikka. Javassa, eli kurssilla k&auml;ytt&auml;m&auml;ss&auml;mme ohjelmointikieless&auml;, k&auml;skyj&auml; luetaan ylh&auml;&auml;lt&auml; alas vasemmalta oikealle. Ohjelmointikurssit aloitetaan usein esittelem&auml;ll&auml; ohjelma, joka tulostaa merkkijonon <code>Hei maailma!</code>. Alla on Java-kielell&auml; kirjoitettu k&auml;sky <code>Hei maailma!</code>-merkkijonon tulostamiseksi.</p>
	<pre class="sh_java">
        System.out.println(&quot;Hei maailma!&quot;);
</pre>
	<p>K&auml;skyss&auml; kutsutaan <code>System</code>-luokkaan liittyv&auml;n muuttujan <code>println</code>-metodia, joka tulostaa ensin parametrina annetun merkkijonon ja sen j&auml;lkeen rivinvaihdon. Metodille annetaan parametrina merkkijono <code>Hei maailma!</code>, jolloin tulostus on <code>Hei maailma!</code>jota seuraa rivinvaihto.</p>
	<p>Ohjelmaan voi liitty&auml; muuttujia joita voi k&auml;ytt&auml;&auml; osana ohjelman toimintaa. Alla on ohjelma, joka ensin esittelee kokonaislukutyyppisen muuttujan <code>pituus</code>johon asetetaan seuraavalla rivill&auml; arvo 179. T&auml;m&auml;n j&auml;lkeen tulostetaan muuttujan <code>pituus</code>arvo eli <code>179</code>.</p>
	<pre class="sh_java">
        int pituus;
        pituus = 179;
        System.out.println(pituus);
</pre>
	<p>Yll&auml; ohjelman suoritus tapahtuisi rivi kerrallaan. Ensin suoritetaan rivi <code>int pituus;</code>, jossa esitell&auml;&auml;n muuttuja nimelt&auml; <code>pituus</code>. Seuraavaksi suoritetaan rivi <code>pituus = 179;</code>, jossa asetetaan edellisell&auml; rivill&auml; esiteltyyn muuttujaan arvo <code>179</code>. T&auml;m&auml;n j&auml;lkeen suoritetaan rivi <code>System.out.println(pituus);</code>, jossa kutsutaan aiemmin n&auml;kem&auml;&auml;mme tulostusmetodia, jolle annetaan parametrina muuttuja pituus. Metodi tulostaa muuttujan pituus sis&auml;ll&ouml;n eli arvon <code>179</code>.</p>
	<p>Yll&auml; olevassa ohjelmassa ei oikeastaan ole tarvetta esitell&auml; muuttujaa <code>pituus</code>ja asettaa siihen arvoa erillisill&auml; riveill&auml;. Muuttujan esittelyn ja siihen liittyv&auml;n arvon asetuksen voi tehd&auml; my&ouml;s samalla rivill&auml;.</p>
	<pre class="sh_java">
        int pituus = 179;
</pre>
	<p>Yll&auml; olevaa rivi&auml; suoritettaessa esitell&auml;&auml;n ensin muuttuja <code>pituus</code>, johon asetetaan esittelyn yhteydess&auml; arvo <code>179</code>.</p>
	<p>Kaikki tieto esiintyy oikeasti tietokoneen sis&auml;ll&auml; jonona bittej&auml;, eli lukuja nolla ja yksi. Muuttujat ovat ohjelmointikielten tarjoama abstraktio, jolla voidaan k&auml;sitell&auml; erilaisia arvoja helpommin. Muuttujia k&auml;ytet&auml;&auml;n arvojen s&auml;ilytt&auml;miseen ja ohjelman tilan yll&auml;pitoon. Javassa k&auml;yt&ouml;ss&auml;mme on muun muassa alkeisarvoiset muuttujatyypit <code>int</code>(kokonaisluku), <code>double</code>(liukuluku), <code>boolean</code>(totuusarvo), <code>char</code>(merkki) sek&auml; viittaustyyppiset muuttujatyypit <code>String</code>(merkkijono), <code>ArrayList</code>(taulukko) ja kaikki luokat. Palaamme alkeistyyppisiin ja viittaustyyppisiin muuttujiin ja niiden eroihin tarkemmin my&ouml;hemmin.</p>
	<h3>
		Muuttujien vertaileminen ja sy&ouml;tteen lukeminen</h3>
	<p>Ohjelmien toiminnallisuus rakennetaan kontrollirakenteiden avulla. Kontrollirakenteet mahdollistavat erilaiset toiminnot ohjelman muuttujien arvoista riippuen. Alla esimerkki <code>if-elseif-else</code>-kontrollirakenteesta, jossa tehd&auml;&auml;n erilainen toiminto vertailun tuloksesta riippuen. Esimerkiss&auml; tulostetaan merkkijono <code>Kaasua</code>jos muuttujan <code>nopeus</code>arvo on pienempi kuin 110, merkkijono <code>Jarrua</code>jos muuttujan <code>nopeus</code>arvo on suurempi kuin 120 ja merkkijono <code>Kruisaillaan</code>muissa tapauksissa.</p>
	<pre class="sh_java">
        int nopeus = 105;

        if(nopeus &lt; 110) {
            System.out.println(&quot;Kaasua&quot;);
        } else if (nopeus &gt; 120) {
            System.out.println(&quot;Jarrua&quot;);
        } else {
            System.out.println(&quot;Kruisaillaan&quot;);
        }
</pre>
	<p>Koska yll&auml; olevassa esimerkiss&auml; muuttujan <code>nopeus</code>arvo on 105, tulostaa ohjelma aina merkkijonon <code>Kaasua</code>. Muistathan ett&auml; merkkijonojen yht&auml;suuruusvertailu tapahtuu merkkijonoon liittyv&auml;ll&auml; <code>equals</code>-metodilla. Alla on esimerkki jossa k&auml;ytet&auml;&auml;n Javan <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokasta luotua olioita k&auml;ytt&auml;j&auml;n kirjoittaman sy&ouml;tteen lukemiseen. Ohjelma tarkistaa ovatko k&auml;ytt&auml;j&auml;n sy&ouml;tt&auml;m&auml;t merkkijonot samat.</p>
	<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print(&quot;Sy&ouml;t&auml; ensimm&auml;inen merkkijono: &quot;);
        String ensimmainen = lukija.nextLine();

        System.out.print(&quot;Sy&ouml;t&auml; toinen merkkijono: &quot;);
        String toinen = lukija.nextLine();

        System.out.println();

        if (ensimmainen.equals(toinen)) {
            System.out.println(&quot;Kirjoittamasi merkkijonot ovat samat!&quot;);
        } else {
            System.out.println(&quot;Kirjoittamasi merkkijonot eiv&auml;t olleet samat!&quot;);
        }
</pre>
	<p>Ohjelman toiminta riippuu k&auml;ytt&auml;j&auml;n sy&ouml;tteest&auml;. Alla esimerkki, punaisella v&auml;rill&auml; tarkoitetaan k&auml;ytt&auml;j&auml;n kirjoittamaa sy&ouml;tett&auml;.</p>
	<pre>
Sy&ouml;t&auml; ensimm&auml;inen merkkijono: porkkana
Sy&ouml;t&auml; toinen merkkijono: salaatti

Kirjoittamasi merkkijonot eiv&auml;t olleet samat!
</pre>
	<h3>
		Toistolausekkeet</h3>
	<p>Ohjelmissa tarvitaan usein toistoa. Tehd&auml;&auml;n ensin ns. while-true-break -toistolause, jota jatketaan niin pitk&auml;&auml;n kunnes k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; merkkijonon <code>salasana</code>. Lause <code>while(true)</code>aloittaa toistolauseen, jota jatketaan kunnes kohdataan avainsana <code>break</code>.</p>
	<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        while(true) {
            System.out.print(&quot;Sy&ouml;t&auml; salasana: &quot;);
            String salasana = lukija.nextLine();

            if(salasana.equals(&quot;salasana&quot;)) {
                break;
            }
        }

        System.out.println(&quot;Kiitos!&quot;);
</pre>
	<pre>
Sy&ouml;t&auml; salasana: porkkana
Sy&ouml;t&auml; salasana: salasana
Kiitos
</pre>
	<p>While-toistolausekkeeseen voi asettaa totuusarvon <code>true</code>sijaan my&ouml;s vertailun. Alla tulostetaan k&auml;ytt&auml;j&auml;n sy&ouml;tt&auml;m&auml; merkkijono siten, ett&auml; sill&auml; on yl&auml;- ja alapuolella t&auml;hti&auml;.</p>
	<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print(&quot;Sy&ouml;t&auml; merkkijono: &quot;);
        String merkkijono = lukija.nextLine();
        int tahdenNumero = 0;

        while(tahdenNumero &lt; merkkijono.length()) {
            System.out.print(&quot;*&quot;);
            tahdenNumero = tahdenNumero + 1;
        }
        System.out.println();

        System.out.println(merkkijono);
        tahdenNumero = 0;

        while(tahdenNumero &lt; merkkijono.length()) {
            System.out.print(&quot;*&quot;);
            tahdenNumero = tahdenNumero + 1;
        }
        System.out.println();
</pre>
	<pre>
Sy&ouml;t&auml; merkkijono: porkkana
********
porkkana
********
</pre>
	<p>Yll&auml; olevan esimerkin pit&auml;isi nostattaa kylmi&auml; v&auml;reit&auml; selk&auml;piiss&auml;si. Kylm&auml;t v&auml;reet toivottavasti johtuvat siit&auml;, ett&auml; huomaat esimerkin rikkovan ohjelmoinnin perusteissa opittuja k&auml;yt&auml;nteit&auml;. Esimerkiss&auml; on turhaa toistoa joka tulee poistaa metodien avulla.</p>
	<p>While-toistolauseen lis&auml;ksi k&auml;yt&ouml;ss&auml;mme on my&ouml;s for-toistolauseen kaksi versiota. Uudempaa for-lauseketta k&auml;ytet&auml;&auml;n listojen l&auml;pik&auml;yntiin.</p>
	<pre class="sh_java">
        ArrayList&lt;String&gt; tervehdykset = new ArrayList&lt;String&gt;();
        tervehdykset.add(&quot;Hei&quot;);
        tervehdykset.add(&quot;Hallo&quot;);
        tervehdykset.add(&quot;Hi&quot;);

        for(String tervehdys: tervehdykset) {
            System.out.println(tervehdys);
        }
</pre>
	<pre>
Hei
Hallo
Hi
</pre>
	<p>Perinteisemp&auml;&auml; for-lausetta k&auml;ytet&auml;&auml;n samankaltaisissa tilanteissa kuin <code>while</code>-toistolausetta. Sit&auml; voidaan k&auml;ytt&auml;&auml; esimerkiksi taulukoiden l&auml;pik&auml;yntiin. Seuraavassa esimerkiss&auml; kerrotaan jokaisen taulukon <code>luvut</code>alkion sis&auml;lt&ouml; kahdella ja lopuksi tulostetaan luvut uudempaa for-lausetta k&auml;ytt&auml;en.</p>
	<pre class="sh_java">
        int[] luvut = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; luvut.length; i++) {
            luvut[i] = luvut[i] * 2;
        }

        for (int luku : luvut) {
            System.out.println(luku);
        }
</pre>
	<pre>
2
4
6
8
10
12
</pre>
	<p>Perinteinen for-lauseke on eritt&auml;in hy&ouml;dyllinen tapauksissa joissa k&auml;ymme indeksej&auml; yksitellen l&auml;pi. Allaoleva toistolauseke k&auml;y merkkijonon merkit yksitellen l&auml;pi, ja tulostaa merkkijono <code>Hip!</code>aina kun t&ouml;rm&auml;&auml;mme merkkiin <code>a</code>.</p>
	<pre class="sh_java">
        String merkkijono = &quot;saippuakauppias&quot;;
        for (int i = 0; i &lt; merkkijono.length(); i++) {
            if (merkkijono.charAt(i) == &#39;a&#39;) {
                System.out.println(&quot;Hip!&quot;);
            }
        }
</pre>
	<pre>
Hip!
Hip!
Hip!
Hip!
</pre>
	<h3>
		Metodit</h3>
	<p>Metodit ovat tapa pilkkoa ohjelman toiminnallisuutta pienempiin osakokonaisuuksiin. Kaikkien Java-ohjelmien suoritus alkaa p&auml;&auml;ohjelmametodista, joka m&auml;&auml;ritell&auml;&auml;n lauseella <code>public static void main(String[] args)</code>. Lause m&auml;&auml;rittelee staattisen, eli luokkaan liittyv&auml;n metodin, joka saa parametrina merkkijonotaulukon. Java-ohjelmat k&auml;ynnistet&auml;&auml;n p&auml;&auml;ohjelmametodista.</p>
	<pre class="sh_java">
    public static void main(String[] args) {
        System.out.println(&quot;Hei maailma!&quot;);
    }
</pre>
	<p>Ohjelmoija m&auml;&auml;rittelee metodeja toiminnallisuuksien abstrahoimiseksi. Ohjelmoidessa tulee tavoitella tilannetta, jossa ohjelmaa voidaan katsoa ns. <em>korkeammalta tasolta</em>, jolloin ohjelma sis&auml;lt&auml;&auml; joukosta itse m&auml;&auml;riteltyj&auml; metodikutsuja, jotka sis&auml;lt&auml;v&auml;t ohjelman toiminnallisuudet. Metodit joiden m&auml;&auml;rittelyss&auml; on sana <code>static</code>, liittyv&auml;t metodin sis&auml;lt&auml;v&auml;&auml;n <em>luokkaan</em> ja toimivat ns. apumetodeina. Metodit joiden m&auml;&auml;rittelyss&auml; ei ole sanaa <code>static</code>liittyv&auml;t luokasta tehtyihin ilmentymiin, eli <em>olioihin</em>, ja voivat muokata yksitt&auml;isten olioiden sis&auml;ist&auml; tilaa.</p>
	<p>Metodilla on aina n&auml;kyvyysm&auml;&auml;re (public, n&auml;kyy kaikille, private, n&auml;kyy vain luokan sis&auml;ll&auml;), paluutyyppi (void, ei palauta arvoa) sek&auml; metodin nimi. Luodaan luokkaan liittyv&auml; metodi <code>public static void tulosta(String merkkijono, int kertaa)</code>, joka tulostaa merkkijonon halutun m&auml;&auml;r&auml;n kertoja. K&auml;ytet&auml;&auml;n t&auml;ll&auml; kertaa metodia <code>System.out.print</code>, joka on kuin sen kaveri <code>System.out.println</code>, mutta ei tulosta rivinvaihtoa.</p>
	<pre class="sh_java">
    public static void tulosta(String merkkijono, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.print(merkkijono);
        }
    }
</pre>
	<p>Yll&auml; oleva metodi tulostaa parametrina annetun merkkijonon niin monta kertaa kuin parametrina annettu kokonaisluku kertoo.</p>
	<p>Toistolausekkeisiin liittyv&auml;ss&auml; kappaleessa huomasimme tilanteen, joka nostatti kylmi&auml; v&auml;reit&auml; selk&auml;piiss&auml;mme. Metodien avulla voimme siirt&auml;&auml; t&auml;htien tulostamisen erillisen metodiin. Luodaan metodi <code>public static void tulostaTahtia(int kertaa)</code>, joka tulostaa parametrina annetun muuttujan m&auml;&auml;r&auml;&auml;m&auml;n m&auml;&auml;r&auml;n t&auml;hti&auml;. Metodi k&auml;ytt&auml;&auml; <code>for</code>-toistolausetta <code>while</code>-toistolauseen sijaan.</p>
	<pre class="sh_java">
    public static void tulostaTahtia(int kertaa) {
        for(int i = 0; i &lt; kertaa; i++) {
            System.out.print(&quot;*&quot;);
        }
        System.out.println();
    }
</pre>
	<p>Metodia hy&ouml;dynt&auml;ess&auml; aiemmin kauhistusta aihettanut esimerkkimme n&auml;ytt&auml;&auml; seuraavalta.</p>
	<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print(&quot;Sy&ouml;t&auml; merkkijono: &quot;);
        String merkkijono = lukija.nextLine();

        tulostaTahtia(merkkijono.length());
        System.out.println(merkkijono);
        tulostaTahtia(merkkijono.length());
</pre>
	<h3>
		Luokka</h3>
	<p>Metodit toimivat ohjelman abstrahoimisessa tiettyyn pisteeseen asti, mutta ohjelmien kasvaessa suuremmiksi ohjelmia halutaan pilkkoa pienempiin metodit sis&auml;lt&auml;viin kokonaisuuksiin. Luokkien avulla voimme m&auml;&auml;rittelemme k&auml;sitteit&auml; ja k&auml;sitteisiin liittyvi&auml; toiminnallisuuksia. Jokainen Java-ohjelma vaatii toimiakseen luokan, eli yll&auml; rakennettu <code>Hei maailma!</code>-esimerkki ei toimisi ilman luokkam&auml;&auml;rittely&auml;. Luokka m&auml;&auml;ritell&auml;&auml;n avainsanoilla <code>public class LuokanNimi</code>.</p>
	<pre class="sh_java">
public class HeiMaailma {
    public static void main(String[] args) {
        System.out.println(&quot;Hei maailma!&quot;);
    }
}
</pre>
	<p>Luokkia k&auml;ytet&auml;&auml;n ohjelmassa esiintyvien k&auml;sitteiden ja niihin liittyvien toiminnallisuuksien m&auml;&auml;rittelyyn. Luokista voidaan luoda olioita, jotka ovat luokan ilmentymi&auml;. Jokaisella tiettyyn luokkaan liittyv&auml;ll&auml; oliolla on sama rakenne, mutta oliohin liittyvien muuttujien arvot voivat olla erilaiset. Olioiden metodit k&auml;sittelev&auml;t olioiden tilaa, eli sis&auml;isi&auml; muuttujia.</p>
	<p>Tutkitaan alla olevaa luokkaa <code>Kirja</code>, jolla on oliomuuttujat nimi (merkkijono) ja julkaisuvuosi (kokonaisluku).</p>
	<pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }
}
</pre>
	<p>Alussa oleva m&auml;&auml;ritelm&auml; <code>public class Kirja</code>kertoo luokan nimen, jota seuraa oliomuuttujat. Oliomuuttujat ovat muuttujia jotka ovat omat jokaiselle luokasta luodulle oliolle. Luokasta luodaan olioita <em>konstruktorilla</em>. Konstruktori on metodi joka alustaa olion (eli luo oliolle siihen liittyv&auml;t muuttujat) ja suorittaa konstruktorin sis&auml;ll&auml; olevat k&auml;skyt. Konstruktori on aina samanniminen kuin konstruktorin sis&auml;lt&auml;v&auml; luokka. Konstruktorissa <code>public Kirja(String nimi, int julkaisuvuosi)</code>luodaan uusi olio luokasta <code>Kirja</code>ja asetetaan siihen liittyviin muuttujiin parametrina annetut arvot.</p>
	<p>T&auml;m&auml;n lis&auml;ksi luokalle on m&auml;&auml;ritelty kaksi olioiden tietoja k&auml;sittelev&auml;&auml; metodia. Metodi <code>public String getNimi()</code>palauttaa k&auml;sitelt&auml;v&auml;n olion nimen. Metodi <code>public int getJulkaisuvuosi()</code>palauttaa k&auml;sitelt&auml;v&auml;n olion julkaisuvuoden.</p>
	<h3>
		Olio</h3>
	<p>Olioita luodaan luokkaan m&auml;&auml;ritellyn konstruktorin avulla. Ohjelmakoodissa konstruktoria kutsutaan <code>new</code>-k&auml;skyll&auml;, joka palauttaa viitteen uuteen olioon. Oliot ovat luokista tehtyj&auml; ilmentymi&auml;. Tutkitaan ohjelmaa, joka luo kaksi eri kirjaa, jonka j&auml;lkeen tulostetaan olioihin liittyvien metodien <code>getNimi</code>palauttamat arvot.</p>
	<pre class="sh_java">
        Kirja jarkiJaTunteet = new Kirja(&quot;J&auml;rki ja tunteet&quot;, 1811);
        Kirja ylpeysJaEnnakkoluulo = new Kirja(&quot;Ylpeys ja ennakkoluulo&quot;, 1813);

        System.out.println(jarkiJaTunteet.getNimi());
        System.out.println(ylpeysJaEnnakkoluulo.getNimi());
</pre>
	<pre>
J&auml;rki ja tunteet
Ylpeys ja ennakkoluulo
</pre>
	<p>Jokaisella oliolla on siis oma sis&auml;inen tila. Tila muodostuu olioon liittyvist&auml; oliomuuttujista. Oliomuuttujat voivat olla sek&auml; alkeistyyppisi&auml; muuttujia ett&auml; viittaustyyppisi&auml; muuttujia. Jos olioon liittyy viittaustyyppisi&auml; muuttujia, voi olla ett&auml; muutkin oliot viittaavat samoihin olioihin! Visualisoidaan t&auml;m&auml; pankkiesimerkill&auml;, jossa on tilej&auml; ja henkil&ouml;it&auml;.</p>
	<pre class="sh_java">
public class Tili {
    private String tilitunnus;
    private int saldoSentteina;

    public Tili(String tilitunnus) {
        this.tilitunnus = tilitunnus;
        this.saldoSentteina = 0;
    }

    public void pane(int summa) {
        this.saldoSentteina += summa;
    }

    public int getSaldoSentteina() {
        return this.saldoSentteina;
    }

    // .. muita tiliin liittyvi&auml; metodeja
}
</pre>
	<pre class="sh_java">
import java.util.ArrayList;

public class Henkilo {
    private String nimi;
    private ArrayList&lt;Tili&gt; tilit;

    public Henkilo(String nimi) {
        this.nimi = nimi;
        this.tilit = new ArrayList&lt;Tili&gt;();
    }

    public void lisaaTili(Tili tili) {
        this.tilit.add(tili);
    }

    public int rahaaYhteensa() {
        int yhteensa = 0;
        for (Tili tili: this.tilit) {
            yhteensa += tili.getSaldoSentteina();
        }

        return yhteensa;
    }

    // ... muita henkil&ouml;&ouml;n liittyvi&auml; metodeja
}
</pre>
	<p>Jokaisella <code>Henkilo</code>-luokasta tehdyll&auml; oliolla on oma nimi sek&auml; oma lista tileist&auml;. Luodaan seuraavaksi kaksi henkil&ouml;&auml; ja kaksi tili&auml;. Toinen tileist&auml; on vain yhden henkil&ouml;n oma, toinen yhteinen.</p>
	<pre class="sh_java">
        Henkilo matti = new Henkilo(&quot;Matti&quot;);
        Henkilo maija = new Henkilo(&quot;Maija&quot;);

        Tili palkkatili = new Tili(&quot;NORD-LOL&quot;);
        Tili kotitaloustili = new Tili(&quot;SAM-LOL&quot;);

        matti.lisaaTili(palkkatili);
        matti.lisaaTili(kotitaloustili);
        maija.lisaaTili(kotitaloustili);

        System.out.println(&quot;Matin tileill&auml; rahaa: &quot; + matti.rahaaYhteensa());
        System.out.println(&quot;Maijan tileill&auml; rahaa: &quot; + maija.rahaaYhteensa());
        System.out.println();

        palkkatili.pane(150000);

        System.out.println(&quot;Matin tileill&auml; rahaa: &quot; + matti.rahaaYhteensa());
        System.out.println(&quot;Maijan tileill&auml; rahaa: &quot; + maija.rahaaYhteensa());
        System.out.println();

        kotitaloustili.pane(10000);

        System.out.println(&quot;Matin tileill&auml; rahaa: &quot; + matti.rahaaYhteensa());
        System.out.println(&quot;Maijan tileill&auml; rahaa: &quot; + maija.rahaaYhteensa());
        System.out.println();
</pre>
	<pre>
Matin tileill&auml; rahaa: 0
Maijan tileill&auml; rahaa: 0

Matin tileill&auml; rahaa: 150000
Maijan tileill&auml; rahaa: 0

Matin tileill&auml; rahaa: 160000
Maijan tileill&auml; rahaa: 10000
</pre>
	<p>Ensin kummankin henkil&ouml;n tilit ovat tyhji&auml;. Kun palkkatilille, johon oliolla <code>matti</code>on viite, lis&auml;t&auml;&auml;n rahaa, kasvaa Matin tileill&auml; oleva raham&auml;&auml;r&auml;. Kun kotitaloustilille lis&auml;t&auml;&auml;n rahaa, <em>kasvaa kummankin henkil&ouml;n raham&auml;&auml;r&auml;</em>. T&auml;m&auml; johtuu siit&auml; ett&auml; sek&auml; Matilla ett&auml; Maijalla on &quot;oikeus&quot; kotitaloustilille, eli kummakin omassa oliomuuttujassa <code>tilit</code>on viite kotitaloustiliin. Palaamme alkeis- ja viittaustyyppisten muuttujien eroon tarkemmin my&ouml;hemmin.</p>
	<h3>
		Ohjelmien rakenteesta</h3>
	<p>Ohjelmien tulee olla selkeit&auml; paitsi itselle, my&ouml;s toisille. K&auml;yt&auml;mme luokkia ja metodeja selvent&auml;&auml;ksemme ohjelmissa esiintyvi&auml; k&auml;sitteit&auml; kaikille. Jokaisella luokalla on vastuu, johon liittyvi&auml; teht&auml;vi&auml; se hoitaa. Metodeja k&auml;ytet&auml;&auml;n toiston v&auml;hent&auml;miseen ja luokkien sis&auml;isten toimintojen selvent&auml;miseksi. Metodien avulla voidaan my&ouml;s selkeytt&auml;&auml; ohjelmakoodia. K&auml;yt&auml;nn&ouml;ss&auml; metodi ei saa olla koskaan niin pitk&auml; ett&auml; sen luettavuus vaikeutuisi. Jos huomaat ett&auml; metodisi on niin pitk&auml;, ettet ymm&auml;rr&auml; tai muista mit&auml; se tekee, kannattaa pilkkoa se heti pienempiin metodeihin. Hyv&auml;t ohjelmoijat ohjelmoivat koodia, jota he ja heid&auml;n ty&ouml;kaverinsa ymm&auml;rt&auml;v&auml;t my&ouml;s viikkoja koodin kirjoittamisen j&auml;lkeenkin.</p>
	<p>Ymm&auml;rrett&auml;v&auml;&auml;n koodiin liittyy niin kuvaava muuttujien, metodien ja luokkien niment&auml; kuin ohjelmakoodin ilmavuus ja seurattavien sisennysten m&auml;&auml;r&auml;. Tutkitaan seuraavaa esimerkki&auml; k&auml;ytt&ouml;liittym&auml;st&auml;, jossa k&auml;ytt&auml;j&auml; voi ostaa ja myyd&auml; esineit&auml;. Vaikka esimerkiss&auml; ainoat ostettavat ja myyt&auml;v&auml;t asiat ovat porkkanoita, eik&auml; niist&auml; pidet&auml; kirjaa, voisi k&auml;ytt&ouml;liittym&auml;&auml; laajentaa esimerkiksi siten ett&auml; sille annettaisiin varasto konstruktorin parametrina -- t&auml;h&auml;nkin palataan my&ouml;hemmin kurssin aikana.</p>
	<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals(&quot;lopeta&quot;)) {
                break;
            } else if (komento.equals(&quot;osta&quot;)) {
                String luettu = null;
                while(true) {
                    System.out.print(&quot;Mit&auml; ostetaan: &quot;);
                    luettu = lukija.nextLine();
                    if(luettu.equals(&quot;porkkana&quot;) {
                        break;
                    } else {
                        System.out.println(&quot;Ei l&ouml;ydy!&quot;);
                    }
                }

                System.out.println(&quot;Ostettu!&quot;);
            } else if (komento.equals(&quot;myy&quot;)) {
                String luettu = null;
                while(true) {
                    System.out.print(&quot;Mit&auml; myyd&auml;&auml;n: &quot;);
                    luettu = lukija.nextLine();
                    if(luettu.equals(&quot;porkkana&quot;) {
                        break;
                    } else {
                        System.out.println(&quot;Ei l&ouml;ydy!&quot;);
                    }
                }

                System.out.println(&quot;Myyty!&quot;);
            }
        }
    }
}
</pre>
	<p>Huomaamme esimerkiss&auml; heti monta ongelmakohtaa. Ensimm&auml;inen pulma liittyy <code>kaynnista</code>-metodin sis&auml;ll&ouml;n suuruuteen. Huomaamme ett&auml; metodia voi pienent&auml;&auml; siirt&auml;m&auml;ll&auml; muiden komentojen kuin <code>lopeta</code>-komennon k&auml;sittelyn erilliseen metodiin.</p>
	<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals(&quot;lopeta&quot;)) {
                break;
            } else {
                hoidaKomento(komento);
            }
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals(&quot;osta&quot;)) {
            String luettu = null;
            while(true) {
                System.out.print(&quot;Mit&auml; ostetaan: &quot;);
                luettu = lukija.nextLine();
                if(luettu.equals(&quot;porkkana&quot;) {
                    break;
                } else {
                    System.out.println(&quot;Ei l&ouml;ydy!&quot;);
                }
            }

            System.out.println(&quot;Ostettu!&quot;);
        } else if (komento.equals(&quot;myy&quot;)) {
            String luettu = null;
            while(true) {
                System.out.print(&quot;Mit&auml; myyd&auml;&auml;n: &quot;);
                luettu = lukija.nextLine();
                if(luettu.equals(&quot;porkkana&quot;) {
                    break;
                } else {
                    System.out.println(&quot;Ei l&ouml;ydy!&quot;);
                }
            }

            System.out.println(&quot;Myyty!&quot;);
        }
    }
}
</pre>
	<p>Metodissa <code>hoidaKomento</code>on viel&auml; toisteisuutta sy&ouml;tteen lukemiseen liittyen. Huomaamme ett&auml; lukemisessa toistuu aina muutama merkkijono. Kun ostetaan kysyt&auml;&auml;n &quot;Mit&auml; ostetaan: &quot;, kun myyd&auml;&auml;n kysyt&auml;&auml;n &quot;Mit&auml; myyd&auml;&auml;n: &quot;. Molemmat lukemiskohdat odottavat merkkijonoa &quot;porkkana&quot; ja tulostavat &quot;Ei l&ouml;ydy!&quot; jos k&auml;ytt&auml;j&auml; ei sy&ouml;t&auml; merkkijonoa &quot;Porkkana&quot;. Luodaan t&auml;t&auml; varten erillinen metodi <code>public String lueKayttajalta(String kysymys)</code>, joka kysyy k&auml;ytt&auml;j&auml;lt&auml; haluttua merkkijonoa. Huomaa ett&auml; jos k&auml;ytt&ouml;liittym&auml;ss&auml;mme olisi k&auml;yt&ouml;ss&auml; jonkinlainen varastonhallintaolio, vertaisimme sen sis&auml;lt&auml;mi&auml; esineit&auml; k&auml;ytt&auml;j&auml;n sy&ouml;tteeseen porkkanan sijasta.</p>
	<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals(&quot;lopeta&quot;)) {
                break;
            } else {
                hoidaKomento(komento);
            }
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals(&quot;osta&quot;)) {
            String luettu = lueKayttajalta(&quot;Mit&auml; ostetaan: &quot;);
            System.out.println(&quot;Ostettu!&quot;);
        } else if (komento.equals(&quot;myy&quot;)) {
            String luettu = lueKayttajalta(&quot;Mit&auml; myyd&auml;&auml;n: &quot;);
            System.out.println(&quot;Myyty!&quot;);
        }
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = lukija.nextLine();

            if(luettu.equals(&quot;porkkana&quot;) {
                return luettu;
            } else {
                System.out.println(&quot;Ei l&ouml;ydy!&quot;);
            }
        }
    }
}
</pre>
	<p>Ohjelma on nyt pilkottu sopiviksi osiksi. Huomaamme kuitenkin ett&auml; <code>kaynnista</code>-metodin yhteydess&auml; on turha <code>else</code>-haara. Jos ohjelman suoritus p&auml;&auml;tyy <code>if</code>-haaraan, suoritetaan komento <code>break</code>ja poistutaan toistolauseesta. Voimme siis poistaa <code>else</code>-haaran jolloin <code>hoidaKomento</code>-metodin suorittaminen on omalla rivill&auml;&auml;n. Samanlainen tilanne on my&ouml;s metodissa <code>lueKayttajalta</code>. Siistit&auml;&auml;n se my&ouml;s samalla.</p>
	<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals(&quot;lopeta&quot;)) {
                break;
            }

            hoidaKomento(komento);
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals(&quot;osta&quot;)) {
            String luettu = lueKayttajalta(&quot;Mit&auml; ostetaan: &quot;);
            System.out.println(&quot;Ostettu!&quot;);
        } else if (komento.equals(&quot;myy&quot;)) {
            String luettu = lueKayttajalta(&quot;Mit&auml; myyd&auml;&auml;n: &quot;);
            System.out.println(&quot;Myyty!&quot;);
        }
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = lukija.nextLine();

            if(luettu.equals(&quot;porkkana&quot;) {
                return luettu;
            }

            System.out.println(&quot;Ei l&ouml;ydy!&quot;);
        }
    }
}
</pre>
	<p>Yll&auml; kuvaavaamme ohjelman pilkkomista pienempiin osiin kutsutaan <em>refaktoroinniksi</em>. Refaktoroinnissa ohjelman toiminta pysyy samana, mutta sis&auml;inen rakenne muuttuu selke&auml;mm&auml;ksi ja yll&auml;pidett&auml;v&auml;mm&auml;ksi. Nykyinen versiomme on huomattavasti selke&auml;mpi alkuper&auml;iseen ohjelmaan verrattuna. Ohjelmassa on toki viel&auml;kin parannettavaa. Esimerkiksi metodin <code>hoidaKomento</code>voi pilkkoa ostamis- ja myymistoiminnallisuutta hoitaviin metodeihin.</p>
	<pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals(&quot;lopeta&quot;)) {
                break;
            }

            hoidaKomento(komento);
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals(&quot;osta&quot;)) {
            komentoOsta();
        } else if (komento.equals(&quot;myy&quot;)) {
            komentoMyy();
        }
    }

    public void komentoOsta() {
        String luettu = lueKayttajalta(&quot;Mit&auml; ostetaan: &quot;);
        System.out.println(&quot;Ostettu!&quot;);
    }

    public void komentoMyy() {
        String luettu = lueKayttajalta(&quot;Mit&auml; myyd&auml;&auml;n: &quot;);
        System.out.println(&quot;Myyty!&quot;);
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = lukija.nextLine();

            if(luettu.equals(&quot;porkkana&quot;) {
                return luettu;
            }

            System.out.println(&quot;Ei l&ouml;ydy!&quot;);
        }
    }
}
</pre>
	<p>Nyt ohjelma on sopivan pieni. Huomaa ett&auml; jokaisella metodilla on oma pieni teht&auml;v&auml; jota se hoitaa. Huomaa ett&auml; emme lis&auml;nneet refaktoroidessa ohjelmaan uutta toiminnallisuutta, muokkasimme vain rakennetta selke&auml;mm&auml;ksi.</p>
	<h3>
		Ohjelmoinnista ja ennenkaikkea harjoittelun t&auml;rkeydest&auml;</h3>
	<p>Tiet&auml;&auml;ksemme kukaan ei ole oppinut ohjelmoimaan luentoja kuuntelemalla. Ohjelmointitaidon kehittymisen kannalta harjoittelu ja kertaaminen on t&auml;rke&auml;&auml;. Ohjelmointitaitoa on verrattu niin kielten puhumiseen kuin instrumentin soittamiseen -- kummassakin kehittyy vain harjoittelemalla. Oikeastaan, esimerkiksi hyv&auml;t viulistit eiv&auml;t ole hyvi&auml; <em>vain</em> sen takia, ett&auml; he ovat harjoitelleet paljon. Harjoittelua motivoi my&ouml;s se, ett&auml; se on hauskaa. Samaa voi sanoa ohjelmoijista.</p>
	<p>Linus Torvaldsin sanoin <em>&quot;Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program.&quot;</em>.</p>
	<p>Tohtori Luukkainen on kirjoittanut listan jota kannattaa seurata ohjelmoidessa ja siin&auml; kehittyess&auml;. Seuraa listan neuvoja kunnes osaat ne unissasikin.</p>
	<ul>
		<li>
			Etene pieni askel kerrallaan
			<ul>
				<li>
					Yrit&auml; pilkkoa ongelma osaongelmiin ja <strong>ratkaise vain yksi osaongelma kerrallaan</strong></li>
				<li>
					Testaa aina ett&auml; ohjelma on etenem&auml;ss&auml; oikeaan suuntaan eli ett&auml; osaongelman ratkaisu meni oikein</li>
			</ul>
		</li>
		<li>
			Kirjoita mahdollisimman &quot;siisti&auml;&quot; koodia
			<ul>
				<li>
					sisenn&auml; koodi</li>
				<li>
					k&auml;yt&auml; kuvaavia muuttujien ja metodien nimi&auml;</li>
				<li>
					&auml;l&auml; tee liian pitki&auml; metodeja, edes mainia</li>
				<li>
					tee yhdess&auml; metodissa vaan yksi asia</li>
				<li>
					<strong>poista koodistasi kaikki copy-paste</strong></li>
				<li>
					korvaa koodisi &quot;huonot&quot; ja ep&auml;siistit osat siistill&auml; koodilla</li>
			</ul>
		</li>
	</ul>
	<h2>
		N&auml;kyvyysm&auml;&auml;reet</h2>
	<p>Olemme t&auml;h&auml;n menness&auml; k&auml;ytt&auml;neet kahta erilaista <em>n&auml;kyvyyteen</em> liittyv&auml;&auml; avainsanaa metodien ja oliomuuttujien m&auml;&auml;rittelyss&auml;. Avainsana <code>public</code>asettaa metodit ja muuttujat kaikille n&auml;kyviksi. Esimerkiksi luokan aksessorit ja konstruktorit merkit&auml;&auml;n usein m&auml;&auml;reell&auml; public, jolloin niit&auml; voi kutsua luokan ulkopuolelta.</p>
	<p>Avainsana <code>private</code>taas piilottaa metodit ja muuttujat luokan sis&auml;lle. Metodia, jolla on m&auml;&auml;re <code>private</code>, ei pysty kutsumaan luokan ulkopuolelta.</p>
	<pre class="sh_java">
public class Kirja {
    private String nimi;
    private String sisalto;

    public Kirja(String nimi, String sisalto) {
        this.nimi = nimi;
        this.sisalto = sisalto;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getSisalto() {
        return this.sisalto;
    }

    // ...
}
</pre>
	<p>Yll&auml; olevasta Kirja-luokasta luotujen olioiden tietoihin p&auml;&auml;see k&auml;siksi vain kirjan julkisten metodien kautta. Private-m&auml;&auml;reell&auml; merkityt oliomuuttujat ovat n&auml;kyvill&auml; ja k&auml;sitelt&auml;viss&auml; vain luokan sis&auml;isess&auml; koodissa. Jos kirjalla olisi private-m&auml;&auml;reellinen metodi, ei sit&auml;k&auml;&auml;n voisi k&auml;ytt&auml;&auml; muualta kuin Kirja-luokan sis&auml;lt&auml;.</p>
	<p>Sitten itse asiaan, eli harjoitteluun!</p>
	<div class="tehtavat">
		<h3>
			Hymi&ouml;t</h3>
		<p>Laadi tehtavapohjan mukana tulevalle luokalle <code>Hymiot</code>apumetodi <code>private static void tulostaHymioityna(String merkkijono)</code>. Metodin tulee tulostaa annettu merkkijono hymi&ouml;ill&auml; ympyr&ouml;ityn&auml;. K&auml;yt&auml; hymi&ouml;n&auml; merkkijonoa <code>:)</code>.</p>
		<pre class="sh_java">
tulostaHymioityna(&quot;\\:D/&quot;);
</pre>
		<pre>
:):):):):)
:) \:D/ :)
:):):):):)
</pre>
		<p>Huomaa, ett&auml; merkkijonoon on kirjoitettava \\ jotta saadaan tulostumaan merkki \.</p>
		<p><em>Huom!</em> Jos merkkijonon pituus on pariton, kannattaa lis&auml;t&auml; ylim&auml;&auml;r&auml;inen v&auml;lily&ouml;nti annetun merkkijonon oikealle puolelle.</p>
		<pre class="sh_java">
tulostaHymioityna(&quot;\\:D/&quot;);
tulostaHymioityna(&quot;87.&quot;);
</pre>
		<pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
</pre>
		<p>Kannattaa ensin mietti&auml; montako hymi&ouml;t&auml; mink&auml;kin pituiselle merkkijonolle tulee tulostaa. Merkkijonon pituuden saa selville siihen liittyv&auml;ll&auml; <code>length</code>-metodilla. Ala- ja yl&auml;rivin hymi&ouml;iden tulostamiseen auttaa toistolause, keskimm&auml;isell&auml; rivill&auml; selvi&auml;t normaalilla tulostuskomennolla. Pituuden parittomuuden voit tarkistaa jakoj&auml;&auml;nn&ouml;ksen avulla <code>merkkijono.length() % 2 == 1</code>.</p>
		<h3>
			Merkkijonomuuntaja</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; luodaan merkkijonomuuntaja, joka koostuu kahdesta luokasta. Luokka Muunnos muuttaa yksitt&auml;iset merkit toiseksi, Muuntaja sis&auml;lt&auml;&auml; joukon Muunnoksia ja muuttaa merkkijonoja sis&auml;lt&auml;miens&auml; Muunnos-olioiden avulla.</p>
		<h4>
			Muunnos-luokka</h4>
		<p>Luo luokka <code>Muunnos</code>, jolla on seuraavat toiminnot:</p>
		<ul>
			<li>
				konstruktori <code>public Muunnos(char muunnettava, char muunnettu)</code>luo olion joka tekee muunnoksia merkilt&auml; <code>muunnettava</code>merkille <code>muunnettu</code></li>
			<li>
				metodi <code>public String muunna(String merkkijono)</code>palauttaa muunnetun version annetusta merkkijonosta</li>
		</ul>
		<p>Luokkaa k&auml;ytet&auml;&auml;n seuraavalla tavalla:</p>
		<pre class="sh_java">
  Muunnos muunnos = new Muunnos(&#39;a&#39;, &#39;b&#39;);
  System.out.println(muunnos.muunna(&quot;porkkana&quot;));
</pre>
		<p>Yll&auml; oleva esimerkki tulostaisi:</p>
		<pre>
  porkkbnb
</pre>
		<h4>
			Muuntaja-luokka</h4>
		<p>Luo luokka <code>Muuntaja</code>, jolla on seuraavat toiminnot:</p>
		<ul>
			<li>
				konstruktori <code>public Muuntaja()</code>luo uuden muuntajan</li>
			<li>
				metodi <code>public void lisaaMuunnos(Muunnos muunnos)</code>lis&auml;&auml; uuden muunnoksen muuntajaan</li>
			<li>
				metodi <code>public String muunna(String merkkijono)</code>suorittaa merkkijonolle kaikki lis&auml;tyt muunnokset niiden lis&auml;ysj&auml;rjestyksess&auml; ja palauttaa muunnetun merkkijonon</li>
		</ul>
		<p>Luokkaa k&auml;ytet&auml;&auml;n seuraavalla tavalla:</p>
		<pre class="sh_java">
  Muuntaja skanditPois = new Muuntaja();
  skanditPois.lisaaMuunnos(new Muunnos(&#39;&auml;&#39;, &#39;a&#39;));
  skanditPois.lisaaMuunnos(new Muunnos(&#39;&ouml;&#39;, &#39;o&#39;));
  System.out.println(skanditPois.muunna(&quot;&auml;&auml;li&ouml; &auml;l&auml; ly&ouml;, &ouml;&ouml;li&auml; l&auml;ikkyy&quot;));
</pre>
		<p>Yll&auml; oleva esimerkki tulostaisi:</p>
		<pre>
  aalio ala lyo, oolia laikkyy
</pre>
		<h3>
			Laskin</h3>
		<p>Teemme t&auml;ss&auml; teht&auml;v&auml;ss&auml; samantyylisen yksinkertaisen laskimen, joka oli jo ohjelmoinnin perusteiden viikon 1 materiaalissa. T&auml;ll&auml; kertaa kiinnit&auml;mme kuitenkin huomiota ohjelman rakenteeseen. Erityisesti teemme <em>main</em>-metodista eli p&auml;&auml;ohjelmasta hyvin kevyen. P&auml;&auml;ohjelmametodi ei tee oikeastaan mit&auml;&auml;n muuta kun k&auml;ynist&auml;&auml; ohjelman:</p>
		<pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Laskin laskin = new Laskin();
        laskin.kaynnista();
    }
}
</pre>
		<p>P&auml;&auml;ohjelma siis ainoastaan luo varsinaisen sovelluslogiikan toteuttavan olion ja k&auml;ynnist&auml;&auml; sen. T&auml;m&auml; on oikea tyyli tehd&auml; ohjelmia ja tulemme jatkossa usein pyrkim&auml;&auml;n t&auml;h&auml;n rakenteeseen.</p>
		<h4>
			Lukija</h4>
		<p>Kommunikoidakseen k&auml;ytt&auml;j&auml;n kanssa laskin tarvitsee Scanner-olion. Kuten olemme huomanneet, on kokonaislukujen lukeminen scannerilla hieman ty&ouml;l&auml;st&auml;. Teemme nyt erillisen luokan <code>Lukija</code>joka kapseloi sis&auml;lleen Scanner-olion.</p>
		<p>Toteuta luokka <code>Lukija</code>ja lis&auml;&auml; sille metodit</p>
		<ul>
			<li>
				<code>public String lueMerkkijono()</code></li>
			<li>
				<code>public int lueKokonaisluku()</code></li>
		</ul>
		<p>Lukijan sis&auml;ll&auml; tulee olla oliomuuttujana Scanner-olio jota metodit k&auml;ytt&auml;v&auml;t ohjelmoinnin perusteista tuttuun tyyliin. Muistathan ett&auml; kokonaislukujen lukemisessa kannattaa ensin lukea koko rivi, jonka j&auml;lkeen rivi tulee muuttaa kokonaisluvuksi. T&auml;ss&auml; on hy&ouml;dyksi <code>Integer</code>-luokan metodi <code>parseInt</code>.</p>
		<h4>
			Sovellusrunko</h4>
		<p>Laskin toimii seuraavan esimerkin mukaan:</p>
		<pre>
komento: summa
luku1: 4
luku2: 6
lukujen summa 10

komento: tulo
luku1: 3
luku2: 2
lukujen tulo 6

komento: lopetus
</pre>
		<p>Tee ohjelmaasi sovelluslogiigasta huolehtiva luokka <code>Laskin</code>ja sille metodi <code>public void kaynnista()</code>jonka sis&auml;lt&ouml; on t&auml;sm&auml;lleen seuraava:</p>
		<pre class="sh_java">
    public void kaynnista() {
        while (true) {
            System.out.print(&quot;komento: &quot;);
            String komento = lukija.lueMerkkijono();
            if (komento.equals(&quot;lopetus&quot;)) {
                break;
            }

            if (komento.equals(&quot;summa&quot;)) {
                summa();
            } else if (komento.equals(&quot;erotus&quot;)) {
                erotus();
            } else if (komento.equals(&quot;tulo&quot;)) {
                tulo();
            }
        }

        statistiikka();
    }
</pre>
		<p>Laskimellamme on operaatiot <code>summa, erotus, tulo</code>.</p>
		<p>Tee valmiiksi rungot metodeille <code>summa</code>, <code>erotus</code>, <code>tulo</code>ja <code>statistiikka</code>. Kaikkien tulee olla tyyppi&auml; <code>private void</code>, eli metodit ovat vain laskimen sis&auml;isess&auml; k&auml;yt&ouml;ss&auml;.</p>
		<p>Lis&auml;&auml; laskimelle oliomuuttuja jonka tyyppi on <code>Lukija</code>, ja luo lukija konstruktorissa. <em>Laskimessa ei saa olla erikseen Scanner-tyyppist&auml; muuttujaa!</em></p>
		<h4>
			Sovelluslogiikan toteutus</h4>
		<p>Toteuta nyt metodit <code>summa</code>, <code>erotus</code>ja <code>tulo</code>siten, ett&auml; ne toimivat yll&auml; olevan esimerkin mukaan. Esimerkiss&auml; kysyt&auml;&auml;n aina ensin komento, jonka j&auml;lkeen kysyt&auml;&auml;n 2 lukua k&auml;ytt&auml;j&auml;lt&auml;, suoritetaan haluttu operaatio, ja tulostetaan operaation arvo.</p>
		<p>Huomaa, ett&auml; koska metodit ovat luokan <code>Laskin</code>sis&auml;ll&auml;, on oliomuuttujana oleva <code>Lukija</code>k&auml;ytett&auml;viss&auml; metodien sis&auml;ll&auml;.</p>
		<h4>
			Statistiikka</h4>
		<p>Metodissa <code>kaynnista</code>olevan <code>while</code>-silmukan j&auml;lkeen kutsutaan metodia <code>statistiikka</code>. Metodin on tarkoitus tulostaa kuinka montaa kertaa laskinoliolla suoritettiin joku laskutoimenpide. Esim:</p>
		<pre>
komento: summa
luku1: 4
luku2: 6
lukujen summa 10

komento: tulo
luku1: 3
luku2: 2
lukujen tulo 6

komento: lopetus
Laskuja laskettiin 2
</pre>
		<p>Toteuta metodi <code>private void statistiikka()</code>, ja tee statistiikan ker&auml;&auml;miseen tarvittavat muutokset muualle Laskin-luokan koodiin.</p>
		<p>Huom: jos ohjelmalle annetaan virheellinen komento (eli joku muu kuin summa, erotus, tulo, tai lopetus), ei laskin reagoi komentoon mill&auml;&auml;n tavalla vaan jatkaa kysym&auml;ll&auml; seuraavaa komentoa. Statistiikka ei saa laskea virheellist&auml; komentoa laskutoimenpiteeksi.</p>
		<pre>
komento: integraali
komento: erotus
luku1: 3
luku2: 2
lukujen erotus 1

komento: lopetus
Laskuja laskettiin 1
</pre>
	</div>
	<h2>
		Alkeis- ja viittaustyyppiset muuttujat</h2>
	<p>Java on vahvasti tyypitetty kieli, eli kaikilla sen muuttujilla on <em>tyyppi</em>. Muuttujatyypit voidaan jakaa kahteen kategoriaan; alkeis- ja viittaustyyppisiin muuttujiin. Kummankin kategorian muuttujatyypeill&auml; on oma &quot;lokero&quot;, joka sis&auml;lt&auml;&auml; niihin liittyv&auml;n arvon. Alkeistyyppisill&auml; muuttujilla muuttujien konkreettinen <em>arvo</em> tallennetaan lokeroon, kun taas viittaustyyppisten muuttujien lokero sis&auml;lt&auml;&auml; viitteen muuttujaan liittyv&auml;&auml;n konkreettiseen <em>olioon</em>.</p>
	<p>Oliot eiv&auml;t mahdu lokeroihin, vaan niihin viitataan aina.</p>
	<h3>
		Alkeistyyppiset muuttujat</h3>
	<p>Alkeistyyppisen muuttujan arvo tallennetaan muuttujaa varten luotuun lokeroon. Jokaisella alkeistyyppisell&auml; muuttujalla on oma lokero ja oma arvo. Muuttujalle luodaan uusi lokero silloin kun se esitell&auml;&auml;n (esim. <code>int numero;</code>). Lokeroon asetetaan arvo sijoitusoperaatiolla <code>=</code>. Alla on esimerkki alkeistyyppisen int (kokonaisluku) -muuttujan esittelemisest&auml; ja arvon asettamisesta samassa lausekkeessa.</p>
	<pre class="sh_java">
int numero = 42;
</pre>
	<p>Alkeistyyppisi&auml; muuttujia ovat muun muassa <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code>sek&auml; harvemmin k&auml;ytt&auml;m&auml;mme <code>short</code>, <code>float</code>, <code>byte</code>ja <code>long</code>. My&ouml;s <code>void</code>on alkeistyyppi, mutta sill&auml; ei ole omaa lokeroa tai arvoa. Void-tyyppi&auml; k&auml;ytet&auml;&auml;n silloin kun halutaan ilmaista ett&auml; metodi ei palauta mit&auml;&auml;n arvoa.</p>
	<p>Esitell&auml;&auml;n seuraavaksi kaksi alkeistyyppist&auml; muuttujaa ja asetetaan niihin arvot.</p>
	<pre class="sh_java">
int vitonen = 5;
int kutonen = 6;
</pre>
	<p>Yll&auml; esiteltyjen alkeistyyppisten muuttujien nimet ovat <code>vitonen</code>ja <code>kutonen</code>. Muuttujaa <code>vitonen</code>luodessa sit&auml; varten luotuun <em>lokeroon</em> asetetaan arvo 5 (<code>int vitonen = 5;</code>). Muuttujaa <code>kutonen</code>luodessa sit&auml; varten luotuun lokeroon asetetaan arvo 6 (<code>int kutonen = 6;</code>). Muuttujat <code>vitonen</code>ja <code>kutonen</code>ovat kumpikin <code>int</code>-tyyppisi&auml;, eli kokonaislukuja.</p>
	<p>Alkeistyyppiset muuttujat voi visualisoida laatikkoina joiden sis&auml;lle kuhunkin muuttujaan liittyv&auml; arvo on tallennettu:</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen.png" /></p>
	<p>Tarkastellaan seuraavaksi alkeistyyppisten muuttujien arvojen kopioitumista.</p>
	<pre class="sh_java">
int vitonen = 5;
int kutonen = 6;

vitonen = kutonen; // muuttuja vitonen sis&auml;lt&auml;&auml; nyt arvon 6, eli arvon joka oli muuttujassa kutonen
kutonen = 64; // muuttuja kutonen sis&auml;lt&auml;&auml; nyt arvon 64

// muuttuja vitonen sis&auml;lt&auml;&auml; viel&auml;kin arvon 6
</pre>
	<p>Yll&auml; esitell&auml;&auml;n muuttujat <code>vitonen</code>ja <code>kutonen</code>ja asetetaan niihin arvot. T&auml;m&auml;n j&auml;lkeen muuttujan <code>vitonen</code>lokeroon kopioidaan muuttujan <code>kutonen</code>lokeron sis&auml;lt&auml;m&auml; arvo (<code>vitonen = kutonen;</code>). T&auml;ss&auml; vaiheessa muuttujan <code>vitonen</code>lokeroon kopioituu muuttujan <code>kutonen</code>sis&auml;lt&auml;m&auml; arvo. Jos muuttujan <code>kutonen</code>arvoa muutetaan t&auml;m&auml;n j&auml;lkeen, ei muuttujan <code>vitonen</code>sis&auml;lt&auml;m&auml; arvo muutu: muuttujan <code>vitonen</code>arvo on sen omassa lokerossa eik&auml; liity muuttujan <code>kutonen</code>lokerossa olevaan arvoon mill&auml;&auml;n tavalla. Lopputilanne kuvana.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen-64.png" /></p>
	<h4>
		Alkeistyyppinen muuttuja metodin parametrina ja paluuarvona</h4>
	<p>Kun alkeistyyppinen muuttuja annetaan metodille parametrina, asetetaan metodin parametrimuuttujaan kopio annetun muuttujan lokerossa olevasta. K&auml;yt&auml;nn&ouml;ss&auml; my&ouml;s metodin parametrimuuttujilla on omat lokerot, joihin arvo kopioidaan kuten asetuslauseessa. Katsotaan seuraavaa metodia <code>lisaaLukuun(int luku, int paljonko)</code>.</p>
	<pre class="sh_java">
public int lisaaLukuun(int luku, int paljonko) {
    return luku + paljonko;
}
</pre>
	<p>Metodi <code>lisaaLukuun</code>saa kaksi parametria, kokonaisluvut <code>luku</code>ja <code>paljonko</code>. Metodi palauttaa uuden luvun, joka on annettujen parametrien summa. Tutkitaan viel&auml; metodin kutsumista.</p>
	<pre class="sh_java">
int omaLuku = 10;
omaLuku = lisaaLukuun(omaLuku, 15);
// muuttuja omaLuku sis&auml;lt&auml;&auml; nyt arvon 25
</pre>
	<p>Esimerkiss&auml; kutsutaan <code>lisaaLukuun</code>-metodia muuttujalla <code>omaLuku</code>ja arvolla <code>15</code>. Metodin muuttujiin <code>luku</code>ja <code>paljonko</code>kopioituvat arvot 10, eli muuttujan <code>omaLuku</code>sis&auml;lt&ouml;, ja 15. Metodi palauttaa muuttujien <code>luku</code>ja <code>paljonko</code>summan, eli <code>10 + 15 = 25</code>.</p>
	<p>Huom! Edellisess&auml; esimerkiss&auml; muuttujan <code>omaLuku</code>arvo muuttuu ainoastaan koska metodin <code>lisaaLukuun</code>palauttama arvo asetetaan siihen sijoituslausekkeella (<code>omaLuku = lisaaLukuun(omaLuku, 15);</code>). Jos metodin <code>lisaaLukuun</code>kutsu olisi seuraavanlainen, ei muuttujan <code>omaLuku</code>arvo muutu.</p>
	<pre class="sh_java">
int omaLuku = 10;
lisaaLukuun(omaLuku, 15);
// muuttuja omaLuku sis&auml;lt&auml;&auml; viel&auml;kin arvon 10
</pre>
	<h4>
		Minimi- ja maksimiarvot</h4>
	<p>Eri tietotyypeill&auml; on omat minimi- ja maksimiarvonsa, eli arvot joita pienempi&auml; tai suurempia ne eiv&auml;t voi olla. T&auml;m&auml; johtuu Javan (ja useimpien ohjelmointikielten) sis&auml;isest&auml; tiedon esitysmuodosta, jossa tietotyyppien koot on ennalta m&auml;&auml;r&auml;tty.</p>
	<p>Alla muutama Javan alkeistyyppi ja niiden minimi- ja maksimiarvot</p>
	<p>&nbsp;</p>
	<table cellspacing="5">
		<tbody>
			<tr>
				<th>
					Muuttujatyyppi</th>
				<th>
					Selitys</th>
				<th>
					Minimiarvo</th>
				<th>
					Maksimiarvo</th>
			</tr>
			<tr>
				<td>
					int</td>
				<td>
					Kokonaisluku</td>
				<td>
					-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td>
				<td>
					2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td>
			</tr>
			<tr>
				<td>
					long</td>
				<td>
					Iso kokonaisluku</td>
				<td>
					-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td>
				<td>
					9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td>
			</tr>
			<tr>
				<td>
					boolean</td>
				<td>
					Totuusarvo</td>
				<td colspan="2">
					<code>true</code>tai <code>false</code></td>
			</tr>
			<tr>
				<td>
					double</td>
				<td>
					Liukuluku</td>
				<td>
					<code>Double.MIN_VALUE</code></td>
				<td>
					<code>Double.MAX_VALUE</code></td>
			</tr>
		</tbody>
	</table>
	<p>&nbsp;</p>
	<p><strong>Py&ouml;ristysvirheet</strong></p>
	<p>Liukulukuja k&auml;ytt&auml;ess&auml; kannattaa muistaa ett&auml; liukuluvun arvo on aina <em>arvio</em> oikeasta arvosta. Koska liukuluvun, kuten kaikkien muidenkin alkeistyyppien sis&auml;lt&auml;m&auml; tietom&auml;&auml;r&auml; on rajoitettu, voidaan huomata yll&auml;tt&auml;vi&auml;kin py&ouml;ristysvirheit&auml;. Esimerkiksi seuraava tilanne.</p>
	<pre class="sh_java">
double eka = 0.39;
double toka = 0.35;
System.out.println(eka - toka);
</pre>
	<p>Esimerkki tulostaa arvon <code>0.040000000000000036</code>. Ohjelmointikielet tarjoavat usein ty&ouml;kalut liukulukujen tarkempaa k&auml;sittely&auml; varten. Esimerkiksi Javassa on luokka <em>BigDecimal</em>, johon voi asettaa &auml;&auml;rett&ouml;m&auml;n pitki&auml; liukulukuja.</p>
	<p>Liukulukuja vertaillessa py&ouml;ristysvirheisiin varaudutaan usein vertaamalla arvojen et&auml;isyytt&auml; toisistaan. Esimerkiksi edellisen esimerkin muuttujia k&auml;ytett&auml;ess&auml; vertailu <code>eka - toka == 0.4</code>ei tuota toivottua tulosta py&ouml;ristysvirheen takia.</p>
	<pre class="sh_java">
double eka = 0.39;
double toka = 0.35;

if((eka - toka) == 0.4) {
    System.out.println(&quot;Vertailu onnistui!&quot;);
} else {
    System.out.println(&quot;Vertailu ep&auml;onnistui!&quot;);
}
</pre>
	<pre>
Vertailu ep&auml;onnistui!
</pre>
	<p>Arvon et&auml;isyytt&auml; jostain luvusta voi tarkastella esimerkiksi seuraavasti. Apufunktio <code>Math.abs</code>palauttaa sille annetun luvun itseisarvon.</p>
	<pre class="sh_java">
double eka = 0.39;
double toka = 0.35;

double etaisyys = 0.4 - (eka - toka);

if(Math.abs(etaisyys) &lt; 0.0001) ) {
    System.out.println(&quot;Vertailu onnistui!&quot;);
} else {
    System.out.println(&quot;Vertailu ep&auml;onnistui!&quot;);
}
</pre>
	<h3>
		Viittaustyyppi</h3>
	<p>Viittaustyyppiset muuttujat tallentavat niihin liittyv&auml;n tiedon viitteen taakse eli &quot;langan p&auml;&auml;h&auml;n&quot;. Viittaustyyppisten muuttujien lokerossa on viite tiedon sis&auml;lt&auml;v&auml;&auml;n paikkaan. Toisin kuin alkeistyyppisill&auml; muuttujilla, viittaustyyppisill&auml; muuttujilla ei ole rajoitettua arvoaluetta, koska niiden oikea arvo tai <em>tieto</em> on viitteen takana. Oleellinen ero alkeistyyppisiin muuttujiin on se, ett&auml; eri viittaustyyppiset muuttujat voivat viitata samaan paikkaan.</p>
	<p>Viittaustyyppisist&auml; muuttujista puhutaan olioina, joita luodaan <code>new</code>-kutsulla. Muuttujan arvo asetetaan viel&auml;kin sijoitusoperaattorilla <code>=</code>, mutta komento <code>new</code>luo olion ja palauttaa viitteen olioon. Viite asetetaan muuttujaan liittyv&auml;&auml;n lokeroon eli sen arvoksi. Tutkitaan kahden viittaustyyppisen muuttujan luontia. Esimerkeiss&auml; k&auml;ytet&auml;&auml;n seuraavaa luokkaa <em>Laskuri</em>:</p>
	<pre class="sh_java">
public class Laskuri {
    private int arvo;

    public Laskuri(int alkuarvo) {  // Konstruktori
        this.arvo = alkuarvo;
    }

    public void kasvataArvoa() {
        this.arvo = this.arvo + 1;
    }

    public int annaArvo() {
        return arvo;
   }
}
</pre>
	<p>P&auml;&auml;ohjelma:</p>
	<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);
</pre>
	<p>Esimerkiss&auml; luodaan ensin viittaustyyppinen muuttuja <code>bonusLaskuri</code>(<code>Laskuri bonusLaskuri = new Laskuri(5);</code>). Komentoa <code>new</code>kutsuessa varataan tila muuttujan tietoa varten, suoritetaan <code>new</code>-kutsua seuraavan konstruktorin koodi, ja palautetaan viite juuri luotuun olioon. Konstruktori suorittaa mahdolliset muutokset olioon liittyv&auml;&auml;n tilaan. Esimerkiss&auml; luodaan Laskuri-tyyppinen olio, ja palautetaan viite siihen. Palautettu viite asetetaan sijoitusoperaattorilla <code>=</code>muuttujaan <code>bonusLaskuri</code>. Sama tapahtuu muuttujalle nimelt&auml; <code>axeLaskuri</code>. Kuvana viittaustyyppi kannattaa ajatella siten, ett&auml; muuttuja sis&auml;lt&auml;&auml; &quot;langan&quot; tai &quot;nuolen&quot;, jonka p&auml;&auml;ss&auml; on olio itse. Muuttuja ei siis sis&auml;ll&auml; oliota, vaan viitteen olioon liittyviin tietoihin.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit.png" /></p>
	<p>Tutkitaan seuraavaksi viittaustyyppisen muuttujan kopioitumista.</p>
	<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sis&auml;lt&auml;m&auml; viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6
</pre>
	<p>Viittaustyyppist&auml; muuttujaa kopioitaessa (yll&auml; <code>bonusLaskuri = axeLaskuri;</code>) muuttujan viite kopioituu. Yll&auml; muuttujan <code>bonusLaskuri</code>lokeroon kopioituu muuttujan <code>axeLaskuri</code>lokerossa oleva viite. Nyt kummatkin oliot viittaavat samaan paikkaan!</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-3.png" /></p>
	<p>Jatketaan yll&auml; olevaa esimerkki&auml; ja asetetaan muuttujaan <code>axeLaskuri</code>uusi viite, joka osoittaa kutsulla <code>new Laskuri(10)</code>luotuun olioon.</p>
	<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sis&auml;lt&auml;m&auml; viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6

axeLaskuri = new Laskuri(10); // muuttujaan axeLaskuri asetetaan uusi viite, joka osoittaa
                              // new Laskuri(10) - kutsulla luotuun Laskuri-olioon

// muuttuja bonusLaskuri sis&auml;lt&auml;&auml; viel&auml;kin viitteen Laskuri-olioon, joka sai konstruktorissaan arvon 6
</pre>
	<p>Esimerkiss&auml; tehd&auml;&auml;n k&auml;yt&auml;nn&ouml;ss&auml; samat operaatiot kuin alkeistyyppi-kappaleessa olevassa asetusesimerkiss&auml;. &Auml;skeisess&auml; esimerkiss&auml; kopioimme viittaustyyppisten muuttujien viitteit&auml;, kun taas alkeistyyppisiin muuttujiin liittyv&auml;ss&auml; esimerkiss&auml; kopioimme alkeistyyppien arvoja. Kummassakin tapausessa siis lokeron sis&auml;lt&ouml; kopioidaan, alkeistyyppisten muuttujien lokero sis&auml;lt&auml;&auml; arvon, viittaustyyppisten muuttujien lokero sis&auml;lt&auml;&auml; viitteen.</p>
	<p>Edellisen esimerkin lopussa kukaan ei viittaa Laskuriolioon, joka sai arvokseen 5 sen konstruktorissa. Javassa oleva roskienkeruumekanismi k&auml;y ajallaan poistamassa t&auml;llaiset turhat oliot. Lopputilanne kuvana:</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-2.png" /></p>
	<p>Tarkastellaan viel&auml; kolmatta esimerkki&auml;, joka n&auml;ytt&auml;&auml; viite- ja alkeistyyppisten muuttujien oleellisen eron.</p>
	<pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sis&auml;lt&auml;m&auml; viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6

axeLaskuri.kasvataArvoa(); // kasvatetaan axeLaskuri-viitteen takana olevan olion arvoa yhdell&auml;

System.out.println(bonusLaskuri.annaArvo());
System.out.println(axeLaskuri.annaArvo());
</pre>
	<pre>
7
7
</pre>
	<p>Koska asetuksen <code>bonusLaskuri = axeLaskuri;</code>j&auml;lkeen <code>bonusLaskuri</code>-muuttuja viittaa samaan olioon kuin <code>axeLaskuri</code>-muuttuja, on kummankin laskurin arvo 7 vaikka kasvatuksia on tehty vain yksi. T&auml;m&auml; johtuu siit&auml; ett&auml; kummatkin laskurit viittaavat samaan olioon.</p>
	<p>Kuvana tilanne on ehk&auml; selke&auml;mpi. Kutsu <code>axeLaskuri.kasvataArvoa()</code>kasvattaa muuttujan <code>axeLaskuri</code>viittaaman olion sis&auml;lt&auml;m&auml;&auml; muuttujan <code>arvo</code>arvoa yhdell&auml;. Koska muuttuja <code>bonusLaskuri</code>viittaa samaan olioon, palauttaa kutsu <code>bonusLaskuri.annaArvo()</code>saman muuttujan arvon, jota aiempi kutsu <code>axeLaskuri.kasvataArvoa()</code>kasvatti.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-4.png" /></p>
	<p>Viittaustyyppiset muuttujat viittaavat aina toisaalla oleviin olioihin. Useat viittaustyyppiset muuttujat voivat sis&auml;lt&auml;&auml; saman viitteen, jolloin kaikki muuttujat osoittavat samaan olioon. Seuraavassa esimerkiss&auml; on kolme viittaustyyppist&auml; muuttujaa, jotka kaikki osoittavat samaan <code>Laskuri</code>-olioon.</p>
	<pre class="sh_java">
Laskuri bonus = new Laskuri(5);
Laskuri ihq = bonus;
Laskuri lennon = bonus;
</pre>
	<p>Esimerkiss&auml; luodaan vain yksi <code>Laskuri</code>-olio, mutta kaikki kolme <code>Laskuri</code>-tyyppist&auml; muuttujaa osoittavat lopussa siihen. T&auml;ll&ouml;in kaikki metodikutsut viitteille <code>bonus</code>, <code>ihq</code>ja <code>lennon</code>muokkaavat samaa oliota. Viel&auml; kerran: viittaustyyppisi&auml; muuttujia kopioitaessa viitteet kopioituvat. Kuvana:</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-5.png" /></p>
	<p>Katsotaan kopioitumista viel&auml; esimerkill&auml;.</p>
	<pre class="sh_java">
Laskuri bonus = new Laskuri(5);
Laskuri ihq = bonus;
Laskuri lennon = bonus;

lennon = new Laskuri(3);
</pre>
	<p>Kun muuttujan <code>lennon</code>sis&auml;lt&ouml;, eli viite muuttuu, se ei vaikuta muuttujien <code>bonus</code>tai <code>ihq</code>sis&auml;lt&auml;miin viitteisiin. Muuttujan arvoa asetettaessa muutetaan aina vain muuttujan oman lokeron sis&auml;lt&ouml;&auml;. Kuvana:</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-6.png" /></p>
	<h4>
		Viittaustyyppinen muuttuja metodin parametrina</h4>
	<p>Kun viittaustyyppinen muuttuja annetaan parametrina metodille, luodaan metodin parametrimuuttujalle kopio annetusta muuttujan viitteest&auml;. Parametrimuuttujalla on siis oma lokero, johon viite kopioidaan. Alkeistyyppisist&auml; muuttujista poiketen kopioimme viitteen, emmek&auml; arvoa, eli voimme muokata viitteen takana olevaa oliota my&ouml;s metodin sis&auml;ll&auml;. Oletetaan ett&auml; metodimme on alla esitelty <code>public void lisaaLaskuriin(Laskuri laskuri, int paljonko)</code>.</p>
	<pre class="sh_java">
public void lisaaLaskuriin(Laskuri laskuri, int paljonko) {
    for (int i = 0; i &lt; paljonko; i++) {
        laskuri.kasvataArvoa();
    }
}
</pre>
	<p>Metodille <code>lisaaLaskuriin</code>annetaan kaksi parametria, viittaustyyppinen muuttuja ja alkeistyyppinen muuttuja. Kumpaankin muuttujaan liittyv&auml;n lokeron sis&auml;lt&ouml; kopioidaan metodin parametrimuuttujien omiin lokeroihin. Viittaustyyppiselle parametrimuuttujalle <code>laskuri</code>kopioituu viite ja alkeistyyppiselle parametrimuuttujalle <code>paljonko</code>kopioituu arvo. Metodi kutsuu <code>Laskuri</code>-tyyppisen parametrin metodia <code>kasvataArvoa()</code><code>paljonko</code>-muuttujan sis&auml;lt&auml;m&auml;n arvon m&auml;&auml;r&auml;n. Tutkitaan viel&auml; metodin kutsumista.</p>
	<pre class="sh_java">
int kertoja = 10;

Laskuri bonus = new Laskuri(10);
lisaaLaskuriin(bonus, kertoja);
// muuttujan bonus sis&auml;inen arvo on nyt 20
</pre>
	<p>Esimerkiss&auml; kutsutaan <code>lisaaLaskuriin()</code>-metodia muuttujilla <code>bonus</code>ja <code>kertoja</code>. Metodin parametrimuuttujiin <code>laskuri</code>ja <code>paljonko</code>kopioituvat siis viittaustyyppisen muuttujan <code>bonus</code>viite, ja alkeistyyppisen muuttujan <code>kertoja</code>arvo <code>10</code>. Metodi suorittaa metodissa olevalle muuttujalle <code>laskuri</code><code>paljonko</code>muuttujan m&auml;&auml;rittelem&auml;n m&auml;&auml;r&auml;n <code>kasvataArvoa()</code>-metodikutsuja. T&auml;m&auml; kuvana:</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-7.png" /></p>
	<p><em>Metodissa on siis p&auml;&auml;ohjelmasta t&auml;ysin erilliset muuttujat!</em></p>
	<p>Viittaustyyppisest&auml; muuttujasta kopioituu metodin sis&auml;iseen muuttujaan viite, eli metodin sis&auml;inen muuttuja viittaa viel&auml;kin samaan olioon. Alkeistyyppisest&auml; muuttujasta kopioituu arvo, eli metodin sis&auml;isell&auml; muuttujalla on t&auml;ysin oma arvonsa.</p>
	<p>Metodi n&auml;kee saman laskurin johon muuttuja <code>bonus</code>viittaa, eli metodin tekem&auml; muutos vaikuttaa suoraan olioon. Alkeistyyppien suhteen tilanne on toinen, eli metodille tulee ainoastaan kopio muuttujan <code>kertoja</code>arvosta. Metodista k&auml;sin ei siis voi muuttaa alkeistyyppisten muuttujien arvoja.</p>
	<h4>
		Viittaustyyppinen muuttuja metodin paluuarvona</h4>
	<p>Kun metodi palauttaa viittaustyyppisen muuttujan, palauttaa se viitteen muualla sijaitsevaan olioon. Metodin palauttaman viittaustyyppisen muuttujan voi asettaa muuttujalle samalla tavalla kuin normaalikin asetus tapahtuu, eli yht&auml;suuruusmerkin avulla. Katsotaan metodia <code>public Laskuri luoLaskuri(int alkuarvo)</code>, joka luo uuden viittaustyyppisen muuttujan.</p>
	<pre class="sh_java">
public Laskuri luoLaskuri(int alkuarvo) {
    return new Laskuri(alkuarvo);
}
</pre>
	<p>Metodi luoLaskuri palauttaa metodissa luotuun olioon viittaavan viitteen <code>uusiLaskuri</code>. Uusi olio luodaan aina metodia kutsuttaessa, seuraavassa esimerkiss&auml; luomme kaksi erillist&auml; <code>Laskuri</code>-tyyppist&auml; oliota.</p>
	<pre class="sh_java">
Laskuri bonus  = luoLaskuri(10);
Laskuri lennon = luoLaskuri(10);
</pre>
	<p>Metodi <code>luoLaskuri</code>luo aina uuden <code>Laskuri</code>-tyyppisen olion. Ensimm&auml;isess&auml; kutsussa, eli kutsussa <code>Laskuri bonus = luoLaskuri(10);</code>asetetaan metodin palauttama viite viittaustyyppiseen muuttujaan <code>bonus</code>. Toisessa metodikutsussa luodaan uusi viite, joka asetetaan muuttujaan <code>lennon</code>. Muuttujat <code>bonus</code>ja <code>lennon</code>eiv&auml;t sis&auml;ll&auml; samaa viitett&auml;, sill&auml; metodi luo aina uuden olion ja palauttaa viitteen luotuun olioon.</p>
	<h2 id="stat_ja_ei">
		Static ja ei-static</h2>
	<p>Kerrataan ja t&auml;smennet&auml;&auml;n Ohjelmoinnin perusteiden luvussa 30 k&auml;sitelty&auml; asiaa. Staattisilla ja ei-staattisilla metodeilla erotetaan se, mihin muuttuja tai metodi liittyy. Staattiset metodit liittyv&auml;t aina luokkaan, kun taas ei-staattiset metodit voivat muokata olion omia muuttujia.</p>
	<h3>
		Static, luokkakirjastot ja final</h3>
	<p>Static-m&auml;&auml;reen saavat metodit eiv&auml;t liity olioihin vaan luokkiin. On mahdollista m&auml;&auml;ritell&auml; my&ouml;s luokkakohtaisia muuttujia lis&auml;&auml;m&auml;ll&auml; muuttujan eteen m&auml;&auml;re <code>static</code>. Esimerkiksi <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code>ja <code>Double.MAX_VALUE</code>ovat kaikki staattisia muuttujia. Staattisia muuttujia ja metodeja k&auml;ytet&auml;&auml;n luokan nimen kautta, esimerkiksi <code>LuokanNimi.muuttuja</code>tai <code>LuokanNimi.metodi()</code>.</p>
	<p>Luokkakirjastoksi kutsutaan luokkaa, jossa on yleisk&auml;ytt&ouml;isi&auml; metodeja ja muuttujia. Esimerkiksi Javan <code>Math</code>-luokka on luokkakirjasto. Se tarjoaa muun muassa <code>Math.PI</code>-muuttujan. Omien luokkakirjastojen toteuttaminen on usein hy&ouml;dyllist&auml;. Esimerkiksi Helsingin Seudun Liikenne (HSL) voisi pit&auml;&auml; lippujensa hintoja luokkakirjastossa, josta ne l&ouml;ytyisi tarvittaessa.</p>
	<pre class="sh_java">
public class HslHinnasto {
    public static final double KERTALIPPU_AIKUINEN = 2.50;
    public static final double RAITIOVAUNULIPPU_AIKUINEN = 2.50;
}
</pre>
	<p>Avainsana <code>final</code>muuttujan m&auml;&auml;rittelyss&auml; kertoo ettei muuttujaan voi asettaa uutta arvoa kun se on kerran asetettu. Final-tyyppiset muuttujat ovat vakioita, ja niiden tulee sis&auml;lt&auml;&auml; aina arvo. Esimerkiksi luokkamuuttuja <code>Integer.MAX_VALUE</code>on vakiotyyppinen luokkamuuttuja. Sill&auml; on final-m&auml;&auml;re, joten sit&auml; ei voi muuttaa.</p>
	<p>Jos k&auml;yt&ouml;ss&auml;mme on yll&auml; esitelty luokka <code>HslHinnasto</code>, voivat kaikki ohjelmat, jotka k&auml;ytt&auml;v&auml;t kerta- tai raitiovaunulipun hintaa k&auml;ytt&auml;&auml; niit&auml; <code>HslHinnasto</code>-luokan kautta. Seuraavassa esimerkiss&auml; esitell&auml;&auml;n luokka <code>Ihminen</code>, jolla on metodi <code>onkoRahaaKertalippuun()</code>, joka k&auml;ytt&auml;&auml; <code>HslHinnasto</code>-luokasta l&ouml;ytyv&auml;&auml; lipun hintaa.</p>
	<pre class="sh_java">
public class Ihminen {
    private String nimi;
    private double rahat;
    // muut oliomuuttujat

    // konstruktori

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat &gt;= HslHinnasto.KERTALIPPU_AIKUINEN) {
            return true;
        }

        return false;
    }

    // muut luokkaan Ihminen liittyv&auml;t metodit
}
</pre>
	<p>Metodi <code>public boolean onkoRahaaKertalippuun()</code>vertaa luokan <code>Ihminen</code>oliomuuttujaa <code>rahat</code><code>HslHinnasto</code>-luokan staattiseen muuttujaan <code>KERTALIPPU_AIKUINEN</code>. Metodia <code>onkoRahaaKertalippuun()</code>voi kutsua vain olioviitteen kautta. Esimerkiksi:</p>
	<pre class="sh_java">
Ihminen matti = new Ihminen();

if (matti.onkoRahaaKertalippuun()) {
    System.out.println(&quot;Ostetaan kertalippu.&quot;);
} else {
    System.out.println(&quot;Menn&auml;&auml;n pummilla.&quot;);
}
</pre>
	<p>Huomaa nime&auml;misk&auml;yt&auml;nt&ouml;! Kaikki staattiset <em>alkeistyyppiset</em> muuttujat kirjoitetaan ISOLLA_JA_ALAVIIVOILLA. Staattiset metodit toimivat vastaavasti. Esimerkiksi Luokka <code>HslHinnasto</code>saattaisi <em>kapseloida</em> muuttujat ja antaa vain <em>aksessorit</em> niihin. Aksessoriksi kutsutaan metodia, jolla voi joko lukea muuttujan arvon tai sijoittaa muuttujalle uuden arvon.</p>
	<pre class="sh_java">
public class HslHinnasto {
  private static final double KERTALIPPU_AIKUINEN = 2.50;
  private static final double RAITIOVAUNULIPPU_AIKUINEN = 2.50;

  public static double annaKertalipunHinta() {   // Aksessori
    return KERTALIPPU_AIKUINEN;
  }

  public static double annaRaitiovaunulipunHinta() {   // Aksessori
    return RAITIOVAUNULIPPU_AIKUINEN;
  }
}
</pre>
	<p>T&auml;ll&ouml;in <code>Ihminen</code>-luokan toteutuksessa tulee kutsua metodia<code>annaKertalipunHinta()</code>sen sijaan ett&auml; kutsuttaisiin muuttujaa suoraan. Palaamme n&auml;kyvyysm&auml;&auml;reiden <code>public</code>ja <code>private</code>tarkempaan merkitykseen kohta.</p>
	<pre class="sh_java">
public class Ihminen {
    private String nimi;
    private double rahat;
    // muut oliomuuttujat

    // konstruktori

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat &gt;= HslHinnasto.annaKertalipunHinta()) {
            return true;
        }

        return false;
    }

    // muut luokkaan Ihminen liittyv&auml;t metodit
}
</pre>
	<h3>
		Ei-static</h3>
	<p>Ei-staattiset metodit ja muuttujat liittyv&auml;t olioihin. Oliomuuttujat, eli attribuutit m&auml;&auml;ritell&auml;&auml;n luokan alussa. Kun olio luodaan <code>new</code>-kutsulla, kaikille oliomuuttujille varataan tila olioon liittyv&auml;n viitteen p&auml;&auml;h&auml;n. Muuttujien arvot ovat oliokohtaisia, eli jokaisella oliolla on omat muuttujien arvot. Tutkitaan taas luokkaa <code>Ihminen</code>, jolla on oliomuuttujat <code>nimi</code>ja <code>rahat</code>.</p>
	<pre class="sh_java">
public class Ihminen {
  private String nimi;
  private double rahat;

  // muut tiedot
}
</pre>
	<p>Kun luokasta <em>Ihminen</em> luodaan uusi ilmentym&auml;, alustetaan my&ouml;s siihen liittyv&auml;t muuttujat. Jos viittaustyyppist&auml; muuttujaa <code>nimi</code>ei alusteta, saa se arvokseen <em>null</em>-viitteen. Lis&auml;t&auml;&auml;n luokan <em>Ihminen</em> toteutukseen viel&auml; <em>konstruktori</em> ja muutama metodi.</p>
	<pre class="sh_java">
public class Ihminen {
    private String nimi;
    private double rahat;

    // konstruktori
    public Ihminen(String nimi, double rahat) {
        this.nimi = nimi;
        this.rahat = rahat;
    }

    public String getNimi() {
        return this.nimi;
    }

    public double getRahat() {
        return this.rahat;
    }

    public void lisaaRahaa(double summa) {
        if(summa &gt; 0) {
          this.rahat += summa;
        }
    }

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat &gt;= HslHinnasto.annaKertalipunHinta()) {
            return true;
        }

        return false;
    }
}
</pre>
	<p>Konstruktori <code>Ihminen(String nimi, double rahat)</code>luo uuden ihmisolion ja palauttaa viitteen siihen. Aksessori <code>getNimi()</code>palauttaa viitteen <code>nimi</code>-olioon, ja <code>getRahat()</code>-metodi palauttaa alkeistyyppisen muuttujan <code>rahat</code>. Metodi <code>lisaaRahaa(double summa)</code>lisaa oliomuuttujaan <code>rahat</code>parametrina annetun summan jos parametrin arvo on suurempi kuin 0.</p>
	<p>Oliometodeja kutsutaan olion viitteen kautta. Seuraava koodiesimerkki luo uuden Ihmis-olion, lis&auml;&auml; sille rahaa, ja lopuksi tulostaa sen nimen. Huomaa ett&auml; metodikutsut ovat muotoa <code>olionNimi.metodinNimi()</code></p>
	<pre class="sh_java">
Ihminen matti = new Ihminen(&quot;Matti&quot;, 5.0);
matti.lisaaRahaa(5); // lottovoitto!

if (matti.onkoRahaaKertalippuun()) {
    System.out.println(&quot;Ostetaan kertalippu.&quot;);
} else {
    System.out.println(&quot;Menn&auml;&auml;n pummilla.&quot;);
}
</pre>
	<p>Esimerkki tulostaa &quot;<code>Ostetaan kertalippu</code>&quot;.</p>
	<h4>
		Metodit luokan sis&auml;ll&auml;</h4>
	<p>Luokan sis&auml;isi&auml; ei-staattisia metodeja voi kutsua my&ouml;s ilman olio-etuliitett&auml; metodiin liittyviss&auml; luokissa. Esimerkiksi seuraava <code>toString()</code>-metodi <code>Ihminen</code>luokalle, joka kutsuu olioon liittyv&auml;&auml; metodia <code>getNimi()</code>.</p>
	<pre class="sh_java">
public class Ihminen {
    // aiemmin toteutetun luokan sis&auml;lt&ouml;

    public String toString() {
        return this.getNimi();
    }
}
</pre>
	<p>Metodi <code>toString()</code>kutsuu siis luokan sis&auml;ist&auml; juuri k&auml;sitelt&auml;v&auml;&auml;n olioon liittyv&auml;&auml; <code>getNimi()</code>-metodia. Etuliite <code>this</code>korostaa kutsun liittyv&auml;n juuri t&auml;h&auml;n olioon.</p>
	<p>Ei-staattiset metodit voivat kutsua my&ouml;s staattisia, eli luokkakohtaisia metodeja. Toisaalta, luokkakohtaiset metodit eiv&auml;t voi kutsua oliokohtaisia metodeja ilman viitett&auml; itse olioon, sill&auml; ilman viitett&auml; ei p&auml;&auml;st&auml; k&auml;siksi olioon liittyviin tietoihin.</p>
	<h4>
		Muuttujat metodien sis&auml;ll&auml;</h4>
	<p>Metodien sis&auml;ll&auml; m&auml;&auml;ritelt&auml;v&auml;t muuttujat ovat metodien suorituksessa k&auml;ytett&auml;vi&auml; apumuuttujia, eik&auml; niit&auml; tule sekoittaa oliomuuttujiin. Alla esimerkki metodista, jossa luodaan metodiin paikallinen muuttuja. Muuttuja <code>indeksi</code>on olemassa ja k&auml;yt&ouml;ss&auml; vain metodin suorituksen ajan.</p>
	<pre class="sh_java">
public class ... {
    ...

    public static void tulostaTaulukko(String[] taulukko) {
        int indeksi = 0;

        while(indeksi &lt; taulukko.length) {
            System.out.println(taulukko[indeksi]);
            indeksi++;
        }
    }
}
</pre>
	<p>Metodissa <code>tulostaTaulukko()</code>luodaan apumuuttuja <code>indeksi</code>jota k&auml;ytet&auml;&auml;n taulukon l&auml;pik&auml;ynniss&auml;. Muuttuja <code>indeksi</code>on olemassa vain metodin suorituksen ajan.</p>
	<div class="tehtavat">
		<h3>
			Tavara, Matkalaukku ja Lastiruuma</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;sarjassa tehd&auml;&auml;n luokat <code>Tavara</code>, <code>Matkalaukku</code>ja <code>Lastiruuma</code>, joiden avulla harjoitellaan olioita, jotka sis&auml;lt&auml;v&auml;t toisia olioita.</p>
		<h4 class="req">
			Tavara-luokka</h4>
		<p>Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).</p>
		<p>Lis&auml;&auml; luokkaan seuraavat metodit:</p>
		<ul>
			<li>
				Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
			<li>
				Metodi <code>public String getNimi()</code>, joka palauttaa tavaran nimen</li>
			<li>
				Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
			<li>
				Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa &quot;nimi (paino kg)&quot;</li>
		</ul>
		<p>Seuraavassa on luokan k&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara(&quot;Aapiskukko&quot;, 2);
        Tavara puhelin = new Tavara(&quot;Nokia 3210&quot;, 1);

        System.out.println(&quot;Kirjan nimi: &quot; + kirja.getNimi());
        System.out.println(&quot;Kirjan paino: &quot; + kirja.getPaino());

        System.out.println(&quot;Kirja: &quot; + kirja);
        System.out.println(&quot;Puhelin: &quot; + puhelin);
    }
}
</pre>
		<p>Ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
Kirjan nimi: Aapiskukko
Kirjan paino: 2
Kirja: Aapiskukko (2 kg)
Puhelin: Nokia 3210 (1 kg)
</pre>
		<h4 class="req">
			Matkalaukku-luokka</h4>
		<p>Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka m&auml;&auml;rittelee tavaroiden suurimman mahdollisen yhteispainon.</p>
		<p>Lis&auml;&auml; luokkaan seuraavat metodit:</p>
		<ul>
			<li>
				Konstruktori, jolle annetaan maksimipaino</li>
			<li>
				Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lis&auml;&auml; parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mit&auml;&auml;n arvoa.</li>
			<li>
				Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa &quot;x tavaraa (y kg)&quot;</li>
		</ul>
		<p>Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:</p>
		<pre class="sh_java">
ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
</pre>
		<p>Luokan <code>Matkalaukku</code>tulee valvoa, ett&auml; sen sis&auml;lt&auml;mien tavaroiden yhteispaino ei ylit&auml; maksimipainoa. Jos maksimipaino ylittyisi lis&auml;tt&auml;v&auml;n tavaran vuoksi, metodi <code>lisaaTavara</code>ei saa lis&auml;t&auml; uutta tavaraa laukkuun.</p>
		<p>Seuraavassa on luokan k&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara(&quot;Aapiskukko&quot;, 2);
        Tavara puhelin = new Tavara(&quot;Nokia 3210&quot;, 1);
        Tavara tiiliskivi = new Tavara(&quot;tiiliskivi&quot;, 4);

        Matkalaukku matkalaukku = new Matkalaukku(5);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(kirja);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(puhelin);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(tiiliskivi);
        System.out.println(matkalaukku);
    }
}
</pre>
		<p>Ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
0 tavaraa (0 kg)
1 tavaraa (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>
		<h4>
			Kielenhuoltoa</h4>
		<p>Ilmoitukset &quot;0 tavaraa&quot; ja &quot;1 tavaraa&quot; eiv&auml;t ole kovin hyv&auml;&auml; suomea &ndash; paremmat muodot olisivat &quot;ei tavaroita&quot; ja &quot;1 tavara&quot;. Tee t&auml;m&auml; muutos luokkaan <code>Matkalaukku</code>.</p>
		<p>Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
ei tavaroita (0 kg)
1 tavara (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>
		<h4 class="req">
			Kaikki tavarat</h4>
		<p>Lis&auml;&auml; luokkaan <code>Matkalaukku</code>seuraavat metodit:</p>
		<ul>
			<li>
				metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
			<li>
				metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
		</ul>
		<p>Seuraavassa on luokan k&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara(&quot;Aapiskukko&quot;, 2);
        Tavara puhelin = new Tavara(&quot;Nokia 3210&quot;, 1);
        Tavara tiiliskivi = new Tavara(&quot;tiiliskivi&quot;, 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        System.out.println(&quot;Matkalaukussa on seuraavat tavarat:&quot;);
        matkalaukku.tulostaTavarat();
        System.out.println(&quot;Yhteispaino: &quot; + matkalaukku.yhteispaino() + &quot; kg&quot;);
    }
}
</pre>
		<p>Ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
Matkalaukussa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
Tiiliskivi (4 kg)
Yhteispaino: 7 kg
</pre>
		<p>Muokkaa my&ouml;s luokkaasi siten, ett&auml; k&auml;yt&auml;t vain kahta oliomuuttujaa. Toinen sis&auml;lt&auml;&auml; maksimipainon, toinen on lista laukussa olevista tavaroista.</p>
		<h4 class="req">
			Raskain tavara</h4>
		<p>Lis&auml;&auml; viel&auml; luokkaan <code>Matkalaukku</code>metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yht&auml; raskaita tavaroita on useita, metodi voi palauttaa mink&auml; tahansa niist&auml;. Metodin tulee palauttaa olioviite. Jos laukku on tyhj&auml;, palauta arvo <em>null</em>.</p>
		<p>Seuraavassa on luokan k&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara(&quot;Aapiskukko&quot;, 2);
        Tavara puhelin = new Tavara(&quot;Nokia 3210&quot;, 1);
        Tavara tiiliskivi = new Tavara(&quot;Tiiliskivi&quot;, 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        Tavara raskain = matkalaukku.raskainTavara();
        System.out.println(&quot;Raskain tavara: &quot; + raskain);
    }
}
</pre>
		<p>Ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
Raskain tavara: Tiiliskivi (4 kg)
</pre>
		<h4 class="req">
			Lastiruuma-luokka</h4>
		<p>Tee luokka <code>Lastiruuma</code>, johon liittyv&auml;t seuraavat metodit:</p>
		<ul>
			<li>
				konstruktori, jolle annetaan maksimipaino</li>
			<li>
				metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lis&auml;&auml; parametrina annetun matkalaukun lastiruumaan</li>
			<li>
				metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa &quot;x matkalaukkua (y kg)&quot;</li>
		</ul>
		<p>Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.</p>
		<p>Luokan <code>Lastiruuma</code>tulee valvoa, ett&auml; sen sis&auml;lt&auml;mien matkalaukkujen yhteispaino ei ylit&auml; maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code>ei saa lis&auml;t&auml; uutta matkalaukkua.</p>
		<p>Seuraavassa on luokan k&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara(&quot;Aapiskukko&quot;, 2);
        Tavara puhelin = new Tavara(&quot;Nokia 3210&quot;, 1);
        Tavara tiiliskivi = new Tavara(&quot;tiiliskivi&quot;, 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println(lastiruuma);
    }
}
</pre>
		<p>Ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
2 matkalaukkua (7 kg)
</pre>
		<h4 class="req">
			Lastiruuman sis&auml;lt&ouml;</h4>
		<p>Lis&auml;&auml; luokkaan <code>Lastiruuma</code>metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.</p>
		<p>Seuraavassa on luokan k&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara(&quot;Aapiskukko&quot;, 2);
        Tavara puhelin = new Tavara(&quot;Nokia 3210&quot;, 1);
        Tavara tiiliskivi = new Tavara(&quot;tiiliskivi&quot;, 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println(&quot;Ruuman matkalaukuissa on seuraavat tavarat:&quot;);
        lastiruuma.tulostaTavarat();
    }
}
</pre>
		<p>Ohjelman tulostuksen tulisi olla seuraava:</p>
		<pre>
Ruuman matkalaukuissa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
tiiliskivi (4 kg)
</pre>
		<h4>
			Paljon tiiliskivi&auml;</h4>
		<p>Testataan viel&auml;, ett&auml; lastiruuman toiminta on oikea eik&auml; maksimipaino p&auml;&auml;se ylittym&auml;&auml;n. Tee Main-luokkaan metodi <code>public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma)</code>, joka lis&auml;&auml; parametrina annettuun lastiruumaan 100 matkalaukkua, joissa jokaisessa on yksi tiiliskivi. Tiiliskivien painot ovat 1, 2, 3, ..., 100 kg.</p>
		<p>Ohjelman runko on seuraava:</p>
		<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lisaaMatkalaukutTiiliskivilla(lastiruuma);
        System.out.println(lastiruuma);
    }

    public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma) {
        // 100 matkalaukun lis&auml;&auml;minen, jokaiseen tulee tiiliskivi
    }
}
</pre>
		<p>Ohjelman tulostus on seuraava:</p>
		<pre>
44 matkalaukkua (990 kg)
</pre>
	</div>
	<h2 id="hashmap">
		Hajautustaulu (HashMap)</h2>
	<p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">Hajautustaulu</a> on yksi Javan yleishy&ouml;dyllisist&auml; tietorakenteista. Hajautustaulun ideana on laskea olioon liittyv&auml;lle <em>avaimelle</em>, eli yksil&ouml;iv&auml;lle arvolle (esimerkiksi henkil&ouml;tunnus, opiskelijanumero, puhelinnumero), indeksi hajautustaulun sis&auml;lt&auml;m&auml;st&auml; taulukosta. Indeksin avulla Avaimen muuttamista indeksiksi kutsutaan <em>hajautukseksi</em>, joka tarkoittaa indeksin laskemista. Hajautus tapahtuu aina tietyn hajautusfunktion avulla, joka takaa ett&auml; tietyll&auml; avaimella saadaan aina sama indeksi.</p>
	<p>Avaimen perusteella lis&auml;&auml;minen ja hakeminen mahdollistaa eritt&auml;in nopean hakemisen. Sen sijaan ett&auml; tutkisimme taulukon alkiot j&auml;rjestyksess&auml; (pahimmassa tapauksessa joudumme k&auml;ym&auml;&auml;n kaikki alkiot l&auml;pi), tai etsisimme arvoa bin&auml;&auml;rihaulla (pahimmassa tapauksessa k&auml;ymme taulukon kokoon liittyv&auml;n logaritmisen m&auml;&auml;r&auml;n alkoita l&auml;pi), voimme periaatteessa katsoa tasan yht&auml; taulukon indeksi&auml; ja tarkistaa onko indeksiin tallennettu arvoa vai ei.</p>
	<p>Hajautustaulu k&auml;ytt&auml;&auml; avaimen arvon laskemiseen <code>Object</code>-luokassa m&auml;&auml;ritelty&auml; <code>hashCode()</code>-metodia, jonka jokainen toteutettu luokka <em>perii</em>. Emme kuitenkaan tutustu hajautustaulun toteutukseen tarkemmin t&auml;ll&auml; kurssilla. Perint&auml;&auml;n palaamme noin viikolla 4.</p>
	<p>Javan luokka <code>HashMap</code>kapseloi eli piilottaa hajautustaulun toteutuksen, ja tarjoaa valmiit metodit sen k&auml;ytt&ouml;&ouml;n.</p>
	<p>Hajautustaulua luodessa tarvitaan kaksi tyyppiparametria, avainmuuttujan tyyppi ja tallennettavan olion tyyppi. Seuraava esimerkki k&auml;ytt&auml;&auml; avaimena <code>String</code>-tyyppist&auml; oliota, ja tallennettavana oliona <code>String</code>-tyyppist&auml; oliota.</p>
	<p>Hajautustaulun toiminnasta ja k&auml;yt&ouml;st&auml; on lyhyt yhteenveto MOOC-kurssin <a href="http://mooc.cs.helsinki.fi/content/cheatsheet">Cheatsheetiss&auml;</a>.</p>
	<pre class="sh_java">
HashMap&lt;String, String&gt; numerot = new HashMap&lt;String, String&gt;();
numerot.put(&quot;Yksi&quot;, &quot;Uno&quot;);
numerot.put(&quot;Kaksi&quot;, &quot;Dos&quot;);

String kaannos = numerot.get(&quot;Yksi&quot;);
System.out.println(kaannos);

System.out.println(numerot.get(&quot;Kaksi&quot;));
System.out.println(numerot.get(&quot;Kolme&quot;));
System.out.println(numerot.get(&quot;Uno&quot;));
</pre>
	<pre>
Uno
Dos
null
null
</pre>
	<p>Esimerkiss&auml; luodaan hajatustaulu, jonka avaimena ja tallennettavana oliona merkkijono. Hajautustauluun lis&auml;t&auml;&auml;n tietoa <code>put()</code>-metodilla, joka saa parametreikseen viitteet avaimeen ja tallennettavaan olioon. Metodi <code>get()</code>-palauttaa parametrina annettuun avaimeen liittyv&auml;n viitteen tai arvon <code>null</code>jos avaimella ei l&ouml;ydy viitett&auml;.</p>
	<p>Hajautustaulussa tietty avain osoittaa aina tiettyyn paikkaan. Sama avain ei voi osoittaa kahteen eri olioon. Jos jo olemassaolevalla avaimella tallennetaan uusi olio, katoaa vanhan olion viite hajautustaulusta.</p>
	<pre class="sh_java">
HashMap&lt;String, String&gt; numerot = new HashMap&lt;String, String&gt;();
numerot.put(&quot;Yksi&quot;, &quot;Uno&quot;);
numerot.put(&quot;Kaksi&quot;, &quot;Dos&quot;);
numerot.put(&quot;Yksi&quot;, &quot;Ein&quot;);

String kaannos = numerot.get(&quot;Yksi&quot;);
System.out.println(kaannos);

System.out.println(numerot.get(&quot;Kaksi&quot;));
System.out.println(numerot.get(&quot;Kolme&quot;));
System.out.println(numerot.get(&quot;Uno&quot;));
</pre>
	<p>Koska avain &quot;<code>Yksi</code>&quot; asetetaan uudestaan, on esimerkin tulostus nyt seuraavanlainen.</p>
	<pre>
Ein
Dos
null
null
</pre>
	<div class="tehtavat">
		<h3>
			Lempinimet</h3>
		<p>Luo <code>main</code>-metodissa uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna t&auml;h&auml;n HashMappiin seuraavien henkil&ouml;iden nimet ja lempinimet niin, ett&auml; nimi on avain ja lempinimi on arvo. K&auml;yt&auml; pelkki&auml; pieni&auml; kirjaimia.</p>
		<ul>
			<li>
				matin lempinimi on mage</li>
			<li>
				mikaelin lempinimi on mixu</li>
			<li>
				arton lempinimi on arppa</li>
		</ul>
		<p>T&auml;m&auml;n j&auml;lkeen hae HashMapist&auml; mikaelin lempinimi ja tulosta se.</p>
	</div>
	<h3 id="kirjastotietokanta">
		Kirjojen haku hajautustaulun avulla</h3>
	<p>Tutkitaan hajautustaulun toimintaa seuraavaksi kirjastoesimerkin avulla. Kirjastosta voi hakea kirjoja kirjan nimen perusteella, nimi toimii siis kirjan avaimena. Jos annetulle nimelle l&ouml;ytyy kirja, saadaan siihen liittyv&auml; viite ja samalla kirjan tiedot. Luodaan ensin esimerkkiluokka <code>Kirja</code>, jolla on oliomuuttujina nimi ja kirjaan liittyv&auml; sis&auml;lt&ouml;.</p>
	<pre class="sh_java">
public class Kirja {
    private String nimi;
    private String sisalto;
    private int julkaisuvuosi;

    public Kirja() {
    }

    public Kirja(String nimi, int julkaisuvuosi, String sisalto) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
        this.sisalto = sisalto;
    }

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    public void setJulkaisuvuosi(int julkaisuvuosi) {
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getSisalto() {
        return this.sisalto;
    }

    public void setSisalto(String sisalto) {
        this.sisalto = sisalto;
    }

    public String toString() {
        String palautus = &quot;Nimi: &quot; + this.nimi + &quot; (&quot; + this.julkaisuvuosi + &quot;)\n&quot;
                         + &quot;Sis&auml;lt&ouml;: &quot; + this.sisalto;
        return palautus;
    }
}
</pre>
	<p>Luodaan seuraavaksi hajautustaulu, joka k&auml;ytt&auml;&auml; avaimena kirjan nime&auml; eli String-tyyppist&auml; oliota, ja tallentaa viitteit&auml; <code>Kirja</code>-olioihin.</p>
	<pre class="sh_java">
HashMap&lt;String, Kirja&gt; kirjahakemisto = new HashMap&lt;String, Kirja&gt;();
</pre>
	<p>Yll&auml; oleva hajautustaulu k&auml;ytt&auml;&auml; avaimena <code>String</code>-oliota. Laajennetaan esimerkki&auml; siten, ett&auml; kirjahakemistoon lis&auml;t&auml;&auml;n kaksi kirjaa, <code>"Järki ja tunteet"</code>ja <code>"Ylpeys ja ennakkoluulo"</code>.</p>
	<pre class="sh_java">
Kirja jarkiJaTunteet = new Kirja(&quot;J&auml;rki ja tunteet&quot;, 1811, &quot;...&quot;);
Kirja ylpeysJaEnnakkoluulo = new Kirja(&quot;Ylpeys ja ennakkoluulo&quot;, 1813, &quot;....&quot;);

HashMap&lt;String, Kirja&gt; kirjahakemisto = new HashMap&lt;String, Kirja&gt;();
kirjahakemisto.put(jarkiJaTunteet.getNimi(), jarkiJaTunteet);
kirjahakemisto.put(ylpeysJaEnnakkoluulo.getNimi(), ylpeysJaEnnakkoluulo);
</pre>
	<p>Kirjahakemistosta voi hakea kirjoja kirjan nimell&auml;. Haku kirjalla <code>"Viisasteleva sydän"</code>ei tuota osumaa, jolloin hajautustaulu palauttaa <code>null</code>-viitteen. Kirja &quot;Ylpeys ja ennakkoluulo&quot; kuitenkin l&ouml;ytyy.</p>
	<pre class="sh_java">
Kirja kirja = kirjahakemisto.get(&quot;Viisasteleva syd&auml;n&quot;);
System.out.println(kirja);
System.out.println();
kirja = kirjahakemisto.get(&quot;Ylpeys ja ennakkoluulo&quot;);
System.out.println(kirja);
</pre>
	<pre>
null

Nimi: Ylpeys ja ennakkoluulo (1813)
Sis&auml;lt&ouml;: ...
</pre>
	<p>Hajautustaulu on hy&ouml;dyllinen silloin kun tiedet&auml;&auml;n avain mink&auml; perusteella halutaan hakea. Avaimet ovat aina yksil&ouml;llisi&auml;, joten saman avaimen taakse ei voi tallettaa montaa eri oliota. Tallennettava olio voi toki olla lista tai toinen hajautustaulukko!</p>
	<h3 id="kapseloitu_kirjasto">
		Kirjasto</h3>
	<p>Yll&auml; olevan kirjahakemiston ongelmana on se, ett&auml; kirjoja haettaessa t&auml;ytyy muistaa kirjan nimi merkki merkilt&auml; oikein. Javan valmis <code>String</code>-luokka tarjoaa meille v&auml;lineet t&auml;h&auml;nkin. Metodi <code>toLowerCase()</code>muuttaa merkkijonon kirjaimet pieniksi, ja metodi <code>trim()</code>poistaa merkkijonon alusta ja lopusta tyhj&auml;t merkit (esimerkiksi v&auml;lily&ouml;nnit). Tietokoneen k&auml;ytt&auml;j&auml;t usein kirjoittavat tekstin alkuun tai loppuun vahingossa v&auml;lily&ouml;ntej&auml;.</p>
	<pre class="sh_java">
String teksti = &quot;Ylpeys ja ennakkoluulo &quot;;
teksti = teksti.toLowerCase(); // teksti nyt &quot;ylpeys ja ennakkoluulo &quot;
teksti = teksti.trim() // teksti nyt &quot;ylpeys ja ennakkoluulo&quot;
</pre>
	<p>Luodaan luokka <code>Kirjasto</code>, joka kapseloi kirjat sis&auml;lt&auml;v&auml;n hajautustaulun ja mahdollistaa kirjoitusasusta riippumattoman kirjojen haun. Lis&auml;t&auml;&auml;n <code>Kirjasto</code>-luokalle metodit <code>lisaaKirja(Kirja kirja)</code>ja <code>poistaKirja(String kirjanNimi)</code>. Huomaamme jo nyt ett&auml; merkkijonon siistimist&auml; tarvitsisi useammassa metodissa, joten tehd&auml;&auml;n siit&auml; erillinen metodi <code>private String siistiMerkkijono(String merkkijono)</code>.</p>
	<pre class="sh_java">
public class Kirjasto {
    private HashMap&lt;String, Kirja&gt; hakemisto;

    public Kirjasto() {
        this.hakemisto = new HashMap&lt;String, Kirja&gt;();
    }

    public void lisaaKirja(Kirja kirja) {
        String nimi = siistiMerkkijono(kirja.getNimi());

        if(this.hakemisto.containsKey(nimi)) {
            System.out.println(&quot;Kirja on jo kirjastossa!&quot;);
        } else {
            hakemisto.put(nimi, kirja);
        }
    }

    public void poistaKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);

        if(this.hakemisto.containsKey(kirjanNimi)) {
            this.hakemisto.remove(kirjanNimi);
        } else {
            System.out.println(&quot;Kirjaa ei l&ouml;ydy, ei voida poistaa!&quot;);
        }
    }

    private String siistiMerkkijono(String merkkijono) {
        if (merkkijono == null) {
            return &quot;&quot;;
        }

        merkkijono = merkkijono.toLowerCase();
        return merkkijono.trim();
    }
}
</pre>
	<p>Toteutetaan kirjan hakutoiminnallisuus siten, ett&auml; kirjaa haetaan hajautusrakenteesta sen nimell&auml;.</p>
	<pre class="sh_java">
    public Kirja haeKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);
        return this.hakemisto.get(kirjanNimi);
    }
</pre>
	<p>Yll&auml; oleva metodi palauttaa haetun kirjan jos sellainen l&ouml;ytyy, muulloin <code>null</code>-arvon. Voimme my&ouml;s k&auml;yd&auml; kaikki hakemiston avaimet l&auml;pi yksitellen, etsien esimerkiksi alkuosaa kirjan nimest&auml;. T&auml;ll&auml; tavalla etsiess&auml; menet&auml;mme kuitenkin hajautustaulun nopeusedun, sill&auml; huonoimmassa tapauksessa joudumme k&auml;ym&auml;&auml;n kaikkien kirjojen nimet l&auml;pi. Hakeminen alkuosan perusteella onnistuisi hajautustaulun <code>keySet()</code>-metodin avulla. Metodi <code>keySet()</code>palauttaa avaimet joukossa, jonka voi k&auml;yd&auml; l&auml;pi <code>for-each</code>-toistolauseella.</p>
	<pre class="sh_java">
    public Kirja haeKirjaNimenAlkuosalla(String kirjanAlkuosa) {
        kirjanAlkuosa = siistiMerkkijono(kirjanAlkuosa);

        for (String avain: this.hakemisto.keySet()) {
            if (avain.startsWith(kirjanAlkuosa)) {
                return this.hakemisto.get(avain);
            }
        }

        return null;
    }
</pre>
	<p>J&auml;t&auml;mme yll&auml; olevan metodin kuitenkin pois kirjastostamme. Kirjastosta puuttuu oleellisista toiminnoista viel&auml; kirjojen listaaminen. Luodaan metodi <code>public ArrayList&lt;Kirja&gt; kirjalista()</code>, joka palauttaa listan kirjaston kirjoista. Metodi <code>kirjalista</code>hy&ouml;dynt&auml;&auml; hajautustaulun tarjoamaa <code>values()</code>-metodia. Metodi <code>values()</code>palauttaa kokoelman kirjaston kirjoista, jonka voi antaa parametrina <code>ArrayList</code>-luokan konstruktorille.</p>
	<pre class="sh_java">
public class Kirjasto {
    private HashMap&lt;String, Kirja&gt; hakemisto;

    public Kirjasto() {
        this.hakemisto = new HashMap&lt;String, Kirja&gt;();
    }

    public Kirja haeKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);
        return this.hakemisto.get(kirjanNimi);
    }

    public void lisaaKirja(Kirja kirja) {
        String nimi = siistiMerkkijono(kirja.getNimi());

        if(this.hakemisto.containsKey(nimi)) {
            System.out.println(&quot;Kirja on jo kirjastossa!&quot;);
        } else {
            this.hakemisto.put(nimi, kirja);
        }
    }

    public void poistaKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);

        if(this.hakemisto.containsKey(kirjanNimi)) {
            this.hakemisto.remove(kirjanNimi);
        } else {
            System.out.println(&quot;Kirjaa ei l&ouml;ydy, ei voida poistaa!&quot;);
        }
    }

    public ArrayList&lt;Kirja&gt; kirjalista() {
        return new ArrayList&lt;Kirja&gt;(this.hakemisto.values());
    }

    private String siistiMerkkijono(String merkkijono) {
        if (merkkijono == null) {
            return &quot;&quot;;
        }

        merkkijono = merkkijono.toLowerCase();
        return merkkijono.trim();
    }
}
</pre>
	<p>Yksi ohjelmoinnin periaatteista on ns. <em>DRY</em>-periaate (Don&#39;t Repeat Yourself), jolla pyrit&auml;&auml;n v&auml;ltt&auml;m&auml;&auml;n saman koodin olemista useassa paikassa. Merkkijonon pieneksi muuttaminen ja <em>trimmaus</em>, eli tyhjien merkkien poisto alusta ja lopusta, olisi toistunut useasti kirjastoluokassamme ilman metodia <code>siistiMerkkijono</code>. Toistuvaa koodia ei usein huomaa ennen kuin sit&auml; on jo kirjoittanut, jolloin sit&auml; p&auml;&auml;tyy koodiin l&auml;hes pakosti. T&auml;ss&auml; ei kuitenkaan ole mit&auml;&auml;n pahaa. T&auml;rkeint&auml; on ett&auml; siistit koodiasi sit&auml; mukaa kun huomaat siistimist&auml; vaativia tilanteita.</p>
	<h3>
		Alkeistyyppiset muuttujat hajautustaulussa</h3>
	<p>Huomaa ett&auml; hajautustaulun avain ja tallennettava olio ovat aina viittaustyyppisi&auml;. Jos haluat k&auml;ytt&auml;&auml; alkeistyyppisi&auml; muuttujia avaimena tai tallennettavana arvona, on niille olemassa my&ouml;s viittaustyyppiset vastineet. Alla on esitelty muutama.</p>
	<p>&nbsp;</p>
	<table>
		<tbody>
			<tr>
				<th>
					Alkeistyyppi</th>
				<th>
					Viittaustyyppinen vastine</th>
			</tr>
			<tr>
			</tr>
			<tr>
				<td>
					int</td>
				<td>
					<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td>
			</tr>
			<tr>
				<td>
					double</td>
				<td>
					<a href="docs.oracle.com/javase/6/docs/api/java/lang/Double.html" target="_blank">Double</a></td>
			</tr>
			<tr>
				<td>
					char</td>
				<td>
					<a href="docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_blank">Character</a></td>
			</tr>
		</tbody>
	</table>
	<p>&nbsp;</p>
	<p>Java oikeastaan kapseloi alkeistyyppiset muuttujat automaattisesti viittaustyyppisiksi muuttujiksi tarvittaessa. Vaikka numero <code>1</code>on alkeistyyppinen muuttuja, voit k&auml;ytt&auml;&auml; sit&auml; suoraan <code>Integer</code>-tyyppisen&auml; avaimena seuraavasti.</p>
	<pre class="sh_java">
HashMap&lt;Integer, String&gt; taulu = new HashMap&lt;Integer, String&gt;();
taulu.put(1, &quot;Ole!&quot;);
</pre>
	<p>Alkeistyyppisten muuttujien automaattista muunnosta viittaustyyppisiksi kutsutaan Javassa <em>auto-boxingiksi</em>, eli automaattiseksi &quot;laatikkoon&quot; asettamiseksi. Vastaava onnistuu my&ouml;s toisinp&auml;in. Voimme luoda metodin, joka palauttaa hajautustaulun sis&auml;lt&auml;m&auml;n kokonaisluvun. Seuraavassa esimerkiss&auml; olevassa metodissa <code>lisaaBongaus</code>tapahtuu automaattinen tyyppimuunnos.</p>
	<pre class="sh_java">
public class Rekisteribongaus {
    private HashMap&lt;String, Integer&gt; bongatut;

    public Numerokirjanpito() {
        this.bongatut = new HashMap&lt;String, Integer&gt;();
    }

    public void lisaaBongaus(String nimi, int numero) {
        this.bongatut.put(nimi, numero);
    }

    public int viimeisinBongaus(String nimi) {
        this.bongatut.get(nimi);
    }
}
</pre>
	<p>Vaikka hajautustaulu sis&auml;lt&auml;&auml; Integer-tyyppisi&auml; olioita, osaa Java my&ouml;s muuntaa tietyt viittaustyyppiset muuttujat my&ouml;s niiden alkeistyyppisiksi vastineiksi. Esimerkiksi <code>Integer</code>-oliot muuttuvat tarpeen vaatiessa <code>int</code>-tyyppisiksi muuttujiksi. T&auml;ss&auml; piilee kuitenkin vaara! Jos yrit&auml;mme muuttaa null-viitett&auml; numeroksi, n&auml;emme virheen <em>java.lang.reflect.InvocationTargetException</em>. Kun teemme automaattista muunnosta, tulee varmistaa ett&auml; muunnettava arvo ei ole null. Yll&auml; olevassa ohjelmassa oleva <code>viimeisinBongaus</code>-metodi tulee korjata esimerkiksi seuraavasti.</p>
	<pre class="sh_java">
    public int viimeisinBongaus(String nimi) {
        if(this.bongatut.containsKey(nimi) {
            return this.bongatut.get(nimi);
        }

        return 0;
    }
</pre>
	<div class="tehtavat">
		<h3>
			Velkakirja</h3>
		<p>Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:</p>
		<ul>
			<li>
				konstruktori <code>public Velkakirja()</code>luo uuden velkakirjan</li>
			<li>
				metodi <code>public void asetaLaina(String kenelle, double maara)</code>tallettaa velkakirjaan merkinn&auml;n lainasta tietylle henkil&ouml;lle.</li>
			<li>
				metodi <code>public double paljonkoVelkaa(String kuka)</code>palauttaa velan m&auml;&auml;r&auml;n annetun henkil&ouml;n nimen perusteella</li>
		</ul>
		<p>Luokkaa k&auml;ytet&auml;&auml;n seuraavalla tavalla:</p>
		<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina(&quot;Arto&quot;, 51.5);
  matinVelkakirja.asetaLaina(&quot;Mikael&quot;, 30);

  System.out.println(matinVelkakirja.paljonkoVelkaa(&quot;Arto&quot;));
  System.out.println(matinVelkakirja.paljonkoVelkaa(&quot;Joel&quot;));
</pre>
		<p>Yll&auml; oleva esimerkki tulostaisi:</p>
		<pre>
51.5
0
</pre>
		<p>Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkil&ouml;lle jolla on vanha velka, vanha velka unohtuu.</p>
		<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina(&quot;Arto&quot;, 51.5);
  matinVelkakirja.asetaLaina(&quot;Arto&quot;, 10.5);

  System.out.println(matinVelkakirja.paljonkoVelkaa(&quot;Arto&quot;));
</pre>
		<pre>
10.5
</pre>
		<h3>
			Sanakirja</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;sarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisi&auml; k&auml;&auml;nn&ouml;ksi&auml;. Sanakirjan tekemisess&auml; k&auml;ytet&auml;&auml;n <code>HashMap</code>-tietorakennetta.</p>
		<h4 class="req">
			Luokka Sanakirja</h4>
		<p>Toteuta luokka nimelt&auml; <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:</p>
		<ul>
			<li>
				<code>public String kaanna(String sana)</code>metodi palauttaa parametrinsa k&auml;&auml;nn&ouml;ksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
			<li>
				<code>public void lisaa(String sana, String kaannos)</code>metodi lis&auml;&auml; sanakirjaan uuden k&auml;&auml;nn&ouml;ksen</li>
		</ul>
		<p>Toteuta luokka Sanakirja siten, ett&auml; sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.</p>
		<p>Testaa sanakirjasi toimintaa:</p>
		<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa(&quot;apina&quot;, &quot;monkey&quot;);
    sanakirja.lisaa(&quot;banaani&quot;, &quot;banana&quot;);
    sanakirja.lisaa(&quot;cembalo&quot;, &quot;harpsichord&quot;);

    System.out.println(sanakirja.kaanna(&quot;apina&quot;));
    System.out.println(sanakirja.kaanna(&quot;porkkana&quot;));
</pre>
		<pre>
monkey
null
</pre>
		<h4>
			Kaikkien sanojen listaaminen</h4>
		<p>Lis&auml;&auml; sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code>joka palauttaa sanakirjan sis&auml;ll&ouml;n listana <i>avain = arvo</i> muotoisia merkkijonoja.</p>
		<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa(&quot;apina&quot;, &quot;monkey&quot;);
    sanakirja.lisaa(&quot;banaani&quot;, &quot;banana&quot;);
    sanakirja.lisaa(&quot;cembalo&quot;, &quot;harpsichord&quot;);

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();
    for(String kaannos: kaannokset) {
        System.out.println(kaannos);
    }
</pre>
		<pre>
banaani = banana
apina = monkey
cembalo = harpsichord
</pre>
		<h4>
			Sanojen lukum&auml;&auml;r&auml;</h4>
		<p>Lis&auml;&auml; sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukum&auml;&auml;r&auml;n.</p>
		<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa(&quot;apina&quot;, &quot;monkey&quot;);
    sanakirja.lisaa(&quot;banaani&quot;, &quot;banana&quot;);
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa(&quot;cembalo&quot;, &quot;harpsichord&quot;);
    System.out.println(sanakirja.sanojenLukumaara());
</pre>
		<pre>
2
3
</pre>
		<h4 class="req">
			Tekstik&auml;ytt&ouml;liittym&auml;n alku</h4>
		<p>Harjoitellaan t&auml;ss&auml;kin teht&auml;v&auml;ss&auml; erillisen tekstik&auml;ytt&ouml;liittym&auml;n tekemist&auml;. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit</p>
		<ul>
			<li>
				konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
			<li>
				metodi <code>public void kaynnista()</code>, joka k&auml;ynnist&auml;&auml; tekstik&auml;ytt&ouml;liittym&auml;n.</li>
		</ul>
		<p>&nbsp;</p>
		<p>Tekstik&auml;ytt&ouml;liittym&auml;ss&auml; tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstik&auml;ytt&ouml;liittym&auml;st&auml;. Jos k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; jotain muuta, k&auml;ytt&auml;j&auml;lle sanotaan &quot;Tuntematon komento&quot;.</p>
		<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
</pre>
		<pre>
Komennot:
  lopeta - poistuu k&auml;ytt&ouml;liittym&auml;st&auml;

Komento: apua
Tuntematon komento.

Komento: lopeta
Hei hei!
</pre>
		<h4 class="req">
			Sanojen lis&auml;&auml;minen ja k&auml;&auml;nt&auml;minen</h4>
		<p>Lis&auml;&auml; tekstik&auml;ytt&ouml;liittym&auml;lle komennot <code>lisaa</code>ja <code>kaanna</code>. Komento <code>lisaa</code>lis&auml;&auml; kysyy k&auml;ytt&auml;j&auml;lt&auml; sanaparin ja lis&auml;&auml; sen sanakirjaan. Komento <code>kaanna</code>kysyy k&auml;ytt&auml;j&auml;lt&auml; sanaa ja tulostaa sen k&auml;&auml;nn&ouml;ksen.</p>
		<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
</pre>
		<pre>
Komennot:
  lisaa - lis&auml;&auml; sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen k&auml;&auml;nn&ouml;ksen
  lopeta - poistuu k&auml;ytt&ouml;liittym&auml;st&auml;

Komento: lisaa
Suomeksi: porkkana
K&auml;&auml;nn&ouml;s: carrot

Komento: kaanna
Anna sana: porkkana
K&auml;&auml;nn&ouml;s: carrot

Komento: lopeta
Hei hei!
</pre>
	</div>
	<h2>
		Kohti testauksen automatisointia</h2>
	<p>Ohjelman testaaminen k&auml;sin on toivottoman ty&ouml;l&auml;st&auml;. Sy&ouml;tteen antaminen on kuitenkin mahdollista automatisoida esimerkiksi sy&ouml;tt&auml;m&auml;ll&auml; Scanner-oliolle luettava merkkijono. Alla on annettu esimerkki siit&auml;, miten yll&auml; olevassa teht&auml;v&auml;ss&auml; luotua ohjelmaa voi testata automaattisesti.</p>
	<pre class="sh_java">
    String syote = &quot;kaanna\n&quot; + &quot;apina\n&quot;  +
                   &quot;kaanna\n&quot; + &quot;juusto\n&quot; +
                   &quot;lisaa\n&quot;  + &quot;juusto\n&quot; + &quot;cheese\n&quot; +
                   &quot;kaanna\n&quot; + &quot;juusto\n&quot; +
                   &quot;lopeta\n&quot;;

    Scanner lukija = new Scanner(syote);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
</pre>
	<p>Ohjelma tulostus n&auml;ytt&auml;&auml; vain ohjelman antaman tulostuksen, ei k&auml;ytt&auml;j&auml;n tekemi&auml; komentoja.</p>
	<pre>
Komennot:
  lisaa - lis&auml;&auml; sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen k&auml;&auml;nn&ouml;ksen
  lopeta - poistuu k&auml;ytt&ouml;liittym&auml;st&auml;

Komento: Anna sana: Tuntematon sana!

Komento: Anna sana: Tuntematon sana!

Komento: Suomeksi: K&auml;&auml;nn&ouml;s:
Komento: Anna sana: K&auml;&auml;nn&ouml;s: cheese

Komento: Hei hei!
</pre>
	<p>Merkkijonon antaminen Scanner-luokalle korvaa n&auml;pp&auml;imist&ouml;lt&auml; luettavan sy&ouml;tteen merkkijonolla. Merkkijonomuuttujan <code>syote</code>sis&auml;lt&ouml; siis &quot;simuloi&quot; k&auml;ytt&auml;j&auml;n antamaa sy&ouml;tett&auml;. Rivinvaihto sy&ouml;tteeseen merkit&auml;&auml;n <code>\n</code>:ll&auml;. Jokainen yksitt&auml;inen rivinvaihtomerkkiin loppuva osa <code>syote</code>-merkkijonossa siis vastaa k&auml;ytt&auml;j&auml;n yhteen nextLine()-komentoon antamaa sy&ouml;tett&auml;.</p>
	<p>Testity&ouml;tett&auml; on helppo muuttaa, esim. seuraavassa sy&ouml;tet&auml;&auml;n lis&auml;&auml; uusia sanoja sanakirjaan:</p>
	<pre class="sh_java">
    String syote = &quot;lisaa\n&quot;  + &quot;juusto\n&quot; +     &quot;cheese\n&quot; +
                   &quot;lisaa\n&quot;  + &quot;olut\n&quot;   +     &quot;beer\n&quot; +
                   &quot;lisaa\n&quot;  + &quot;kirja\n&quot;  +     &quot;book\n&quot; +
                   &quot;lisaa\n&quot;  + &quot;tietokone\n&quot; +  &quot;computer\n&quot; +
                   &quot;lisaa\n&quot;  + &quot;auto\n&quot;   +     &quot;car\n&quot; +
                   &quot;lopeta\n&quot;;
</pre>
	<p>Kun haluat testata ohjelmasi toimintaa j&auml;lleen k&auml;sin, vaihda Scanner-olion konstruktorin parametriksi <code>System.in</code>, eli j&auml;rjestelm&auml;n sy&ouml;tevirta.</p>
	<p>Ohjelman toiminnan oikeellisuus pit&auml;&auml; edelleen tarkastaa itse ruudulta. Tulostus voi olla aluksi hieman h&auml;mment&auml;v&auml;&auml;, sill&auml; automatisoitu sy&ouml;te ei n&auml;y ruudulla ollenkaan.</p>
	<p>Lopullinen tavoite on automatisoida my&ouml;s ohjelman tulostuksen oikeellisuden tarkastaminen niin hyvin, ett&auml; ohjelman testaus ja testituloksen analysointi onnistuu &quot;nappia painamalla&quot;. Palaamme aiheeseen my&ouml;hemmin kurssin aikana.</p>
	<h2>
		Java API</h2>
	<p>Kurssilla k&auml;ytt&auml;m&auml;mme Java-ohjelmointikieli koostuu kolmesta osasta. Ensimm&auml;inen osa on ohjelmointikielen semantiikka ja syntaksi: muuttujien m&auml;&auml;rittelytapa, kontrollirakenteiden muoto, ja muuttujien ja luokkien rakenne ja niin edelleen. Toinen osa on JVM, eli <em>Java Virtual Machine</em>, jota k&auml;ytet&auml;&auml;n ohjelmien suorittamiseen. Java-ohjelmat k&auml;&auml;nnet&auml;&auml;n <em>tavukoodiksi</em>, jota voidaan suorittaa miss&auml; tahansa koneessa olevan JVM:n avulla. Emme oikeastaan ole t&ouml;rm&auml;nneet ohjelmien k&auml;&auml;nt&auml;miseen, sill&auml; ohjelmointiymp&auml;rist&ouml;t tekev&auml;t sen ohjelmoijien puolesta. Silloin t&auml;ll&ouml;in ohjelmointiymp&auml;rist&ouml; ei toimi odotetulla tavalla, ja saatamme joutua valitsemaan <em>clean &amp; build</em>, joka poistaa vanhat l&auml;hdekoodit ja k&auml;&auml;nt&auml;&auml; ohjelman uudestaan. Kolmantena osana on API (<em>Application Programming Interface</em>), eli ohjelmointirajapinta tai standardikirjasto.</p>
	<p>API on ohjelmointikielen tarjoama joukko valmiita luokkia, joita ohjelmoija voi k&auml;ytt&auml;&auml; omissa projekteissaan. Esimerkiksi luokat <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, ja <code>String</code>ovat kaikki osa Javan valmista APIa. Javan version 7 API-kuvaus l&ouml;ytyy osoitteesta <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. Osoitteessa olevan sivuston vasemmassa laidassa on Javan valmiille luokille luokkakuvaus. Etsiess&auml;si sivulta luokkaa <code>ArrayList</code>, l&ouml;yd&auml;t sivun <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, joka kuvaa <code>ArrayList</code>-luokan rakenteen, konstruktorit, ja metodit.</p>
	<p>NetBeans osaa n&auml;ytt&auml;&auml; luokkaan liittyv&auml;n APIn tarvittaessa. Kun kirjoitat luokan nimen ja lis&auml;&auml;t siihen liittyv&auml;n import-lauseen, voit klikata luokan nime&auml; oikealla hiirennapilla ja valita <em>Show Javadoc</em>. T&auml;m&auml; avaa luokkaan liittyv&auml;n API-kuvauksen selaimessa.</p>
	<div class="tehtavat">
		<h3>
			StringBuilder</h3>
		<p>Merkkijonojen rakentaminen <code>+</code>-operaattorilla on hieman vaivalloista ja lis&auml;ksi eritt&auml;in tehotonta. T&auml;t&auml; varten Javan standardikirjasto tarjoaa luokan <code>StringBuilder</code>.</p>
		<p>Tutustu ensin <code>StringBuilder</code>-luokan apidokumentaatioon.</p>
		<p>Teht&auml;v&auml;n&auml;si on toteuttaa luokkametodi <code>public static void pyramidi(int koko, StringBuilder rakentaja)</code>, joka toimii seuraavalla tavalla:</p>
		<pre class="sh_java">
StringBuilder rakentaja = new StringBuilder();
pyramidi(3, rakentaja);
System.out.print(rakentaja.toString());
  </pre>
		<pre>
1
1 2
1 2 3
-----
</pre>
		<pre class="sh_java">
StringBuilder rakentaja = new StringBuilder();
pyramidi(5, rakentaja);
System.out.print(rakentaja.toString());
</pre>
		<pre>
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
---------
</pre>
		<p><em>Huom!</em> K&auml;yt&auml; vain metodin <code>pyramidi</code>parametrina saamaa <code>StringBuilder</code>-oliota pyramidin rakentamiseen. &Auml;l&auml; esimerkiksi k&auml;yt&auml; merkkijonojen katenaatiota tai luo omaa erillist&auml; <code>StringBuilder</code>-oliota metodissa <code>pyramidi</code>.</p>
		<h3>
			Lentokentt&auml;</h3>
		<p>Jokaisella viikolla on yksi laajempi teht&auml;v&auml;, jossa p&auml;&auml;set vapaasti suunnittelemaan ohjelman rakenteen -- k&auml;ytt&ouml;liittym&auml;n ulkomuoto ja vaaditut komennot on m&auml;&auml;ritelty ennalta. Ohjelmoinnin jatkokurssin ensimm&auml;inen vapaasti suunniteltava teht&auml;v&auml; on <em>Lentokentt&auml;</em>.</p>
		<p>Lentokentt&auml;-teht&auml;v&auml;ss&auml; toteutetaan lentokent&auml;n hallintasovellus. Lentokent&auml;n hallintasovelluksessa hallinnoidaan lentokoneita ja lentoja. Lentokoneista tiedet&auml;&auml;n aina tunnus ja kapasiteetti. Lennoista tiedet&auml;&auml;n lennon lentokone, l&auml;ht&ouml;paikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) ja kohdepaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>
		<p>Sek&auml; lentokoneita ett&auml; lentoja voi olla useita. Sama lentokone voi my&ouml;s lent&auml;&auml; useaa eri lentoa (useaa eri reitti&auml;). Sovelluksen tulee toimia kahdessa vaiheessa. Ensin lentokent&auml;n ty&ouml;ntekij&auml; sy&ouml;tt&auml;&auml; lentokoneiden ja lentojen tietoja hallintak&auml;ytt&ouml;liittym&auml;ss&auml;.</p>
		<p>Kun k&auml;ytt&auml;j&auml; poistuu hallintak&auml;ytt&ouml;liittym&auml;ss&auml;, avautuu k&auml;ytt&auml;j&auml;lle mahdollisuus lentopalvelun k&auml;ytt&ouml;&ouml;n. Lentopalvelussa on kolme toimintoa; lentokoneiden tulostaminen, lentojen tulostaminen, ja lentokoneen tietojen tulostaminen. T&auml;m&auml;n lis&auml;ksi k&auml;ytt&auml;j&auml; voi poistua ohjelmasta valitsemalla vaihtoehdon <code>x</code>. Jos k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; ep&auml;kelvon komennon, kysyt&auml;&auml;n komentoa uudestaan.</p>
		<pre>
Lentokent&auml;n hallinta
--------------------

Valitse toiminto:
[1] Lis&auml;&auml; lentokone
[2] Lis&auml;&auml; lento
[x] Poistu hallintamoodista
&gt; porkkana
Valitse toiminto:
[1] Lis&auml;&auml; lentokone
[2] Lis&auml;&auml; lento
[x] Poistu hallintamoodista
&gt; 1
Anna lentokoneen tunnus: HA-LOL
Anna lentokoneen kapasiteetti: 42
Valitse toiminto:
[1] Lis&auml;&auml; lentokone
[2] Lis&auml;&auml; lento
[x] Poistu hallintamoodista
&gt; 1
Anna lentokoneen tunnus: G-OWAC
Anna lentokoneen kapasiteetti: 101
Valitse toiminto:
[1] Lis&auml;&auml; lentokone
[2] Lis&auml;&auml; lento
[x] Poistu hallintamoodista
&gt; 2
Anna lentokoneen tunnus: HA-LOL
Anna l&auml;ht&ouml;paikan tunnus: HEL
Anna kohdepaikan tunnus: BAL
Valitse toiminto:
[1] Lis&auml;&auml; lentokone
[2] Lis&auml;&auml; lento
[x] Poistu hallintamoodista
&gt; x

Lentopalvelu
------------

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
&gt; 1
G-OWAC (101 henkil&ouml;&auml;)
HA-LOL (42 henkil&ouml;&auml;)
Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
&gt; 2
HA-LOL (42 henkil&ouml;&auml;) (HEL-BAL)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
&gt; 3
Anna lentokoneen tunnus: G-OWAC
G-OWAC (101 henkil&ouml;&auml;)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
&gt; x
</pre>
		<p><strong>Huom!</strong> Testien kannalta on oleellista ett&auml; <em>k&auml;ytt&ouml;liittym&auml;</em> toimii kuten yll&auml; kuvattu. Jos k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; ep&auml;kelvon komennon, pyydet&auml;&auml;n komentoa uudestaan. T&auml;m&auml; teht&auml;v&auml; on kolmen yksitt&auml;isen teht&auml;v&auml;pisteen arvoinen.</p>
		<p><em><strong>Ohjelman tulee k&auml;ynnisty&auml; kun teht&auml;v&auml;pohjassa oleva main-metodi suoritetaan, teht&auml;v&auml;ss&auml; saa luoda vain yhden Scanner-olion.</strong></em></p>
	</div>
</div>
<!--
<hr />Viikko 1 loppuu<hr />
--><!--

VK2:

- Interface
- Comparable
- Generics (alkeet)
- Map
- pakkaus


Collection<V>
Set
Entry

kaksitasoinen HM

-->
<div class="week" data-week-number="8">
	<h2 id="object">
		Object</h2>
	<p>Kurssilla on jo useampaan otteeseen k&auml;ytetty metodia <code>public String toString()</code>olion merkkijonoesityksen tulostamiseen. Emme ole saaneet selvyytt&auml; <em>miksi</em> Java osaa k&auml;ytt&auml;&auml; kyseist&auml; metodia. Olemattoman metodin kutsuminenhan tuottaa normaalisti virheen. Tutkitaan seuraavaa luokkaa <code>Kirja</code>, jolla ei ole metodia <code>public String toString()</code>, ja ohjelmaa joka yritt&auml;&auml; tulostaa <code>Kirja</code>-luokasta luodun olion <code>System.out.println()</code>-komennolla.</p>
	<pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }
}
</pre>
	<pre class="sh_java">
Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
System.out.println(olioKirja);
</pre>
	<p>Ohjelmamme ei tulosta virheilmoitusta tai kaadu kun annamme <code>Kirja</code>-luokasta tehdyn olion parametrina <code>System.out.println</code>-komennolle. N&auml;emme virheilmoituksen tai kaatumisen sijaan mielenkiintoisen tulosteen. Tuloste sis&auml;lt&auml;&auml; luokan <code>Kirja</code>nimen ja ep&auml;m&auml;&auml;r&auml;isen @-merkki&auml; seuraavan merkkijonon. Huomaa ett&auml; kutsussa <code>System.out.println(olioKirja)</code>Java tekee oikeasti kutsun <code>System.out.println(olioKirja.toString())</code>-- emme kuitenkaan kohtaa virhett&auml;.</p>
	<p>Selitys liittyy Javan luokkien rakenteeseen. Jokainen Javan luokka <em>perii</em> automaattisesti luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code>, joka sis&auml;lt&auml;&auml; joukon jokaiselle Javan luokalle hy&ouml;dyllisi&auml; perusmetodeja. Perint&auml; tarkoittaa ett&auml; oma luokkamme saa k&auml;ytt&ouml;&ouml;n peritt&auml;v&auml;n luokan m&auml;&auml;rittelemi&auml; toiminnallisuuksia ja ominaisuuksia. Luokka <code>Object</code>sis&auml;lt&auml;&auml; muun muassa metodin <code>toString</code>, joka periytyy luomiimme luokiin.</p>
	<p>Object-luokassa m&auml;&auml;ritelty <code>toString</code>-metodin tuottama merkkijono ei yleens&auml; ole toivomamme. T&auml;m&auml;n takia meid&auml;n tulee <em>korvata</em>, eli syrj&auml;ytt&auml;&auml; metodi omalla toteutuksellamme. Lis&auml;t&auml;&auml;n luokkaan <code>Kirja</code>metodi <code>public String toString()</code>, joka korvaa perityss&auml; <code>Object</code>luokassa olevan metodin <code>toString</code>.</p>
	<pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + &quot; (&quot; + this.julkaisuvuosi + &quot;)&quot;;
    }
}
</pre>
	<p>Nyt kun teemme oliosta ilmentym&auml;n ja annamme sen tulostusmetodille, n&auml;emme luokassa <code>Kirja</code>olevan <code>toString</code>-metodin tuottaman merkkijonon.</p>
	<pre class="sh_java">
Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
System.out.println(olioKirja);
</pre>
	<pre>
Oliokirja (2000)
</pre>
	<p>Luokassa <code>Kirja</code>olevan metodin <code>toString</code>yl&auml;puolella on <em>annotaatio</em> <code>@Override</code>. Annotaatioilla annetaan vinkkej&auml; sek&auml; k&auml;&auml;nt&auml;j&auml;lle ett&auml; lukijalle siit&auml;, miten metodeihin tulisi suhtautua. Annotaatio <code>@Override</code>tarkoittaa ett&auml; annotaatiota seuraava korvaa perityss&auml; luokassa m&auml;&auml;ritellyn metodin. Annotaatio <code>@Override</code>auttaa ohjelmoijaa, sill&auml; k&auml;&auml;nt&auml;j&auml; luo virheilmoituksen jos <code>@Override</code>on lis&auml;tty ei-perityn metodin yl&auml;puolelle.</p>
	<p>Luokasta <code>Object</code>perit&auml;&auml;n muitakin hy&ouml;dyllisi&auml; metodeja. Tutustutaan seuraavaksi metodeihin <code>equals</code>ja <code>hashCode</code>.</p>
	<h3>
		Metodi equals</h3>
	<p>Metodia <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code>k&auml;ytet&auml;&auml;n kahden olion yht&auml;suuruusvertailuun. Metodia on jo k&auml;ytetty muun muassa <code>String</code>-olioiden kanssa.</p>
	<pre class="sh_java">
Scanner lukija = new Scanner(System.in);

System.out.print(&quot;Kirjoita salasana: &quot;);
String salasana = lukija.nextLine();

if(salasana.equals(&quot;salasana&quot;)) {
    System.out.println(&quot;Oikein meni!&quot;);
} else {
    System.out.println(&quot;Pieleen meni!&quot;);
}
</pre>
	<pre>
Kirjoita salasana: mahtiporkkana
Pieleen meni!
</pre>
	<p>Luokassa <code>Object</code>m&auml;&auml;ritelty <code>equals</code>-metodi tarkistaa onko parametrina annetulla oliolla sama viite kuin oliolla johon verrataan. Jos viite on sama, palauttaa metodi arvon <code>true</code>, muuten <code>false</code>. T&auml;m&auml; selvenee seuraavalla esimerkill&auml;. Luokassa <code>Kirja</code>ei ole omaa <code>equals</code>-metodin toteutusta, joten se k&auml;ytt&auml;&auml; <code>Object</code>-luokassa olevaa toteutusta.</p>
	<pre class="sh_java">
Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
Kirja toinenOlioKirja = olioKirja;

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println(&quot;Kirjat olivat samat&quot;);
} else {
    System.out.println(&quot;Kirjat eiv&auml;t olleet samat&quot;);
}

toinenOlioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println(&quot;Kirjat olivat samat&quot;);
} else {
    System.out.println(&quot;Kirjat eiv&auml;t olleet samat&quot;);
}
</pre>
	<pre>
Kirjat olivat samat
Kirjat eiv&auml;t olleet samat
</pre>
	<p>Vaikka <code>Kirja</code>-olioiden sis&auml;inen rakenne (eli oliomuuttujien arvot) ovat molemmissa tapauksissa t&auml;sm&auml;lleen samat, vain ensimm&auml;inen vertailu tulostaa merkkijonon &quot;<code>Kirjat olivat samat</code>&quot;. T&auml;m&auml; johtuu siit&auml; ett&auml; vain ensimm&auml;isess&auml; tapauksessa my&ouml;s viitteet ovat samat. Toisessa vertailussa viitteet ovat eri vaikka olioiden sis&auml;iset muuttujat ovat samat.</p>
	<p>Haluamme ett&auml; kirjojen vertailu onnistuu my&ouml;s nimen ja vuoden perusteella. Korvataan <code>Object</code>-luokassa oleva metodi <code>equals</code>m&auml;&auml;rittelem&auml;ll&auml; sille toteutus luokkaan <code>Kirja</code>. Metodin <code>equals</code>teht&auml;v&auml;n&auml; on selvitt&auml;&auml; onko olio sama kuin metodin parametrina saatu olio. Metodi saa parametrina <code>Object</code>-tyyppisen olion. M&auml;&auml;ritell&auml;&auml;n ensin metodi, jonka mielest&auml; kaikki oliot ovat samoja.</p>
	<pre class="sh_java">
    public boolean equals(Object olio) {
        return true;
    }
</pre>
	<p>Metodimme on varsin optimistinen, joten muutetaan sen toimintaa hieman. M&auml;&auml;ritell&auml;&auml;n ett&auml; oliot eiv&auml;t ole samoja jos parametrina saatu olio on <em>null</em> tai jos olioiden tyypit eiv&auml;t ole samat. Olion tyypin saa (<code>Object</code>-luokassa m&auml;&auml;ritellyll&auml;) metodilla <code>getClass()</code>. Muussa tapauksessa oletetaan ett&auml; oliot ovat samat.</p>
	<pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        return true;
    }
</pre>
	<p>Metodi <code>equals</code>huomaa eron erityyppisten olioiden v&auml;lill&auml;, mutta ei viel&auml; osaa erottaa samanlaisia olioita toisistaan. Jotta voisimme verrata nykyist&auml; oliota ja parametrina saatua <code>Object</code>-oliota, tulee Object-olion tyyppi&auml; muuttaa. Olion tyyppi&auml; voi muuttaa tyyppimuunnoksella jos ja vain jos olion tyyppi on oikeasti sellainen, mihin sit&auml; yritet&auml;&auml;n muuttaa. Tyyppimuunnos tapahtuu antamalla asetuslauseen oikealla puolella haluttu luokka suluissa, esimerkiksi:</p>
	<pre class="sh_java">
    HaluttuTyyppi muuttuja = (HaluttuTyyppi) vanhaMuuttuja;
</pre>
	<p>Voimme tehd&auml; tyyppimuunnoksen koska tied&auml;mme olioiden olevan samantyyppisi&auml; -- jos ne ovat erityyppisi&auml; yll&auml; oleva metodi <code>getClass</code>palauttaa arvon false. Muunnetaan metodissa <code>equals</code>saatu <code>Object</code>-tyyppinen parametri <code>Kirja</code>-tyyppiseksi, ja todetaan kirjojen olevan eri jos niiden julkaisuvuodet ovat eri. Muuten kirjat ovat viel&auml; samat.</p>
	<pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if(this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        return true;
    }
</pre>
	<p>Nyt vertailumetodimme osaa erottaa eri vuosina julkaistut kirjat. Lis&auml;t&auml;&auml;n viel&auml; tarkistus ett&auml; kirjojemme nimet ovat samat ja ett&auml; oman kirjamme nimi ei ole <em>null</em>.</p>
	<pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }
</pre>
	<p>Mahtavaa, viimeinkin toimiva vertailumetodi! Alla viel&auml; t&auml;m&auml;nhetkinen <code>Kirja</code>-luokkamme.</p>
	<pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + &quot; (&quot; + this.julkaisuvuosi + &quot;)&quot;;
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }
}
</pre>
	<p>Nyt kirjojen vertailu palauttaa <code>true</code>jos kirjojen sis&auml;ll&ouml;t ovat samat.</p>
	<pre class="sh_java">
Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
Kirja toinenOlioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println(&quot;Kirjat olivat samat&quot;);
} else {
    System.out.println(&quot;Kirjat eiv&auml;t olleet samat&quot;);
}
</pre>
	<pre>
Kirjat olivat samat
</pre>
	<h4>
		Equals ja ArrayList</h4>
	<p>Useat Javan valmiit tietorakenteet k&auml;ytt&auml;v&auml;t <code>equals</code>-metodia osana sis&auml;ist&auml; hakumekanismiaan. Esimerkiksi luokan <code>ArrayList</code><code>contains</code>-metodi vertailee olioiden yht&auml;suuruutta <code>equals</code>-metodin avulla. Jatketaan aiemmin m&auml;&auml;rittelem&auml;mme <code>Kirja</code>-luokan k&auml;ytt&ouml;&auml; seuraavassa esimerkiss&auml;. Jos emme toteuta omissa olioissamme <code>equals</code>-metodia, emme voi k&auml;ytt&auml;&auml; esimerkiksi <code>contains</code>-metodia. Kokeile allaolevaa koodia kahdella erilaisella <code>Kirja</code>-luokalla. Toisessa on <code>equals</code>-metodi, ja toisessa sit&auml; ei ole.</p>
	<pre class="sh_java">
ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;Kirja&gt;();
Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
kirjat.add(olioKirja);

if (kirjat.contains(olioKirja)) {
    System.out.println(&quot;Oliokirja l&ouml;ytyi.&quot;);
}

olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);

if (!kirjat.contains(olioKirja)) {
    System.out.println(&quot;Oliokirjaa ei l&ouml;ytynyt.&quot;);
}
</pre>
	<h3>
		Metodi hashCode</h3>
	<p>Metodi <code>hashCode</code>luo oliosta numeerisen arvon eli hajautusarvon. Numeerista arvoa tarvitaan esimerkiksi hajautustauluissa olion paikan p&auml;&auml;ttelemist&auml; varten. Oikeastaan kaikilla luokilla joita olemme t&auml;h&auml;n menness&auml; k&auml;ytt&auml;neet hajautustaulun avaimina on ollut oma <code>hashCode</code>-metodin toteutus. Luodaan esimerkki jossa n&auml;in ei ole: jatketaan kirjojen parissa ja mietit&auml;&auml;n kirjojen sijoittamista hyllyihin. Luodaan esimerkki&auml; varten luokka <code>Hylly</code>, joka kuvaa kirjojen sijoituspaikkaa.</p>
	<pre class="sh_java">
public class Hylly {
    private String nimi;

    public Hylly(String nimi) {
        this.nimi = nimi;
    }

    @Override
    public String toString() {
        return this.nimi;
    }
}
</pre>
	<p>Esimerkiss&auml; luodaan hahmotelmaa j&auml;rjestelm&auml;lle joka kertoo mihin hyllyyn mik&auml;kin kirja kuuluu. Kirja-olioita k&auml;ytet&auml;&auml;n hajautustaulun avaimena ja Hylly-olioita talletettavana arvona. Tallennamme hajautustauluun siis kirjojen s&auml;ilytyshyllyj&auml;. Alla olevassa esimerkiss&auml; luodaan tuttu &quot;<code>Oliokirja</code>&quot; ja asetetaan se hyllyyn &quot;<code>Ohjelmointikirjat</code>&quot;. T&auml;m&auml;n j&auml;lkeen hyllyst&auml; haetaan ensin samalla oliolla, jolla on sama viite. T&auml;m&auml;n j&auml;lkeen luodaan uusi t&auml;sm&auml;lleen samanlainen &quot;<code>Oliokirja</code>&quot;oliokirja, ja yritet&auml;&auml;n etsi&auml; sille sopivaa sijoituspaikkaa.</p>
	<pre class="sh_java">
        HashMap&lt;Kirja, Hylly&gt; kirjojenHyllyt = new HashMap&lt;Kirja, Hylly&gt;();
        Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
        Hylly hylly = new Hylly(&quot;Ohjelmointikirjat&quot;);

        kirjojenHyllyt.put(olioKirja, hylly);
        System.out.println(kirjojenHyllyt.get(olioKirja));

        Kirja toinenOlioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
        System.out.println(kirjojenHyllyt.get(toinenOlioKirja));
</pre>
	<pre>
Ohjelmointikirjat
null
</pre>
	<p>L&ouml;yd&auml;mme halutun hyllyn hakiessamme viitteell&auml; joka annettiin hajautustaulun <code>put</code>-metodille avaimeksi. T&auml;sm&auml;lleen samanlaisella kirjalla mutta eri viitteell&auml; haettaessa hylly&auml; ei l&ouml;ydy ja saamme <em>null</em>-viitteen. Syyn&auml; on taas <code>Object</code>-luokassa oleva <code>hashCode</code>-metodin oletustoteutus. Oletustoteutus luo indeksin viitteen perusteella.</p>
	<p>Haluamme kirjoille sijoitushyllyn kirjan nimen perusteella, joten korvataan <code>Object</code>-luokassa oleva <code>hashCode</code>-metodin toteutus omalla <code>hashCode</code>-metodilla. Olemme aiemmin k&auml;ytt&auml;neet <code>String</code>-olioita menestyksekk&auml;&auml;sti hajautustaulun avaimena, joten voimme p&auml;&auml;tell&auml; ett&auml; <code>String</code>-luokassa on oma <code>hashCode</code>-toteutus. <em>Delegoidaan</em>, eli siirret&auml;&auml;n laskemisvastuu <code>String</code>-oliolle.</p>
	<pre class="sh_java">
    public int hashCode() {
        return this.nimi.hashCode();
    }
</pre>
	<p>Yll&auml; oleva ratkaisu on melko hyv&auml;, mutta jos <code>nimi</code>on <em>null</em>, n&auml;emme <code>NullPointerException</code>-virheen. Korjataan t&auml;m&auml; viel&auml; m&auml;&auml;rittelem&auml;ll&auml; ehto: jos <code>nimi</code>-muuttujan arvo on <em>null</em>, palautetaan arvo 7. Arvo 7 on t&auml;t&auml; luokkaa varten satunnaisesti valittu alkuluku. Jos toteutat toisen luokan, voit hyvin valita esimerkiksi arvon 13.</p>
	<pre class="sh_java">
    public int hashCode() {
        if (this.nimi == null) {
            return 7;
        }

        return this.nimi.hashCode();
    }
</pre>
	<p>Saatat t&auml;ss&auml; kohtaa mietti&auml; &quot;eik&ouml; t&auml;m&auml; johda tilanteeseen jossa useampi olio p&auml;&auml;tyy samaan indeksiin hajautustaulussa?&quot;. Vastaus on kyll&auml; ja ei. Vaikka metodi <code>hashCode</code>antaisi kahdelle eri oliolle saman arvon, on hajautustaulut toteutettu sis&auml;isesti siten ett&auml; useampi olio voi olla samassa indeksiss&auml;. Jotta samassa indeksiss&auml; olevat oliot voi erottaa toisistaan, tulee olioilla olla metodi <code>equals</code>toteutettuna. Hajautustaulujen syvemm&auml;st&auml; sielunel&auml;m&auml;st&auml; tulee lis&auml;tietoa muun muassa kurssilla <em>tietorakenteet ja algoritmit</em>.</p>
	<p>Luokka <code>Kirja</code>nyt kokonaisuudessaan.</p>
	<pre class="sh_java">
public class Kirja {

    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + &quot; (&quot; + this.julkaisuvuosi + &quot;)&quot;;
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        if (this.nimi == null) {
            return 7;
        }

        return this.nimi.hashCode();
    }
}
</pre>
	<p>Nyt my&ouml;s aiemmin kohtaamamme hyllytysongelma ratkeaa. Uudelle &quot;<code>Oliokirja</code>&quot;-kirjalle l&ouml;ytyy oikea hylly.</p>
	<pre class="sh_java">
        HashMap&lt;Kirja, Hylly&gt; kirjojenHyllyt = new HashMap&lt;Kirja, Hylly&gt;();
        Kirja olioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
        Hylly hylly = new Hylly(&quot;Ohjelmointikirjat&quot;);

        kirjojenHyllyt.put(olioKirja, hylly);
        System.out.println(kirjojenHyllyt.get(olioKirja));

        Kirja toinenOlioKirja = new Kirja(&quot;Oliokirja&quot;, 2000);
        System.out.println(kirjojenHyllyt.get(toinenOlioKirja));
</pre>
	<pre>
Ohjelmointikirjat
Ohjelmointikirjat
</pre>
	<p><em>NetBeans tarjoaa metodien <code>equals</code>ja <code>hashCode</code>automaattisen luonnin. Voit valita valikosta Source -&gt; Insert Code, ja valita aukeavasta listasta <em>equals() and hashCode()</em>. T&auml;m&auml;n j&auml;lkeen NetBeans kysyy oliomuuttujat joita metodeissa k&auml;ytet&auml;&auml;n.</em></p>
	<div class="tehtavat">
		<h3>
			Ravintolan asiakas</h3>
		<p>Kurt Koodari toteutti er&auml;&auml;lle lounasravintolalle j&auml;rjestelm&auml;n asiakkaiden ja myyntien hallintaan. J&auml;rjestelm&auml; hallinnoi asiakkaiden tilej&auml; sek&auml; ravintolan vip-listaa. Vip-asiakkaat sy&ouml;v&auml;t ravintolassa edullisemmin kuin normaalit asiakkaat.</p>
		<p>Kurt suunnitteli ohjelman rakenteen fiksusti siten, ett&auml; ohjelmassa on eriytetty k&auml;ytt&ouml;liittym&auml;logiikka ja sovelluslogiikka. Sovelluslogiikassa Asiakas-olioita tallennetaan muun muassa <code>ArrayList</code>- ja <code>HashMap</code>-tietorakenteisiin. Koodausinnossaan Kurt kuitenkin unohti <code>Object</code>-luokan metodien ylikirjoittamisen, joten ohjelma ei toimi toivotusti. T&auml;ll&auml; hetkell&auml; esimerkiksi sis&auml;&auml;nkirjautuminen ei onnistu.</p>
		<pre>
Tervetuloa ravintolapalveluun.
Kirjoita nimesi: Arto
Et ole asiakkaamme.

Kirjoita nimesi: Bonus
Et ole asiakkaamme.

Kirjoita nimesi:
</pre>
		<p>H&auml;t&auml; ei ole t&auml;m&auml;n n&auml;k&ouml;inen! Teht&auml;v&auml;n&auml;si on pelastaa Kurtin projekti: toteuta teht&auml;v&auml;pohjassa tulevaan luokkaan <code>Asiakas</code>metodit <code>equals</code>ja <code>hashCode</code>. Hy&ouml;dynn&auml; asiakkaan nime&auml; sek&auml; <code>equals</code>-metodissa ett&auml; <code>hashCode</code>-metodissa. Muutoksen j&auml;lkeen ohjelman pit&auml;isi toimia seuraavasti.</p>
		<pre>
Tervetuloa ravintolapalveluun.
Kirjoita nimesi: Arto
Et ole asiakkaamme.

Kirjoita nimesi: Lennon
Hei Lennon, tilill&auml;si on 8 euroa.
Komennot:
[1] osta lounas
[2] rekister&ouml;idy vip-k&auml;ytt&auml;j&auml;ksi
[x] lopeta
Valitse komento: 1
Hei Lennon, tilill&auml;si on 4 euroa.
Komennot:
[1] osta lounas
[2] rekister&ouml;idy vip-k&auml;ytt&auml;j&auml;ksi
[x] lopeta
Valitse komento: 2
Hei Lennon, tilill&auml;si on 4 euroa.
Komennot:
[1] osta lounas
[x] lopeta
Valitse komento: 1
Hei Lennon, tilill&auml;si on 1 euroa.
Komennot:
[1] osta lounas
[x] lopeta
Valitse komento: x
Hei hei.

Tervetuloa ravintolapalveluun.
Kirjoita nimesi: Bonus
Hei Bonus, tilill&auml;si on 400000 euroa.
Komennot:
[1] osta lounas
[x] lopeta
Valitse komento: x
Hei hei.

Tervetuloa ravintolapalveluun.
Kirjoita nimesi:
</pre>
		<p><em>Huom!</em> Muuta vain Asiakas-luokan toteutusta. Neuvoja <code>equals</code>ja <code>hashCode</code>-metodien toteutukseen saat edellisest&auml; kappaleesta.</p>
	</div>
	<h2 id="rajapinta">
		Rajapinta</h2>
	<p>Rajapinta (engl. <em>interface</em>) on v&auml;line luokilta vaaditun k&auml;ytt&auml;ytymisen m&auml;&auml;rittelyyn. Rajapinnat ovat luokkia kuten normaalit Javan olevat luokat, mutta luokan alussa olevan m&auml;&auml;rittelyn &quot;<code>public class ...</code>&quot; sijaan k&auml;ytet&auml;&auml;n m&auml;&auml;rittely&auml; &quot;<code>public interface ...</code>&quot;. Rajapintaluokat m&auml;&auml;rittelev&auml;t k&auml;ytt&auml;ytymisen metodien nimin&auml; ja palautusarvoina, mutta ne <em>eiv&auml;t sis&auml;ll&auml; metodien toteutusta</em>. N&auml;kyvyysm&auml;&auml;rett&auml; ei merkit&auml; erikseen, sill&auml; se on aina <code>public</code>. Tutkitaan luettavuutta kuvaavaa rajapintaa <em>Luettava</em>.</p>
	<pre class="sh_java">
public interface Luettava {
    String lue();
}
</pre>
	<p>Rajapinta <code>Luettava</code>m&auml;&auml;rittelee metodin <code>lue()</code>, joka palauttaa String-tyyppisen olion. Rajapinnan toteuttavat luokat -- tai oikeastaan luokat toteuttavat ohjelmoijat -- p&auml;&auml;tt&auml;v&auml;t <em>miten</em> rajapinnassa m&auml;&auml;ritellyt metodit lopulta toteutetaan. Luokka toteuttaa rajapinnan lis&auml;&auml;m&auml;ll&auml; luokan nimen j&auml;lkeen avainsanalla <em>implements</em>, jota seuraa rajapinnan nimi. Luodaan luokka <code>Tekstiviesti</code>, joka toteuttaa rajapinnan <code>Luettava</code>.</p>
	<pre class="sh_java">
public class Tekstiviesti implements Luettava {
    private String lahettaja;
    private String sisalto;

    public Tekstiviesti(String lahettaja, String sisalto) {
        this.lahettaja = lahettaja;
        this.sisalto = sisalto;
    }

    public String getLahettaja() {
        return this.lahettaja;
    }

    public String lue() {
        return this.sisalto;
    }
}
</pre>
	<p>Koska luokka <code>Tekstiviesti</code>toteuttaa rajapinnan <code>Luettava</code>(<code>public class Tekstiviesti implements Luettava</code>), on luokassa <code>Tekstiviesti</code><em>pakko</em> olla metodin <code>public String lue()</code>toteutus. Rajapinnassa m&auml;&auml;riteltyjen metodien toteutuksilla tulee aina olla n&auml;kyvyysm&auml;&auml;re public.</p>
	<p><em>Rajapinta on sopimus k&auml;ytt&auml;ytymisest&auml;. Jotta k&auml;ytt&auml;ytyminen toteutuu, tulee luokan toteuttaa rajapinnan m&auml;&auml;rittelem&auml;t metodit. Rajapinnan toteuttavan luokan ohjelmoijan vastuulla on m&auml;&auml;ritell&auml; millaista k&auml;ytt&auml;ytyminen on. Rajapinnan toteuttaminen tarkoittaa sopimuksen tekemist&auml; siit&auml;, ett&auml; luokka tarjoaa kaikki rajapinnan m&auml;&auml;rittelem&auml;t toiminnot eli rajapinnan m&auml;&auml;rittelem&auml;n k&auml;ytt&auml;ytymisen. Luokkaa, joka toteuttaa rajapinnan, mutta ei toteuta rajapinnan metodeja, ei voi olla olemassa.</em></p>
	<p>Toteutetaan luokan <code>Tekstiviesti</code>lis&auml;ksi toinen <code>Luettava</code>rajapinnan toteuttava luokka. Luokka <code>Sahkokirja</code>on s&auml;hk&ouml;inen toteutus kirjasta, joka sis&auml;lt&auml;&auml; kirjan nimen ja sivut. S&auml;hk&ouml;kirjaa luetaan sivu kerrallaan, metodin <code>public String lue()</code>kutsuminen palauttaa aina seuraavan sivun merkkijonona.</p>
	<pre class="sh_java">
public class Sahkokirja implements Luettava {
    private String nimi;
    private ArrayList&lt;String&gt; sivut;
    private int sivunumero;

    public Sahkokirja(String nimi, ArrayList&lt;String&gt; sivut) {
        this.nimi = nimi;
        this.sivut = sivut;
        this.sivunumero = 0;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int sivuja() {
        return this.sivut.size();
    }

    public String lue() {
        String sivu = this.sivut.get(this.sivunumero);
        seuraavaSivu();
        return sivu;
    }

    private void seuraavaSivu() {
        this.sivunumero = this.sivunumero + 1;
        if(this.sivunumero % this.sivut.size() == 0) {
            this.sivunumero = 0;
        }
    }
}
</pre>
	<p>Rajapinnan toteuttavasta luokasta voi tehd&auml; olioita aivan kuten normaaleistakin luokista, ja niit&auml; voidaan k&auml;ytt&auml;&auml; my&ouml;s esimerkiksi ArrayList-listojen tyyppin&auml;.</p>
	<pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti(&quot;ope&quot;, &quot;Huikeaa menoa!&quot;);
    System.out.println(viesti.lue());

    ArrayList&lt;Tekstiviesti&gt; tekstiviestit = new ArrayList&lt;Tekstiviesti&gt;();
    tekstiviestit.add(new Tekstiviesti(&quot;tuntematon numero&quot;, &quot;I hid the body.&quot;);
</pre>
	<pre>
Huikeaa menoa!</pre>
	<pre class="sh_java">
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add(&quot;Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.&quot;);
    sivut.add(&quot;Erota k&auml;ytt&ouml;liittym&auml;logiikka sovelluksen logiikasta.&quot;);
    sivut.add(&quot;Ohjelmoi aina ensin pieni ohjelma joka ratkaisee vain osan ongelmasta.&quot;);
    sivut.add(&quot;Harjoittelu tekee mestarin. Keksi joku hauska oma projekti.&quot;);

    Sahkokirja kirja = new Sahkokirja(&quot;Vinkkej&auml; ohjelmointiin.&quot;, sivut);
    for(int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
</pre>
	<pre>
Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.
Erota k&auml;ytt&ouml;liittym&auml;logiikka sovelluksen logiikasta.
Ohjelmoi aina ensin pieni ohjelma joka ratkaisee vain osan ongelmasta.
Harjoittelu tekee mestarin. Keksi joku hauska oma projekti.
</pre>
	<div class="tehtavat">
		<h3>
			Palvelusvelvollinen</h3>
		<p>Teht&auml;v&auml;pohjassa on valmiina rajapinta <code>Palvelusvelvollinen</code>, jossa on seuraavat toiminnot:</p>
		<ul>
			<li>
				metodi <code>int getTJ()</code>palauttaa j&auml;ljell&auml; olevien palvelusp&auml;ivien m&auml;&auml;r&auml;n</li>
			<li>
				metodi <code>void palvele()</code>v&auml;hent&auml;&auml; yhden palvelusp&auml;iv&auml;n. Palvelusp&auml;ivien m&auml;&auml;r&auml; ei saa menn&auml; negatiiviseksi.</li>
		</ul>
		<pre class="sh_java">
public interface Palvelusvelvollinen {
    int getTJ();
    void palvele();
}
</pre>
		<h4>
			Sivari</h4>
		<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Sivari</code>, jolla parametriton konstruktori. Luokalla on oliomuuttuja TJ, joka alustetaan konstruktorikutsun yhteydess&auml; arvoon 362.</p>
		<h4>
			Asevelvollinen</h4>
		<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Asevelvollinen</code>, jolla on parametrillinen konstruktori, jolla m&auml;&auml;ritell&auml;&auml;n palvelusaika (<code>int tj</code>).</p>
	</div>
	<h3>
		Rajapinta muuttujan tyyppin&auml;</h3>
	<p>Uutta muuttujaa esitelless&auml; esitell&auml;&auml;n aina muuttujan tyyppi. Muuttujatyyppej&auml; on kahdenlaisia, alkeistyyppiset muuttujat (int, double, ...) ja viittaustyyppiset muuttujat (kaikki oliot). Olemme t&auml;h&auml;n menness&auml; k&auml;ytt&auml;neet viittaustyyppisten muuttujien tyyppin&auml; olion luokkaa.</p>
	<pre class="sh_java">
    String merkkijono = &quot;merkkijono-olio&quot;;
    Tekstiviesti viesti = new Tekstiviesti(&quot;ope&quot;, &quot;Kohta tapahtuu huikeita&quot;);
</pre>
	<p>Olion tyyppi voi olla muutakin kuin sen luokka. Esimerkiksi rajapinnan <code>Luettava</code>toteuttavan luokan tyyppi on lis&auml;ksi <code>Luettava</code>. Esimerkiksi koska luokka <code>Tekstiviesti</code>toteuttaa rajapinnan <code>Luettava</code>, on sill&auml; tyypin <code>Tekstiviesti</code>lis&auml;ksi my&ouml;s tyyppi <code>Luettava</code>.</p>
	<pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti(&quot;ope&quot;, &quot;Kohta tapahtuu huikeita&quot;);
    Luettava luettava = new Tekstiviesti(&quot;ope&quot;, &quot;Tekstiviesti on Luettava!&quot;);
</pre>
	<pre class="sh_java">
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add(&quot;Metodi voi kutsua itse itse&auml;&auml;n.&quot;);

    Luettava kirja = new Sahkokirja(&quot;Rekursion alkeet.&quot;, sivut);
    for(int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
</pre>
	<p>Koska rajapintaa voidaan k&auml;ytt&auml;&auml; tyyppin&auml;, on mahdollista luoda rajapintaluokan tyyppisi&auml; olioita sis&auml;lt&auml;v&auml; lista.</p>
	<pre class="sh_java">
    ArrayList&lt;Luettava&gt; lukulista = new ArrayList&lt;Luettava&gt;();

    lukulista.add(new Tekstiviesti(&quot;ope&quot;, &quot;never been programming before...&quot;));
    lukulista.add(new Tekstiviesti(&quot;ope&quot;, &quot;gonna love it i think!&quot;));
    lukulista.add(new Tekstiviesti(&quot;ope&quot;, &quot;give me something more challenging! :)&quot;));
    lukulista.add(new Tekstiviesti(&quot;ope&quot;, &quot;you think i can do it?&quot;));
    lukulista.add(new Tekstiviesti(&quot;ope&quot;, &quot;up here we send several messages each day&quot;));

    for (Luettava luettava: lukulista) {
        System.out.println(luettava.lue());
    }
</pre>
	<p>Huomaa ett&auml; vaikka rajapinnan <code>Luettava</code>toteuttava luokka <code>Sahkokirja</code>on aina rajapinnan tyyppinen, eiv&auml;t kaikki <code>Luettava</code>-rajapinnan toteuttavat luokat ole tyyppi&auml; <code>Sahkokirja</code>. Luokasta <code>Sahkokirja</code>tehdyn olion asettaminen <code>Luettava</code>-tyyppiseen muuttujaan onnistuu, mutta toiseen suuntaan asetus ei ole sallittua ilman erillist&auml; tyyppimuunnosta.</p>
	<pre class="sh_java">
    Luettava luettava = new Tekstiviesti(&quot;ope&quot;, &quot;Tekstiviesti on Luettava!&quot;); // toimii
    Tekstiviesti viesti = luettava; // ei toimi

    Tekstiviesti muunnettuViesti = (Tekstiviesti) luettava; // toimii
</pre>
	<p>Tyyppimuunnos onnistuu jos ja vain jos muuttuja on oikeastikin sit&auml; tyyppi&auml; johon sit&auml; yritet&auml;&auml;n muuntaa. Tyyppimuunnoksen k&auml;ytt&ouml;&auml; ei yleisesti suositella, ja l&auml;hes ainut sallittu paikka sen k&auml;ytt&ouml;&ouml;n on <code>equals</code>-metodin toteutuksessa.</p>
	<h3>
		Rajapinta metodin parametrina</h3>
	<p>Rajapintojen todelliset hy&ouml;dyt tulevat esille kun niit&auml; k&auml;ytet&auml;&auml;n metodille annettavan parametrin tyyppin&auml;. Koska rajapintaa voidaan k&auml;ytt&auml;&auml; muuttujan tyyppin&auml;, voidaan sit&auml; k&auml;ytt&auml;&auml; metodikutsuissa parametrin tyyppin&auml;. Esimerkiksi seuraavan luokan <code>Tulostin</code>metodi <code>tulosta</code>saa parametrina <code>Luettava</code>-tyyppisen muuttujan.</p>
	<pre class="sh_java">
public class Tulostin {
    public void tulosta(Luettava luettava) {
        System.out.println(luettava.lue());
    }
}
</pre>
	<p>Luokan <code>Tulostin</code>tarjoaman metodin <code>tulosta</code>huikeus piilee siin&auml;, ett&auml; sille voi antaa parametrina <em>mink&auml; tahansa</em> <code>Luettava</code>-rajapinnan toteuttavan luokan ilmentym&auml;n. Kutsummepa metodia mill&auml; tahansa Luettava-luokan toteuttaneen luokan oliolla, metodi osaa toimia oikein.</p>
	<pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti(&quot;ope&quot;, &quot;Huhhuh, t&auml;&auml; tulostinkin osaa tulostaa n&auml;it&auml;!&quot;);
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add(&quot;Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisi&auml; lukuja ovat {3, 5}.&quot;);

    Sahkokirja kirja = new Sahkokirja(&quot;Yliopistomatematiikan perusteet.&quot;, sivut);

    Tulostin tulostin = new Tulostin();
    tulostin.tulosta(viesti);
    tulostin.tulosta(kirja);
</pre>
	<pre>
Huhhuh, t&auml;&auml; tulostinkin osaa tulostaa n&auml;it&auml;!
Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisi&auml; lukuja ovat {3, 5}.
</pre>
	<p>Toteutetaan toinen luokka <code>Lukulista</code>, johon voidaan lis&auml;t&auml; mielenkiintoisia luettavia asioita. Luokalla on oliomuuttujana <code>ArrayList</code>-luokan ilmentym&auml;, johon luettavia asioita tallennetaan. Lukulistaan lis&auml;&auml;minen tapahtuu <code>lisaa</code>-metodilla, joka saa parametrikseen <code>Luettava</code>-tyyppisen olion.</p>
	<pre class="sh_java">
public class Lukulista {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;Luettava&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }
}
</pre>
	<p>Lukulistat ovat yleens&auml; luettavia, joten toteutetaan luokalle <code>Lukulista</code>rajapinta <code>Luettava</code>. Lukulistan <code>lue</code>-metodi lukee kaikki <code>luettavat</code>-listalla olevat oliot l&auml;pi, ja lis&auml;&auml; yksitellen niiden <code>lue()</code>-metodin palauttaman merkkijonon StringBuilder-olioon. T&auml;m&auml;n j&auml;lkeen lukulista tyhjennet&auml;&auml;n ja palautetaan StringBuilder-olioon luettu data.</p>
	<pre class="sh_java">
public class Lukulista implements Luettava {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;Luettava&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }

    public String lue() {
        StringBuilder luettu = new StringBuilder();
        for(Luettava luettava: this.luettavat) {
            luettu.append(luettava.lue()).append(&quot;\n&quot;);
        }

        this.luettavat.clear();
        return luettu.toString();
    }
}
</pre>
	<pre class="sh_java">
    Lukulista joelinLista = new Lukulista();
    joelinLista.lisaa(new Tekstiviesti(&quot;matti&quot;, &quot;teitk&ouml; jo testit?&quot;));
    joelinLista.lisaa(new Tekstiviesti(&quot;matti&quot;, &quot;katsoitko jo palautukset?&quot;));

    System.out.println(&quot;Joelilla luettavia: &quot; + joelinLista.luettavia());
</pre>
	<pre>
Joelilla luettavia: 2
</pre>
	<p>Koska <code>Lukulista</code>on tyyppi&auml; <code>Luettava</code>, voi lukulistalle lis&auml;t&auml; <code>Lukulista</code>-olioita. Alla olevassa esimerkiss&auml; Joelilla on paljon luettavaa. Onneksi Mikael tulee h&auml;tiin ja lukee viestit Joelin puolesta.</p>
	<pre class="sh_java">
    Lukulista joelinLista = new Lukulista();
    for (int i = 0; i &lt; 1000; i++) {
        joelinLista.lisaa(new Tekstiviesti(&quot;matti&quot;, &quot;teitk&ouml; jo testit?&quot;));
    }

    System.out.println(&quot;Joelilla luettavia: &quot; + joelinLista.luettavia());
    System.out.println(&quot;Delegoidaan lukeminen Mikaelille&quot;);

    Lukulista mikaelinLista = new Lukulista();
    mikaelinLista.lisaa(joelinLista);
    mikaelinLista.lue();

    System.out.println();
    System.out.println(&quot;Joelilla luettavia: &quot; + joelinLista.luettavia());
</pre>
	<pre>
Joelilla luettavia: 1000
Delegoidaan lukeminen Mikaelille

Joelilla luettavia: 0
</pre>
	<p>Ohjelmassa Mikaelin listalle kutsuttu <code>lue</code>-metodi k&auml;y kaikki sen sis&auml;lt&auml;m&auml;t <code>Luettava</code>-oliot l&auml;pi, ja kutsuu niiden <code>lue</code>-metodia. Kutsuttaessa <code>lue</code>-metodia Mikaelin listalle k&auml;yd&auml;&auml;n my&ouml;s Mikaelin lukulistalla oleva Joelin lukulista l&auml;pi. Joelin lukulista k&auml;yd&auml;&auml;n l&auml;pi kutsumalla sen <code>lue</code>-metodia. Jokaisen <code>lue</code>-metodin kutsun lopussa tyhjennet&auml;&auml;n juuri luettu lista. Eli Joelin lukulista tyhjenee kun Mikael lukee sen.</p>
	<p><em>T&auml;ss&auml; on jo hyvin paljon viitteit&auml;, kannattaa piirt&auml;&auml; oliot paperille ja hahmotella miten <code>mikaelinLista</code>-oliolle tapahtuva metodikutsu <code>lue</code>etenee!</em></p>
	<div class="tehtavat">
		<h3>
			Tavaroita ja laatikoita</h3>
		<h4 class="req">
			Talletettavia</h4>
		<p>Muuton yhteydessa tarvitaan muuttolaatikoita. Laatikoihin talletetaan erilaisia esineit&auml;. Kaikkien laatikoihin talletettavien esineiden on toteutettava seuraava rajapinta:</p>
		<pre class="sh_java">
public interface Talletettava {
    double paino();
}
</pre>
		<p>Lis&auml;&auml; rajapinta ohjelmaasi. Rajapinta lis&auml;t&auml;&auml;n melkein samalla tavalla kuin luokka, <i>new Java class</i> sijaan valitaan <i>new Java interface</i>.</p>
		<p>Tee rajapinnan toteuttavat luokat <code>Kirja</code>ja <code>CDLevy</code>. Kirja saa konstruktorin parametreina kirjan kirjoittajan (String), kirjan nimen (String), ja kirjan painon (double). CD-Levyn konstruktorin parametreina annetaan artisti (String), levyn nimi (String), ja julkaisuvuosi (int). Kaikkien CD-levyjen paino on 0.1 kg.</p>
		<p>Muista toteuttaa luokilla my&ouml;s rajapinta <code>Talletettava</code>. Luokkien tulee toimia seuraavasti:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Kirja kirja1 = new Kirja(&quot;Fedor Dostojevski&quot;, &quot;Rikos ja Rangaistus&quot;, 2);
        Kirja kirja2 = new Kirja(&quot;Robert Martin&quot;, &quot;Clean Code&quot;, 1);
        Kirja kirja3 = new Kirja(&quot;Kent Beck&quot;, &quot;Test Driven Development&quot;, 0.5);

        CDLevy cd1 = new CDLevy(&quot;Pink Floyd&quot;, &quot;Dark Side of the Moon&quot;, 1973);
        CDLevy cd2 = new CDLevy(&quot;Wigwam&quot;, &quot;Nuclear Nightclub&quot;, 1975);
        CDLevy cd3 = new CDLevy(&quot;Rendezvous Park&quot;, &quot;Closer to Being Here&quot;, 2012);

        System.out.println(kirja1);
        System.out.println(kirja2);
        System.out.println(kirja3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
</pre>
		<p>Tulostus:</p>
		<pre>
Fedor Dostojevski: Rikos ja Rangaistus
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
</pre>
		<p>Huom! Painoa ei ilmoiteta tulostuksessa.</p>
		<h4 class="req">
			Laatikko</h4>
		<p>Tee luokka laatikko, jonka sis&auml;lle voidaan tallettaa <code>Talletettava</code>-rajapinnan toteuttavia tavaroita. Laatikko saa konstruktorissaan parametrina laatikon maksimikapasiteetin kiloina. Laatikkoon ei saa lis&auml;t&auml; enemp&auml;&auml; tavaraa kuin sen maksimikapasiteetti m&auml;&auml;r&auml;&auml;. Laatikon sis&auml;lt&auml;mien tavaroiden paino ei siis koskaan saa olla yli laatikon maksimikapasiteetin.</p>
		<p>Seuraavassa esimerkki laatikon k&auml;yt&ouml;st&auml;:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Laatikko laatikko = new Laatikko(10);

        laatikko.lisaa( new Kirja(&quot;Fedor Dostojevski&quot;, &quot;Rikos ja Rangaistus&quot;, 2) ) ;
        laatikko.lisaa( new Kirja(&quot;Robert Martin&quot;, &quot;Clean Code&quot;, 1) );
        laatikko.lisaa( new Kirja(&quot;Kent Beck&quot;, &quot;Test Driven Development&quot;, 0.5) );

        laatikko.lisaa( new CDLevy(&quot;Pink Floyd&quot;, &quot;Dark Side of the Moon&quot;, 1973) );
        laatikko.lisaa( new CDLevy(&quot;Wigwam&quot;, &quot;Nuclear Nightclub&quot;, 1975) );
        laatikko.lisaa( new CDLevy(&quot;Rendezvous Park&quot;, &quot;Closer to Being Here&quot;, 2012) );

        System.out.println( laatikko );
    }
</pre>
		<p>Tulostuu</p>
		<pre>
Laatikko: 6 esinett&auml;, paino yhteens&auml; 3.8 kiloa
</pre>
		<h4 class="req">
			Laatikon paino</h4>
		<p>Jos teit laatikon sis&auml;lle oliomuuttujan <code>double paino</code>, joka muistaa laatikossa olevien esineiden painon, korvaa se metodilla, joka laskee painon:</p>
		<pre class="sh_java">
public class Laatikko {
    //...

    public double paino() {
        double paino = 0;
        // laske laatikkoon talletettujen tavaroiden yhteispaino
        return paino;
    }
}
</pre>
		<p>Kun tarvitset laatikon sis&auml;ll&auml; painoa esim. uuden tavaran lis&auml;yksen yhteydess&auml;, riitt&auml;&auml; siis kutsua laatikon painon laskevaa metodia.</p>
		<p>Metodi toki voisi palauttaa my&ouml;s oliomuuttujan arvon. Harjoittelemme t&auml;ss&auml; kuitenkin tilannetta, jossa oliomuuttujaa ei tarvitse eksplisiittisesti yll&auml;pit&auml;&auml; vaan se voidaan tarpeentullen laskea. Seuraavan teht&auml;v&auml;n j&auml;lkeen laatikossa olevaan oliomuuttujaan talletettu painotieto ei kuitenkaan v&auml;ltt&auml;m&auml;tt&auml; en&auml;&auml; toimisi. Miksi?</p>
		<h4 class="req">
			Laatikkokin on talletettava!</h4>
		<p>Rajapinnan <code>Talletettava</code>toteuttaminen siis edellytt&auml;&auml; ett&auml; luokalla on metodi <code>double paino()</code>. Laatikollehan lis&auml;ttiin juuri t&auml;m&auml; metodi. Laatikosta voidaan siis tehd&auml; talletettava!</p>
		<p>Laatikot ovat oliota joihin voidaan laittaa <code>Talletettava</code>-rajapinnan toteuttavia olioita. Laatikot toteuttavat itsekin rajapinnan. Eli <b>laatikon sis&auml;ll&auml; voi olla my&ouml;s laatikoita!</b></p>
		<p>Kokeile ett&auml; n&auml;in varmasti on, eli tee ohjelmassasi muutama laatikko, laita laatikoihin tavaroita ja laita pienempi&auml; laatikoita isompien laatikoiden sis&auml;&auml;n. Kokeile my&ouml;s mit&auml; tapahtuu kun laitat laatikon itsens&auml; sis&auml;lle. Miksi n&auml;in k&auml;y?</p>
	</div>
	<h3>
		Rajapinta metodin paluuarvona</h3>
	<p>Kuten mit&auml; tahansa muuttujan tyyppi&auml;, my&ouml;s rajapintaa voi k&auml;ytt&auml;&auml; metodin paluuarvona. Toteutetaan luokat <code>Uutinen</code>, joka kuvaa yksitt&auml;ist&auml; luettavaa uutista, ja <code>Uutispalvelu</code>, jonka teht&auml;v&auml;n&auml; on luoda luettavia uutisia. Uutispalvelua k&auml;ytt&auml;ville sovelluksille ei ole t&auml;rke&auml;&auml; tai edes mielek&auml;st&auml; tiet&auml;&auml; uutisten todellisesta toteutuksesta, oleellista on vain niiden lukeminen. Uutispalvelu voi siis hyvin tarjota uutisensa <code>Luettava</code>-rajapinnan kautta.</p>
	<pre class="sh_java">
public class Uutinen implements Luettava {
    private String teksti = teksti;

    public Uutinen(String teksti) {
        this.teksti = teksti;
    }

    public String lue() {
        return this.teksti;
    }
}
</pre>
	<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new Uutinen(&quot;uusinta hottia!&quot;);
    }
}
</pre>
	<p>Uutispalvelu tuottaa uutisensa aina <code>Luettava</code>-rajapinnan tyyppisen&auml;. T&auml;ss&auml; kohtaa nousee usein esille erinomainen kysymys &quot;<code>Miksi emme käyttäisi vain luokkaa Uutinen?</code>&quot;. Vastaus on pitk&auml;hk&ouml;, mutta toivottavasti selvitt&auml;&auml; taustaidean.</p>
	<p>Pohditaan tilannetta, jossa meill&auml; on uutisia julkaiseva <code>Julkaisupalvelu</code>. Julkaisupalvelun teht&auml;v&auml;n&auml; on lukea uutisia tasaisin v&auml;liajoin uutispalvelulta ja tulostaa viestit n&auml;kyville (julkaisupalvelu voisi l&auml;hett&auml;&auml; hyvin viestin esimerkiksi eri medioille, mutta pid&auml;tt&auml;ydyt&auml;&auml;n pienemm&auml;ss&auml; esimerkiss&auml;). Oletetaan ett&auml; Uutispalvelu palauttaa Uutinen-olioita.</p>
	<pre class="sh_java">
public class Uutispalvelu {

    public Uutinen haeViimeisinUutinen() {
        return new Uutinen(&quot;uusinta hottia!&quot;);
    }
}
</pre>
	<p>Julkaisupalvelun oleellinen toiminnallisuus on toistolauseke, joka kutsuu tasaisin v&auml;liajoin uutispalvelun <code>haeViimeisinUutinen-metodia</code>.</p>
	<pre class="sh_java">
public class Julkaisupalvelu {
    private Uutispalvelu uutispalvelu;

    public Julkaisupalvelu() {
        this.uutispalvelu = new Uutispalvelu();
    }

    public void kaynnista() {
        while (true) {
            Uutinen uutinen = uutispalvelu.haeViimeisinUutinen();
            System.out.println(uutinen.lue());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>
	<p>T&auml;ss&auml; vaiheessa kaikki toimii hyvin. Oletetaan ett&auml; Uutispalvelun toimitusjohtaja huomaa, ett&auml; he tarvitsevat uuden formaatin kuvallisille uutisille. Kuvallisia uutisia varten toteutetaan erillinen luokka <code>KuvaUutinen</code>. KuvaUutinen on luettava, joten Uutispalvelun ohjelmoijat toteuttavat my&ouml;s sille rajapinnan Luettava-rajapinta.</p>
	<pre class="sh_java">
public class KuvaUutinen implements Luettava {
    private String kuvaOsoite;
    private String teksti;

    public KuvaUutinen(String teksti, String kuvaOsoite) {
        this.teksti = teksti;
        this.kuvaOsoite = kuvaOsoite;
    }

    public String lue() {
        return this.teksti + &quot; (kuvan osoite: &quot; + this.kuvaOsoite + &quot;)&quot;;
    }
}
</pre>
	<p>Samalla he joutuvat my&ouml;s muuttamaan UutisPalvelu-luokan toteutusta, sill&auml; se ei tue uutta uutisformaattia:</p>
	<pre class="sh_java">
public class Uutispalvelu {

    public KuvaUutinen haeViimeisinUutinen() {
        return new KuvaUutinen(&quot;uusinta hottia!&quot;, &quot;kuvan osoite&quot;);
    }
}
</pre>
	<p>Nyt julkaisupalvelun toteutusta on <em>pakko</em> muuttaa, sill&auml; se ei en&auml;&auml; toimi koska Uutispalvelu palauttaa <code>KuvaUutinen</code>-luokan ilmentym&auml;n. Kuinka montaa luokkaa pit&auml;isi muuttaa jos uutispalvelua olisi k&auml;ytt&auml;nyt kymmenen palvelua, ent&auml; jos tuhat? T&auml;ss&auml; vaiheessa <em>jokaisen</em> uutispalvelua k&auml;ytt&auml;v&auml;n sovelluksen tulee muuttaa omaa toimintaansa.</p>
	<p>Ent&auml; jos kaikissa uutisissa ei ole kuvia, ja haluaisimme silloin t&auml;ll&ouml;in kuitenkin palauttaa <code>Uutinen</code>-luokan ilmentym&auml;n? Yll&auml; oleva metodi <code>haeViimeisinUutinen</code>ei taida riitt&auml;&auml;..</p>
	<p>Pohditaan seuraavaksi yll&auml; tehty&auml; uutisformaatin muutosta tilanteessa, jossa Uutispalvelun <code>haeViimeisinUutinen</code>-metodin palautustyyppi on <code>Luettava</code>.</p>
	<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new Uutinen(&quot;uusinta hottia!&quot;);
    }
}
</pre>
	<p>Kun Uutispalvelun toimitusjohtaja haluaa uuden kuvaformaatin, ei Uutispalvelun <code>haeViimeisinUutinen</code>-metodin palautustyypille tarvitse tehd&auml; mit&auml;&auml;n.</p>
	<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new KuvaUutinen(&quot;uusinta hottia!&quot;, &quot;kuvan osoite&quot;);
    }
}
</pre>
	<p>Julkaisupalveluunkaan ei tarvitse tehd&auml; muutoksia.</p>
	<pre class="sh_java">
public class Julkaisupalvelu {
    private Uutispalvelu uutispalvelu;

    public Julkaisupalvelu() {
        this.uutispalvelu = new Uutispalvelu();
    }

    public void kaynnista() {
        while (true) {
            Luettava luettava = uutispalvelu.haeViimeisinUutinen();
            System.out.println(luettava.lue());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>
	<p>Kuinka montaa luokkaa olisi pit&auml;nyt muuttaa jos uutispalvelua olisi k&auml;ytt&auml;nyt kymmenen palvelua, ent&auml; jos tuhat? Nollaa. Ent&auml; jos uutispalvelu haluaa v&auml;lill&auml; l&auml;hett&auml;&auml; normaaleja uutisia, v&auml;lill&auml; kuvallisia uutisia? Helppo homma, muutos tarvitaan vain uutispalvelun puolelle.</p>
	<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        Random random = new Random();

        if(random.nextDouble() &gt; 0.5) {
            return new Uutinen(&quot;uusinta hottia!&quot;);
        }

        return new KuvaUutinen(&quot;uusinta hottia!&quot;, &quot;kuvan osoite&quot;);
    }
}
</pre>
	<p>Emme joudu t&auml;ss&auml;k&auml;&auml;n tapauksessa muuttamaan Uutispalvelua k&auml;ytt&auml;vi&auml; sovelluksia.</p>
	<p><em>Rajapintojen k&auml;ytt&ouml; ohjelmoinnissa mahdollistaa riippuvaisuuksien v&auml;hent&auml;misen. Jos kaikki uutispalvelua k&auml;ytt&auml;v&auml;t palvelut k&auml;ytt&auml;v&auml;t rajapintaa Luettava, eiv&auml;t ne ole suoraan riippuvaisia jostain tietyst&auml; Luettava-rajapinnan toteuttavasta luokasta. Yll&auml; olevassa esimerkiss&auml; uutispalvelun sis&auml;ist&auml; toteutusta pystyi muuttamaan siten, ett&auml; siin&auml; tehdyt muutokset eiv&auml;t vaikuttaneet uutispalvelua k&auml;ytt&auml;neisiin olioihin mill&auml;&auml;n tavalla.</em></p>
	<h3>
		Valmiit rajapinnat</h3>
	<p>Javan API tarjoaa huomattavan m&auml;&auml;r&auml;n valmiita rajapintoja. Tutustutaan t&auml;ss&auml; nelj&auml;&auml;n ehk&auml; Javan eniten k&auml;ytettyyn rajapintaan: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code>ja <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>
	<h4>
		List</h4>
	<p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> m&auml;&auml;rittelee listoihin liittyv&auml;n perusk&auml;ytt&auml;ytymisen. Koska ArrayList-luokka toteuttaa <code>List</code>-rajapinnan, voi sit&auml; k&auml;ytt&auml;&auml; my&ouml;s <code>List</code>-rajapinnan kautta.</p>
	<pre class="sh_java">
List&lt;String&gt; merkkijonot = new ArrayList&lt;String&gt;();
merkkijonot.add(&quot;merkkijono-olio arraylist-oliossa!&quot;);
</pre>
	<p>Kuten huomaamme <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List-rajapinnan Java API</a>:sta, rajapinnan <code>List</code>toteuttavia luokkia on useita. Er&auml;s tietojenk&auml;sittelij&ouml;ille tuttu listarakenne on linkitetty lista (<a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>). Linkitetty&auml; listaa voi k&auml;ytt&auml;&auml; rajapinnan List-kautta t&auml;ysin samoin kuin ArrayListist&auml; luotua oliota.</p>
	<pre class="sh_java">
List&lt;String&gt; merkkijonot = new LinkedList&lt;String&gt;();
merkkijonot.add(&quot;merkkijono-olio linkedlist-oliossa!&quot;);
</pre>
	<p>Molemmat rajapinnan <code>List</code>toteutukset toimivat k&auml;ytt&auml;j&auml;n n&auml;k&ouml;kulmasta samoin. Rajapinta siis <em>abstrahoi</em> niiden sis&auml;isen toiminnallisuuden. ArrayListin ja LinkedListin sis&auml;inen rakenne on kuitenkin huomattavan erilainen. ArrayList tallentaa alkioita taulukkoon, josta tietyll&auml; indeksill&auml; hakeminen on nopeaa. LinkedList taas rakentaa listan, jossa jokaisessa listan alkiossa on viite seuraavan listan alkioon. Kun linkitetyss&auml; listassa haetaan alkiota tietyll&auml; indeksill&auml;, tulee listaa k&auml;yd&auml; l&auml;pi alusta indeksiin asti.</p>
	<p>Isoilla listoille voimme n&auml;hd&auml; huomattaviakin suorituskykyeroja. Linkitetyn listan vahvuutena on se, ett&auml; listaan lis&auml;&auml;minen on aina nopeaa. ArrayListill&auml; taas taustalla on taulukko, jota t&auml;ytyy kasvattaa aina kun se t&auml;yttyy. Taulukon kasvattaminen vaatii uuden taulukon luonnin ja vanhan taulukon tietojen kopioinnin uuteen taulukkoon. Toisaalta, indeksin perusteella hakeminen on Arraylistist&auml; eritt&auml;in nopeaa, kun taas linkitetyss&auml; listassa joudutaan k&auml;ym&auml;&auml;n listan alkioita yksitellen l&auml;pi tiettyyn indeksiin p&auml;&auml;semiseksi. Tietorakenteiden kuten linkitetyn listan ja ArrayListin sielunel&auml;m&auml;st&auml; tulee lis&auml;&auml; tietoa kurssilla <em>Tietorakenteet ja algoritmit</em>.</p>
	<p>Ohjelmointikurssilla eteen tulevissa tilanteissa kannattaa k&auml;yt&auml;nn&ouml;ss&auml; aina valita ArrayList. Rajapintoihin ohjelmointi kuitenkin kannattaa: toteuta ohjelmasi siten, ett&auml; k&auml;yt&auml;t tietorakenteita rajapintojen kautta.</p>
	<h4>
		Map</h4>
	<p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> m&auml;&auml;rittelee hajautustauluihin liittyv&auml;n perusk&auml;ytt&auml;ytymisen. Koska HashMap-luokka toteuttaa <code>Map</code>-rajapinnan, voi sit&auml; k&auml;ytt&auml;&auml; my&ouml;s <code>Map</code>-rajapinnan kautta.</p>
	<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put(&quot;gambatte&quot;, &quot;tsemppi&auml;&quot;);
kaannokset.put(&quot;hai&quot;, &quot;kyll&auml;&quot;);
</pre>
	<p>Hajautustaulun avaimet saa hajautustaulusta <code>keySet</code>-metodin avulla.</p>
	<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put(&quot;gambatte&quot;, &quot;tsemppi&auml;&quot;);
kaannokset.put(&quot;hai&quot;, &quot;kyll&auml;&quot;);

for(String key: kaannokset.keySet()) {
    System.out.println(key + &quot;: &quot; + kaannokset.get(key));
}
</pre>
	<pre>
gambatte: tsemppi&auml;
hai: kyll&auml;
</pre>
	<p>Metodi <code>keySet</code>palauttaa <code>Set</code>-rajapinnan toteuttavan joukon alkioita. <code>Set</code>-rajapinnan toteuttavan joukon voi k&auml;yd&auml; l&auml;pi for-each -toistorakenteella. Hajautustaulusta saa talletetut arvot metodin <code>values</code>-avulla. Metodi <code>values</code>palauttaa <code>Collection</code>rajapinnan toteuttavan joukon alkioita. Tutustutaan viel&auml; pikaisesti Set- ja Collection-rajapintoihin.</p>
	<h4>
		Set</h4>
	<p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> kuvaa joukkoihin liittyv&auml;&auml; toiminnallisuutta. Javassa joukot sis&auml;lt&auml;v&auml;t aina joko 0 tai 1 kappaletta tietty&auml; oliota. Set-rajapinnan toteuttaa muun muassa <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Joukon alkioita pystyy k&auml;ym&auml;&auml;n l&auml;pi for-each -rakenteen avulla seuraavasti.</p>
	<pre class="sh_java">
Set&lt;String&gt; joukko = new HashSet&lt;String&gt;();
joukko.add(&quot;yksi&quot;);
joukko.add(&quot;yksi&quot;);
joukko.add(&quot;kaksi&quot;);

for (String alkio: joukko) {
    System.out.println(alkio);
}
</pre>
	<pre>
yksi
kaksi
</pre>
	<p>Huomaa ett&auml; HashSet ei ota mill&auml;&auml;n tavalla kantaa joukon alkioiden j&auml;rjestykseen.</p>
	<h4>
		Collection</h4>
	<p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> kuvaa kokoelmiin liittyv&auml;&auml; toiminnallisuutta. Javassa muun muassa listat ja joukot ovat kokoelmia -- rajapinnat List ja Set toteuttavat rajapinnan Collection. Kokoelmarajapinta tarjoaa metodit muun muassa alkioiden olemassaolon tarkistamiseen (metodi <code>contains</code>) ja kokoelman koon tarkistamiseen (metodi <code>size</code>). Kaikkia kokoelmarajapinnan toteuttavia luokkia voi k&auml;yd&auml; l&auml;pi <code>for-each</code>-toistolausekkeella.</p>
	<p>Luodaan viel&auml; hajautustaulu ja k&auml;yd&auml;&auml;n erikseen l&auml;pi siihen liittyv&auml;t avaimet ja arvot.</p>
	<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put(&quot;gambatte&quot;, &quot;tsemppi&auml;&quot;);
kaannokset.put(&quot;hai&quot;, &quot;kyll&auml;&quot;);

Set&lt;String&gt; avaimet = kaannokset.keySet();
Collection&lt;String&gt; avainKokoelma = avaimet;

System.out.println(&quot;Avaimet:&quot;);
for(String avain: avainKokoelma) {
    System.out.println(avain);
}

System.out.println();
System.out.println(&quot;Arvot:&quot;);
Collection&lt;String&gt; arvot = kaannokset.values();
for(String arvo: arvot) {
    System.out.println(arvo);
}
</pre>
	<pre>
Avaimet:
gambatte
hai

Arvot:
kyll&auml;
tsemppi&auml;
</pre>
	<p>My&ouml;s seuraavanlainen hajautustaulun k&auml;ytt&ouml; olisi luonut saman tulostuksen.</p>
	<pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put(&quot;gambatte&quot;, &quot;tsemppi&auml;&quot;);
kaannokset.put(&quot;hai&quot;, &quot;kyll&auml;&quot;);

System.out.println(&quot;Avaimet:&quot;);
for(String avain: kaannokset.keySet()) {
    System.out.println(avain);
}

System.out.println();
System.out.println(&quot;Arvot:&quot;);
for(String arvo: kaannokset.values()) {
    System.out.println(arvo);
}
</pre>
	<p>Seuraavassa teht&auml;v&auml;ss&auml; rakennetaan verkkokauppa ja harjoitellaan luokkien k&auml;ytt&auml;mist&auml; niiden tarjoamien rajapintojen kautta.</p>
	<div class="tehtavat">
		<h3>
			Verkkokauppa</h3>
		<p>Teemme teht&auml;v&auml;ss&auml; muutamia verkkokaupan hallinnointiin soveltuvia ohjelmakomponentteja.</p>
		<h4>
			Varasto</h4>
		<p>Tee luokka Varasto jolla on seuraavat metodit:</p>
		<ul>
			<li>
				<code>public void lisaaTuote(String tuote, int hinta, int saldo)</code>lis&auml;&auml; varastoon tuotteen jonka hinta ja varastosaldo ovat parametrina annetut luvut</li>
			<li>
				<code>public int hinta(String tuote)</code>palauttaa parametrina olevan tuotteen hinnan, jos tuotetta ei ole varastossa, palauttaa metodi -99</li>
		</ul>
		<p>Varaston sis&auml;ll&auml; tuotteiden hinnat (ja seuraavassa kohdassa saldot) tulee tallettaa <code>Map&lt;String, Integer&gt;</code>-tyyppiseksi m&auml;&auml;riteltyyn muuttujaan! Luotava olio voi olla tyypilt&auml;&auml;n <code>HashMap</code>, muuttujan tyyppin&auml; on kuitenkin k&auml;ytett&auml;v&auml; <code>Map</code>-rajapintaa (ks. <a href="#46.4.2">46.4.2.</a>)</p>
		<p>Seuraavassa esimerkki varaston k&auml;yt&ouml;st&auml;:</p>
		<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote(&quot;maito&quot;, 3, 10);
        varasto.lisaaTuote(&quot;kahvi&quot;, 5, 7);

        System.out.println(&quot;hinnat:&quot;);
        System.out.println(&quot;maito:  &quot; + varasto.hinta(&quot;maito&quot;));
        System.out.println(&quot;kahvi:  &quot; + varasto.hinta(&quot;kahvi&quot;));
        System.out.println(&quot;sokeri: &quot; + varasto.hinta(&quot;sokeri&quot;));
</pre>
		<p>Tulostuu:</p>
		<pre>
hinnat:
maito:  3
kahvi:  5
sokeri: -99
</pre>
		<h4>
			Tuotteen varastosaldo</h4>
		<p>Talleta tuotteiden varastosaldot samaan tapaan <code>Map&lt;String, Integer&gt;</code>-tyyppiseen muuttujaan kuin talletit hinnat. T&auml;ydenn&auml; varastoa seuraavilla metodeilla:</p>
		<ul>
			<li>
				<code>public int saldo(String tuote)</code>palauttaa parametrina olevan tuotteen varastosaldon.</li>
			<li>
				<code>public boolean ota(String tuote)</code>v&auml;hent&auml;&auml; parametrina olevan tuotteen saldoa yhdell&auml; ja palauuttaa <em>true</em> jos tuotetta oli varastossa. Jos tuotetta ei ole varastossa, palauttaa metodi <em>false</em>, tuotteen saldo ei saa laskea alle nollan.</li>
		</ul>
		<p>Esimerkki varaston k&auml;yt&ouml;st&auml;:</p>
		<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote(&quot;kahvi&quot;, 5, 1);

        System.out.println(&quot;saldot:&quot;);
        System.out.println(&quot;kahvi:  &quot; + varasto.saldo(&quot;kahvi&quot;));
        System.out.println(&quot;sokeri: &quot; + varasto.saldo(&quot;sokeri&quot;));

        System.out.println(&quot;otetaan kahvi &quot; + varasto.ota(&quot;kahvi&quot;));
        System.out.println(&quot;otetaan kahvi &quot; + varasto.ota(&quot;kahvi&quot;));
        System.out.println(&quot;otetaan sokeri &quot; + varasto.ota(&quot;sokeri&quot;));

        System.out.println(&quot;saldot:&quot;);
        System.out.println(&quot;kahvi:  &quot; + varasto.saldo(&quot;kahvi&quot;));
        System.out.println(&quot;sokeri: &quot; + varasto.saldo(&quot;sokeri&quot;));
</pre>
		<p>Tulostuu:</p>
		<pre>
saldot:
kahvi:  1
sokeri: 0
otetaan kahvi true
otetaan kahvi false
otetaan sokeri false
saldot:
kahvi:  0
sokeri: 0
</pre>
		<h4>
			Tuotteiden listaus</h4>
		<p>List&auml;t&auml;&auml;n varastolle viel&auml; yksi metodi:</p>
		<ul>
			<li>
				<code>public Set&lt;String&gt; tuotteet()</code>palauttaa <em>joukkona</em> varastossa olevien tuotteiden nimet</li>
		</ul>
		<p>Metodi on helppo toteuttaa. Saat tietoon varastossa olevat tuotteet kysym&auml;ll&auml; ne joko hinnat tai saldot muistavalta Map:ilt&auml; metodin <code>keySet</code>avulla.</p>
		<p>Esimerkki varaston k&auml;yt&ouml;st&auml;:</p>
		<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote(&quot;maito&quot;, 3, 10);
        varasto.lisaaTuote(&quot;kahvi&quot;, 5, 6);
        varasto.lisaaTuote(&quot;piim&auml;&quot;, 2, 20);
        varasto.lisaaTuote(&quot;jugurtti&quot;, 2, 20);

        System.out.println(&quot;tuotteet:&quot;);
        for (String tuote : varasto.tuotteet()) {
            System.out.println(tuote);
        }
</pre>
		<p>Tulostuu:</p>
		<pre>
tuotteet:
piim&auml;
jugurtti
kahvi
maito
</pre>
		<h4>
			Ostos</h4>
		<p>Ostoskoriin lis&auml;t&auml;&auml;n <em>ostoksia</em>. Ostoksella tarkoitetaan tietty&auml; m&auml;&auml;r&auml;&auml; tiettyj&auml; tuotteita. Koriin voidaan laittaa esim. ostos joka vastaa yht&auml; leip&auml;&auml; tai ostos joka vastaa 24:&auml;&auml; kahvia.</p>
		<p>Tee luokka <code>Ostos</code>jolla on seuraavat toiminnot:</p>
		<ul>
			<li>
				<code>public Ostos(String tuote, int kpl, int yksikkohinta)</code>konstruktori joka luo ostoksen joka vastaa parametrina annettua tuotetta. Tuotteita ostoksessa on <em>kpl</em> kappaletta ja yhden tuotteen hinta on kolmantena parametrina annettu <em>yksikkohinta</em></li>
			<li>
				<code>public int hinta()</code>palauttaa ostoksen hinnan. Hinta saadaan kertomalla kappalem&auml;&auml;r&auml; yksikk&ouml;hinnalla</li>
			<li>
				<code>public void kasvataMaaraa()</code>kasvattaa ostoksen kappalem&auml;&auml;r&auml;&auml; yhdell&auml;</li>
			<li>
				<code>public String toString()</code>palauttaa ostoksen merkkijonomuodossa, joka on alla olevan esimerkin mukainen</li>
		</ul>
		<p>Esimerkki ostoksen k&auml;yt&ouml;st&auml;</p>
		<pre class="sh_java">
        Ostos ostos = new Ostos(&quot;maito&quot;, 4, 2);
        System.out.println( &quot;ostoksen joka sis&auml;lt&auml;&auml; 4 maitoa yhteishinta on &quot; + ostos.hinta() );
        System.out.println( ostos );
        ostos.kasvataMaaraa();
        System.out.println( ostos );
</pre>
		<p>Tulostuu:</p>
		<pre>
ostoksen joka sis&auml;lt&auml;&auml; 4 maitoa yhteishinta on 8
maito: 4
maito: 5
</pre>
		<p>Huom: <em>toString</em> on siis muotoa <em>tuote: kpl</em> hintaa ei merkkijonoesitykseen tule!</p>
		<h4>
			Ostoskori</h4>
		<p>Vihdoin p&auml;&auml;semme toteuttamaan luokan ostoskori!</p>
		<p>Ostoskori tallettaa sis&auml;isesti koriin lis&auml;tyt tuotteet <em>Ostos-olioina</em>. Ostoskorilla tulee olla oliomuuttja jonka tyyppi on joko <code>Map&lt;String, Ostos&gt;</code>tai <code>List&lt;Ostos&gt;</code>. &Auml;l&auml; laita mit&auml;&auml;n muita oliomuuttujia ostoskorille kuin ostosten talletukseen tarvittava Map tai List.</p>
		<p>Huom: jos talletat Ostos-oliot Map-tyyppiseen apumuuttujaan, on t&auml;ss&auml; ja seuraavassa teht&auml;v&auml;ss&auml; hy&ouml;ty&auml; Map:in metodista values(), jonka avulla on helppo k&auml;yd&auml; l&auml;pi kaikki talletetut ostos-oliot.</p>
		<p>Tehd&auml;&auml;n aluksi ostoskorille parametriton konstruktori ja metodit:</p>
		<ul>
			<li>
				<code>public void lisaa(String tuote, int hinta)</code>lis&auml;&auml; ostoskoriin ostoksen joka vastaa parametrina olevaa tuotetta ja jolla on parametrina annettu hinta.</li>
			<li>
				<code>public int hinta()</code>palauttaa ostoskorin kokonaishinnan</li>
		</ul>
		<p>Esimerkki ostoksen k&auml;yt&ouml;st&auml;</p>
		<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa(&quot;maito&quot;, 3);
        kori.lisaa(&quot;piim&auml;&quot;, 2);
        kori.lisaa(&quot;juusto&quot;, 5);
        System.out.println(&quot;korin hinta: &quot; + kori.hinta());
        kori.lisaa(&quot;tietokone&quot;, 899);
        System.out.println(&quot;korin hinta: &quot; + kori.hinta());
</pre>
		<p>Tulostuu:</p>
		<pre>
korin hinta: 10
korin hinta: 909
</pre>
		<h4>
			Ostoskorin tulostus</h4>
		<p>Tehd&auml;&auml;n ostoskorille metodi <code>public void tulosta()</code>joka tulostaa korin sis&auml;lt&auml;m&auml;t <em>Ostos</em>-oliot. Tulostusj&auml;rjestyksess&auml; ei ole merkityst&auml;. Edellisen esimerkin ostoskori tulostetuna olisi:</p>
		<pre>
piim&auml;: 1
juusto: 1
tietokone: 1
maito: 1
</pre>
		<p>Huomaa, ett&auml; tulostuva numero on siis tuotteen korissa oleva kappalem&auml;&auml;r&auml;, ei hinta!</p>
		<h4>
			yht&auml; tuotetta kohti vain yksi Ostos-olio</h4>
		<p>T&auml;ydennet&auml;&auml;n Ostoskoria siten, ett&auml; jos korissa on jo tuote joka sinne lis&auml;t&auml;&auml;n, ei koriin luoda uutta Ostos-olioa vaan p&auml;ivitet&auml;&auml;n jo korissa olevaa tuotetta vastaavaa ostosolioa kutsumalla sen metodia <em>kasvataMaaraa()</em>.</p>
		<p>Esimerkki:</p>
		<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa(&quot;maito&quot;, 3);
        kori.tulosta();
        System.out.println(&quot;korin hinta: &quot; + kori.hinta() +&quot;\n&quot;);

        kori.lisaa(&quot;piim&auml;&quot;, 2);
        kori.tulosta();
        System.out.println(&quot;korin hinta: &quot; + kori.hinta() +&quot;\n&quot;);

        kori.lisaa(&quot;maito&quot;, 3);
        kori.tulosta();
        System.out.println(&quot;korin hinta: &quot; + kori.hinta() +&quot;\n&quot;);

        kori.lisaa(&quot;maito&quot;, 3);
        kori.tulosta();
        System.out.println(&quot;korin hinta: &quot; + kori.hinta() +&quot;\n&quot;);
</pre>
		<p>Tulostuu:</p>
		<pre>
maito: 1
korin hinta: 3

piim&auml;: 1
maito: 1
korin hinta: 5

piim&auml;: 1
maito: 2
korin hinta: 8

piim&auml;: 1
maito: 3
korin hinta: 11
</pre>
		<p>Eli ensin koriin lis&auml;t&auml;&auml;n maito ja piim&auml; ja niille omat ostos-oliot. Kun koriin lis&auml;t&auml;&auml;n lis&auml;&auml; maitoa, ei luoda uusille maidoille omaa ostosolioa, vaan p&auml;ivitet&auml;&auml;n jo korissa olevan maitoa kuvaavan ostosolion kappalem&auml;&auml;r&auml;&auml;.</p>
		<h4>
			Kauppa</h4>
		<p>Nyt meill&auml; on valmiina kaikki osat &quot;verkkokauppaa&quot; varten. Verkkokaupassa on varasto joka sis&auml;lt&auml;&auml; kaikki tuotteet. Jokaista asiakkaan asiointia varten on oma ostoskori. Aina kun asiakas valitsee ostoksen, lis&auml;t&auml;&auml;n se asiakkaan ostoskoriin jos tuotetta on varastossa. Samalla varastosaldoa pienennet&auml;&auml;n yhdell&auml;.</p>
		<p>Seuraavassa on valmiina verkkokaupan koodin runko. Tee projektiin luokka <code>Kauppa</code>ja kopioi allaoleva koodi luokkaan.</p>
		<pre class="sh_java">
import java.util.Scanner;

public class Kauppa {

    private Varasto varasto;
    private Scanner lukija;

    public Kauppa(Varasto varasto, Scanner lukija) {
        this.varasto = varasto;
        this.lukija = lukija;
    }

    // metodi jolla hoidetaan yhden asiakkaan asiointi kaupassa
    public void asioi(String asiakas) {
        Ostoskori kori = new Ostoskori();
        System.out.println(&quot;Tervetuloa kauppaan &quot; + asiakas);
        System.out.println(&quot;valikoimamme:&quot;);

        for (String tuote : varasto.tuotteet()) {
            System.out.println( tuote );
        }

        while (true) {
            System.out.print(&quot;mit&auml; laitetaan ostoskoriin (pelkk&auml; enter vie kassalle):&quot;);
            String tuote = lukija.nextLine();
            if (tuote.isEmpty()) {
                break;
            }

            // tee t&auml;nne koodi joka lis&auml;&auml; tuotteen ostoskoriin jos sit&auml; on varastossa
            // ja v&auml;hent&auml;&auml; varastosaldoa
            // &auml;l&auml; koske muuhun koodiin!

        }

        System.out.println(&quot;ostoskorissasi on:&quot;);
        kori.tulosta();
        System.out.println(&quot;korin hinta: &quot; + kori.hinta());
    }
}
</pre>
		<p>Seuraavassa p&auml;&auml;ohjelma joka t&auml;ytt&auml;&auml; kaupan varaston ja laittaa Pekan asioimaan kaupassa:</p>
		<pre class="sh_java">
    Varasto varasto = new Varasto();
    varasto.lisaaTuote(&quot;kahvi&quot;, 5, 10);
    varasto.lisaaTuote(&quot;maito&quot;, 3, 20);
    varasto.lisaaTuote(&quot;piim&auml;&quot;, 2, 55);
    varasto.lisaaTuote(&quot;leip&auml;&quot;, 7, 8);

    Kauppa kauppa = new Kauppa(varasto, new Scanner(System.in));
    kauppa.asioi(&quot;Pekka&quot;);
</pre>
		<p>Kauppa on melkein valmiina. Yhden asiakkaan asioinnin hoitavan metodin <code>public void asiointi(String asiakas)</code>on kommenteilla merkitty kohta jonka joudut t&auml;ydent&auml;m&auml;&auml;n. Lis&auml;&auml; kohtaan koodi joka tarkastaa onko asiakkaan haluamaa tuotetta varastossa. Jos on, v&auml;henn&auml; tuotteen varastosaldoa ja lis&auml;&auml; tuote ostoskoriin.</p>
		<p><em>Vapise, verkkokauppa.com!</em></p>
	</div>
	<h2>
		Geneerisyys</h2>
	<p>Geneerisyys (<em>generics</em>) liittyy olioita s&auml;il&ouml;vien luokkien tapaan s&auml;il&ouml;&auml; vapaavalintaisen tyyppisi&auml; olioita. Vapaavalintaisuus perustuu luokkien m&auml;&auml;rittelyss&auml; k&auml;ytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan m&auml;&auml;ritell&auml; <em>olion luontivaiheessa</em> valittavia tyyppej&auml;. Luokan geneerisyys m&auml;&auml;ritell&auml;&auml;n antamalla luokan nimen j&auml;lkeen haluttu m&auml;&auml;r&auml; luokan tyyppiparametreja pienempi kuin ja suurempi kuin -merkkien v&auml;liin. Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden mink&auml;laisen tahansa olion.</p>
	<pre class="sh_java">
public class Lokero&lt;T&gt; {
    private T alkio;

    public void asetaArvo(T alkio) {
        this.alkio = alkio;
    }

    public T haeArvo() {
        return alkio;
    }
}
</pre>
	<p>M&auml;&auml;rittely <code>public class Lokero&lt;T&gt;</code>kertoo ett&auml; luokalle <code>Lokero</code>tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun j&auml;lkeen kaikki olion sis&auml;iset muuttujat tulevat olemaan kutsun yhteydess&auml; annettua tyyppi&auml;. Luodaan merkkijonon tallentava lokero.</p>
	<pre class="sh_java">
    Lokero&lt;String&gt; merkkijono = new Lokero&lt;String&gt;();
    merkkijono.asetaArvo(&quot;:)&quot;);

    System.out.println(merkkijono.haeArvo());
</pre>
	<pre>
:)
</pre>
	<p>Tyyppiparametria vaihtamalla voidaan luoda my&ouml;s muuntyyppisi&auml; olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti</p>
	<pre class="sh_java">
    Lokero&lt;Integer&gt; luku = new Lokero&lt;Integer&gt;();
    luku.asetaArvo(5);

    System.out.println(luku.haeArvo());
</pre>
	<pre>
5
</pre>
	<p>Huomattava osa Javan tietorakenteista on ohjelmoitu geneerisiksi. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.</p>
	<pre class="sh_java">
    List&lt;String&gt; merkkijonot = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; avainArvoParit = new ArrayList&lt;String, String&gt;();
</pre>
	<p>Jatkossa kun n&auml;et esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code>tied&auml;t ett&auml; sen sis&auml;isess&auml; rakenteessa on k&auml;ytetty geneerist&auml; tyyppiparametria.</p>
	<h3>
		Geneerisyytt&auml; hy&ouml;dynt&auml;v&auml; rajapinta: Comparable</h3>
	<p>Normaalien rajapintojen lis&auml;ksi Javassa on geneerisyytt&auml; hy&ouml;dynt&auml;vi&auml; rajapintoja. Geneerisille rajapinnoille m&auml;&auml;ritell&auml;&auml;n sis&auml;isten arvojen tyypit samalla tavalla kuin geneerisille luokille. Tutkitaan Javan valmista rajapintaa <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code>. Rajapinta <code>Comparable</code>m&auml;&auml;rittelee metodin <code>compareTo</code>, jonka tulee palauttaa <code>this</code>-olion paikan vertailuj&auml;rjestyksess&auml; verrattuna parametrina annettuun olioon (negatiivinen luku, 0 tai positiivinen luku). Jos <code>this</code>-olio on vertailuj&auml;rjestyksess&auml; ennen parametrina saatavaa olioa, tulee metodin palauttaa negatiivinen luku, jos taas parametrina saatava olio on j&auml;rjestyksess&auml; ennen, tulee metodin palauttaa positiivinen luku. Jos oliot ovat vertailuj&auml;rjestykselt&auml;&auml;n samat, palautetaan 0. Vertailuj&auml;rjestyksell&auml; tarkoitetaan t&auml;ss&auml; ohjelmoijan m&auml;&auml;rittelem&auml;&auml; olioiden &quot;suuruusj&auml;rjestyst&auml;&quot;, eli jos oliot j&auml;rjestet&auml;&auml;n sort-metodilla, mik&auml; on niiden j&auml;rjestys.</p>
	<p>Yksi <code>Comparable</code>-rajapinnan eduista on se, ett&auml; se mahdollistaa Comparable-tyyppisist&auml; alkioista koostuvan listan j&auml;rjest&auml;misen esimerkiksi standardikirjaston <code>Collections.sort</code>-metodin avulla. <code>Collections.sort</code>k&auml;ytt&auml;&auml; listan alkioiden <code>compareTo</code>-metodia selvitt&auml;&auml;kseen, miss&auml; j&auml;rjestyksess&auml; alkoiden kuuluisi olla. T&auml;t&auml; <code>compareTo</code>-metodin avulla johdettua j&auml;rjestyst&auml; kutsutaan <em>luonnolliseksi j&auml;rjestykseksi</em> (natural ordering).</p>
	<p>Luodaan luokka <code>Kerholainen</code>, joka kuvaa kerhossa k&auml;yv&auml;&auml; lasta tai nuorta. Jokaisella kerholaisella on nimi ja pituus. Kerholaisten tulee menn&auml; aina sy&ouml;m&auml;&auml;n pituusj&auml;rjestyksess&auml;, joten toteutetaan kerholaisille rajapinta <code>Comparable</code>. Comparable-rajapinta ottaa tyyppiparametrinaan my&ouml;s luokan, johon sit&auml; verrataan. K&auml;ytet&auml;&auml;n tyyppiparametrina luokkaa <code>Kerholainen</code>-luokkaa.</p>
	<pre class="sh_java">
public class Kerholainen implements Comparable&lt;Kerholainen&gt; {
    private String nimi;
    private int pituus;

    public Kerholainen(String nimi, int pituus) {
        this.nimi = nimi;
        this.pituus = pituus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getPituus() {
        return this.pituus;
    }

    @Override
    public String toString() {
        return this.getNimi() + &quot; (&quot; + this.getPituus() + &quot;)&quot;;
    }

    @Override
    public int compareTo(Kerholainen kerholainen) {
        if(this.pituus == kerholainen.getPituus()) {
            return 0;
        } else if (this.pituus &gt; kerholainen.getPituus()) {
            return 1;
        } else {
            return -1;
        }
    }
}
</pre>
	<p>Rajapinnan vaatima metodi <code>compareTo</code>palauttaa kokonaisluvun, joka kertoo vertausj&auml;rjestyksest&auml;. Koska <code>compareTo()</code>-metodista riitt&auml;&auml; palauttaa negatiivinen luku, jos <code>this</code>-olio on pienempi kuin parametrina annettu olio ja nolla, kun pituudet ovat samat, voidaan edell&auml; esitelty metodi <code>compareTo</code>toteuttaa my&ouml;s seuraavasti:</p>
	<pre class="sh_java">
    @Override
    public int compareTo(Kerholainen kerholainen) {
        return this.pituus - kerholainen.getPituus();
    }
</pre>
	<p>Kerholaisten j&auml;rjest&auml;minen on nyt helppoa.</p>
	<pre class="sh_java">
    List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;Kerholainen&gt;();
    kerholaiset.add(new Kerholainen(&quot;mikael&quot;, 182));
    kerholaiset.add(new Kerholainen(&quot;matti&quot;, 187));
    kerholaiset.add(new Kerholainen(&quot;joel&quot;, 184));

    System.out.println(kerholaiset);
    Collections.sort(kerholaiset);
    System.out.println(kerholaiset);
</pre>
	<pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
</pre>
	<p>Jos kerholaiset haluaa j&auml;rjest&auml;&auml; k&auml;&auml;nteiseen j&auml;rjestykseen, riitt&auml;&auml; vain <code>compareTo</code>-metodissa olevien muuttujien paikan vaihtaminen.</p>
	<div class="tehtavat">
		<h3>
			K&ouml;yh&auml;t kyykkyyn</h3>
		<p>Saat valmiin luokan Ihminen. Ihmisell&auml; on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, ett&auml; <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan j&auml;rjestykseen - suuripalkkaiset ensin, k&ouml;yh&auml;t kyykkyyn listan loppuun.</p>
		<h3>
			Opiskelijat nimij&auml;rjestykseen</h3>
		<p>Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, ett&auml; <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosj&auml;rjestykseen.</p>
		<p><b>Vinkki:</b> Opiskelijan nimi on String, ja String-luokka on itsess&auml;&auml;n <code>Comparable</code>. Voit hy&ouml;dynt&auml;&auml; String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code>kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja t&auml;t&auml; varten String-luokalla on my&ouml;s metodi <code>compareToIgnoreCase</code>joka nimens&auml; mukaisesti j&auml;tt&auml;&auml; kirjainkoon huomioimatta. Voit k&auml;ytt&auml;&auml; opiskelijoiden j&auml;rjest&auml;miseen kumpaa n&auml;ist&auml; haluat.</p>
		<h3>
			Kortit j&auml;rjestykseen</h3>
		<p>Ohjelmoinnin perusteet-kurssilla toteutettiin Korttipakka-, Kasi- ja Kortti-luokat. Nyt kun osaamme tehd&auml; Comparable-luokkia, voimme parannella tuolloin tekemi&auml;mme ratkaisuja huomattavasti.</p>
		<h4>
			Kortti-luokasta Comparable</h4>
		<p>Saat valmiiksi toteutettuina Korttipakka-, Kasi- ja Kortti-luokat. Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, ett&auml; korttien j&auml;rjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niit&auml; maan perusteella nousevassa j&auml;rjestyksess&auml;: risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</p>
		<h4>
			Korttipakan j&auml;rjest&auml;minen</h4>
		<p>Kun Kortti-luokasta on tehty Comparable, toteuta Korttipakka-luokkaan <code>jarjesta</code>-metodi, joka nimens&auml; mukaisesti j&auml;rjest&auml;&auml; Korttipakan.</p>
		<h4>
			Ojenna k&auml;tesi</h4>
		<p>K&auml;sien k&auml;sittely voi olla helpompaa, jos Kasi-luokan sis&auml;lt&auml;m&auml; korttilista on j&auml;rjestyksess&auml;. T&auml;ll&ouml;in voisimme halutessamme etsi&auml; Kortteja k&auml;dest&auml; vaikka puolitushaulla. Tee siis Kasi-luokan konstruktorista sellainen, ett&auml; jokainen luotu Kasi on j&auml;rjestyksess&auml;.</p>
	</div>
	<h2>
		Collections</h2>
	<p>Luokkakirjasto <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code>on Javan yleishy&ouml;dyllinen kokoelmaluokkiin liittyv&auml; kirjasto. Kuten tied&auml;mme, <code>Collections</code>tarjoaa metodit olioiden j&auml;rjest&auml;miseen joko <code>Comparable</code>- tai <code>Comparator</code>-rajapinnan kautta. J&auml;rjest&auml;misen lis&auml;ksi luokkakirjaston avulla voi etsi&auml; esimerkiksi minimi- (<code>min</code>-metodi) tai maksimialkioita (<code>max</code>-metodi), hakea tietty&auml; arvoa (<code>binarySearch</code>-metodi), tai k&auml;&auml;nt&auml;&auml; listan (<code>reverse</code>-metodi).</p>
	<h3>
		Hakeminen</h3>
	<p>Collections-luokkakirjasto tarjoaa valmiiksi toteutetun bin&auml;&auml;rihaun. Metodi <code>binarySearch()</code>palauttaa haetun alkion indeksin listasta jos se l&ouml;ytyy. Jos alkiota ei l&ouml;ydy, hakualgoritmi palauttaa negatiivisen arvon. Metodi <code>binarySearch()</code>k&auml;ytt&auml;&auml; Comparable-rajapintaa haetun olion l&ouml;yt&auml;miseen. Jos olion <code>compareTo()</code>-metodi palauttaa arvon 0, eli olio on sama, ajatellaan arvon l&ouml;ytyneen.</p>
	<p>Kerholainen-luokkamme vertaa pituuksia <code>compareTo()</code>-metodissaan, eli listasta etsiess&auml; etsisimme samanpituista kerholaista.</p>
	<pre class="sh_java">
    List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;Kerholainen&gt;();
    kerholaiset.add(new Kerholainen(&quot;mikael&quot;, 182));
    kerholaiset.add(new Kerholainen(&quot;matti&quot;, 187));
    kerholaiset.add(new Kerholainen(&quot;joel&quot;, 184));

    Collections.sort(kerholaiset);

    Kerholainen haettava = new Kerholainen(&quot;Nimi&quot;, 180);
    int indeksi = Collections.binarySearch(kerholaiset, haettava);
    if(indeksi &gt;= 0) {
        System.out.println(&quot;180 sentti&auml; pitk&auml; l&ouml;ytyi indeksist&auml; &quot; + indeksi);
        System.out.println(&quot;nimi: &quot; + kerholaiset.get(indeksi).getNimi());
    }

    haettava = new Kerholainen(&quot;Nimi&quot;, 187);
    int indeksi = Collections.binarySearch(kerholaiset, haettava);
    if(indeksi &gt;= 0) {
        System.out.println(&quot;187 sentti&auml; pitk&auml; l&ouml;ytyi indeksist&auml; &quot; + indeksi);
        System.out.println(&quot;nimi: &quot; + kerholaiset.get(indeksi).getNimi());
    }
</pre>
	<p>Esimerkkimme tulostaa seuraavaa</p>
	<pre>
187 sentti&auml; pitk&auml; l&ouml;ytyi indeksist&auml; 2
nimi: matti
</pre>
	<p>Huomaa ett&auml; esimerkiss&auml; kutsuttiin my&ouml;s metodia <code>Collections.sort()</code>. T&auml;m&auml; tehd&auml;&auml;n sen takia, ett&auml; bin&auml;&auml;rihakua ei voida tehd&auml; jos taulukko tai lista ei ole valmiiksi j&auml;rjestyksess&auml;.</p>
	<div class="tehtavat">
		<h3>
			Tilastot kuntoon</h3>
		<p>NHL:ss&auml; pidet&auml;&auml;n pelaajista yll&auml; monenlaisia tilastotietoja. Teemme nyt oman ohjelman NHL-pelaajien tilastojen hallintaan.</p>
		<h4>
			Pelaajalistan tulostus</h4>
		<p>Tee luokka <code>Pelaaja</code>, johon voidaan tallettaa pelaajan nimi, joukkue, pelatut ottelut, maalim&auml;&auml;r&auml;, ja sy&ouml;tt&ouml;m&auml;&auml;r&auml;. Luokalla tulee olla konstruktori, joka saa edell&auml;mainitut tiedot edell&auml; annetussa j&auml;rjestyksess&auml;.</p>
		<p>Tee kaikille edell&auml;minituille arvoille my&ouml;s ns. getterimetodit, jotka palauttavat arvot:</p>
		<ul>
			<li>
				<code>String getNimi</code></li>
			<li>
				<code>String getJoukkue</code></li>
			<li>
				<code>int getOttelut</code></li>
			<li>
				<code>int getMaalit</code></li>
			<li>
				<code>int getSyotot</code></li>
			<li>
				<code>int getPisteet</code>- laskee kokonaispistem&auml;&auml;r&auml;n eli maalien ja sy&ouml;tt&ouml;jen summan</li>
		</ul>
		<p>Talleta seuraavat pelaajat ArrayList:iin ja tulosta listan sis&auml;lt&ouml;:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        pelaajat.add(new Pelaaja(&quot;Alex Ovechkin&quot;, &quot;WSH&quot;, 71, 28, 46));
        pelaajat.add(new Pelaaja(&quot;Dustin Byfuglien&quot;, &quot;ATL&quot;, 69, 19, 31));
        pelaajat.add(new Pelaaja(&quot;Phil Kessel&quot;, &quot;TOR&quot;, 70, 28, 24));
        pelaajat.add(new Pelaaja(&quot;Brendan Mikkelson&quot;, &quot;ANA, CGY&quot;, 23, 0, 2));
        pelaajat.add(new Pelaaja(&quot;Matti Luukkainen&quot;, &quot;SaPKo&quot;, 1, 0, 0 ));

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
    }
</pre>
		<p>Pelaajan <code>toString()</code>-metodin muodostaman tulostuksen tulee olla seuraavassa muodossa:</p>
		<pre>
Alex Ovechkin WSH 71 28 + 46 = 74
Dustin Byfuglien ATL 69 19 + 31 = 50
Phil Kessel TOR 70 28 + 24 = 52
Brendan Mikkelson ANA, CGY 23 0 + 2 = 2
Matti Luukkainen SaPKo 1 0 + 0 = 0
</pre>
		<p>Ensin siis nimi, sitten joukkue, jonka j&auml;lkeen ottelut, maalit, plusmerkki, sy&ouml;t&ouml;t, yht&auml;suuruusmerkki ja kokonaispisteet eli maalien ja sy&ouml;tt&ouml;jen summa.</p>
		<h4>
			Tulostuksen siistiminen</h4>
		<p>Tee <code>Pelaaja</code>-luokkaan metodi <code>toSiistiMerkkijono()</code>, joka palauttaa samat tiedot siististi aseteltuna siten, ett&auml; jokaiselle muuttujalle on varattu tietty m&auml;&auml;r&auml; tilaa tulostuksessa.</p>
		<p>Tulostuksen tulee n&auml;ytt&auml;&auml; seuraavalta:</p>
		<pre>
Alex Ovechkin             WSH             71  28 + 46 = 74
Dustin Byfuglien          ATL             69  19 + 31 = 50
Phil Kessel               TOR             70  28 + 24 = 52
Brendan Mikkelson         ANA, CGY        23   0 +  2 =  2
Matti Luukkainen          SaPKo            1   0 +  0 =  0
</pre>
		<p>Nimen j&auml;lkeen joukkueen nimien t&auml;ytyy alkaa samasta kohdasta. Saat t&auml;m&auml;n aikaan esim. muotoilemalla nimen tulostuksen yhteydess&auml; seuraavasti:</p>
		<pre class="sh_java">
String nimiJaTyhjaa = String.format(&quot;%-25s&quot;, nimi);
</pre>
		<p>Komento tekee merkkijonon <code>nimiJaTyhjaa</code>joka alkaa merkkijonon <code>nimi</code>sis&auml;ll&ouml;ll&auml; ja se j&auml;lkeen tulee v&auml;lily&ouml;ntej&auml; niin paljon ett&auml; merkkijonon pituudeksi tulee 25. Joukkueen nimi tulee vastaavalla tavalla tulostaa 14 merkin pituisena merkkijonona. T&auml;m&auml;n j&auml;lkeen on otteluiden m&auml;&auml;r&auml; (2 merkki&auml;), jota seuraa 2 v&auml;lily&ouml;nti&auml;. T&auml;m&auml;n j&auml;lkeen on maalien m&auml;&auml;r&auml; (2 merkki&auml;), jota seuraa merkkijono &quot; + &quot;. T&auml;t&auml; seuraa sy&ouml;tt&ouml;jen m&auml;&auml;r&auml; (2 merkki&auml;), merkkijono &quot; = &quot;, ja lopuksi yhteispisteet (2 merkki&auml;).</p>
		<p>Lukuarvot eli ottelu-, maali-, sy&ouml;tt&ouml;- ja pistem&auml;&auml;r&auml; muotoillaan kahden merkin mittaisena, eli lukeman 0 sijaan tulee tulostua v&auml;lily&ouml;nti ja nolla. Seuraava komento auttaa t&auml;ss&auml;:</p>
		<pre class="sh_java">
String maalitMerkkeina = String.format(&quot;%2d&quot;, maalit);
</pre>
		<h4>
			Pistep&ouml;rssin tulostus</h4>
		<p>Lis&auml;&auml; luokalle Pelaaja rajapinta <code>Comparable&lt;Pelaaja&gt;</code>, jonka avulla pelaajat voidaan j&auml;rjest&auml;&auml; kokonaispistem&auml;&auml;r&auml;n mukaiseen <em>laskevaan</em> j&auml;rjestykseen. J&auml;rjest&auml; pelaajat Collections-luokan avulla ja tulosta pistep&ouml;rssi:</p>
		<pre class="sh_java">
        Collections.sort(pelaajat);

        System.out.println(&quot;NHL pistep&ouml;rssi:\n&quot;);
        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
</pre>
		<p>Tulostuu:</p>
		<pre>
NHL pistep&ouml;rssi:

Alex Ovechkin             WSH           71  28 + 46 = 74
Phil Kessel               TOR           70  28 + 24 = 52
Dustin Byfuglien          ATL           69  19 + 31 = 50
</pre>
		<p>Ohjeita t&auml;h&auml;n teht&auml;v&auml;&auml;n materiaalissa.</p>
		<h4>
			Kaikkien pelaajien tiedot</h4>
		<p>Tilastomme on viel&auml; hieman vajavainen, siin&auml; on vaan muutaman pelaajan tiedot (ja nekin vastaavat 16.3. tilannetta). Kaikkien tietojen sy&ouml;tt&auml;minen k&auml;sin olisi kovin vaivalloista. Onneksemme internetist&auml; osoitteesta <code>http://nhlstatistics.herokuapp.com/players.txt</code>l&ouml;ytyy p&auml;ivittyv&auml;, koneen luettavaksi tarkoitettu lista pelaajatiedoista.</p>
		<p><b>Huom:</b> kun menet osoitteeseen ensimm&auml;ist&auml; kertaa, sivun latautuminen kest&auml;&auml; muutaman sekunnin (sivu py&ouml;rii virtuaalipalvelimella joka sammutetaan jos sivua ei ole hetkeen k&auml;ytetty). Sen j&auml;lkeen sivu toimii nopeasti.</p>
		<p>Datan lukeminen internetist&auml; on helppoa. Projektissasi on valmiina luokka <code>Tilasto</code>, joka lataa annetun verkkosivun.</p>
		<pre class="sh_java">
import java.io.InputStream;
import java.net.URL;
import java.util.Scanner;

public class Tilasto {
    private static final String OSOITE =
            &quot;http://nhlstatistics.herokuapp.com/players.txt&quot;;

    private Scanner lukija;

    public Tilasto() {
        this(OSOITE);
    }

    public Tilasto(String osoite) {
        try {
            URL url = new URL(osoite);
            lukija = new Scanner(url.openStream());
        } catch (Exception ex) {
        }
    }

    public Tilasto(InputStream in) {
        try {
            lukija = new Scanner(in);
        } catch (Exception ex) {
        }
    }

    public boolean onkoRivejaJaljella() {
        return lukija.hasNextLine();
    }

    public String annaSeuraavaRivi() {
        String rivi = lukija.nextLine();
        return rivi.trim();
    }
}
</pre>
		<p><code>Tilasto</code>-luokka lukee pelaajien tilastotiedot internetist&auml;. Metodilla <code>annaSeuraavaRivi()</code>saadaan selville yhden pelaajan tiedot. Tietoja on tarkoitus lukea niin kauan kuin pelaajia riitt&auml;&auml;, t&auml;m&auml; voidaan tarkastaa metodilla <code>onkoRivejaJaljella()</code></p>
		<p>Kokeile ett&auml; ohjelmasi onnistuu tulostamaan <code>Tilasto</code>-luokan hakemat tiedot:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Tilasto tilasto = new Tilasto();

        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            System.out.println(pelaajaRivina);
        }
    }
</pre>
		<p>Tulostus on seuraavan muodoinen:</p>
		<pre>
Evgeni Malkin;PIT;62;39;46;54 


Steven Stamkos;TBL;70;50;34;64 


Claude Giroux;PHI;66;26;56;27 


Jason Spezza;OTT;72;29;46;30 

// ... ja yli 800:n muun pelaajan tiedot
</pre>
		<p><b>Huom:</b> tulostuksen alussa ja lopussa ja jokaisen pelaajan v&auml;liss&auml; on html-t&auml;gej&auml;, esim. &lt;br/&gt; joka aiheuttaa www-sivulle rivin vaihtumisen.</p>
		<p>Tulostuksessa pelaajan tiedot on erotettu toisistaan puolipisteell&auml;. Ensin nimi, sitten joukkue, ottelut, maalit, sy&ouml;t&ouml;t ja laukaukset.</p>
		<p>Pelaajaa vastaava merkkijono on siis yksitt&auml;inen merkkijono. Saat pilkottua sen osiin <code>split</code>-komennolla seuraavasti:</p>
		<pre class="sh_java">
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(&quot;;&quot;);
            for (int j = 0; j &lt; pelaajaOsina.length; j++) {
                System.out.print(pelaajaOsina[j] + &quot; &quot;);
            }
            System.out.println(&quot;&quot;);
        }
</pre>
		<p>Kokeile ett&auml; t&auml;m&auml; toimii. Saat t&auml;st&auml; teht&auml;v&auml;st&auml; pisteet seuraavan teht&auml;v&auml;n yhteydess&auml;.</p>
		<h4>
			Kaikkien pelaajien pistep&ouml;rssi</h4>
		<p>Tee kaikista <code>Tilasto</code>-luokan hakemien pelaajien tiedoista Pelaaja-olioita ja lis&auml;&auml; ne ArrayListiin. Lis&auml;&auml; teht&auml;v&auml;&auml;n luokka <code>PelaajatTilastosta</code>. K&auml;yt&auml; allaolevaa koodia luokan runkona.</p>
		<pre class="sh_java">
import java.util.ArrayList;

public class PelaajatTilastosta {
    public ArrayList&lt;Pelaaja&gt; haePelaajat(Tilasto tilasto) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(&quot;;&quot;);

            // Lis&auml;t&auml;&auml;n uusi pelaaja vain, jos sy&ouml;tteess&auml; on kentti&auml; riitt&auml;v&auml;sti
            if (pelaajaOsina.length &gt; 4) {
                int ottelut = Integer.parseInt(pelaajaOsina[2].trim());
                // T&auml;ydenn&auml; koodia lukemalla kaikki pelaajaOsina-taulukon kent&auml;t uuteen Pelaaja-olioon
                // ...
                // pelaajat.add(new Pelaaja( ... ));
            }
        }

        return pelaajat;
    }
}
</pre>
		<p>Teht&auml;v&auml;n&auml;si on t&auml;ydent&auml;&auml; runkoa siten, ett&auml; jokaisesta luetusta rivist&auml; luodaan pelaaja, joka lis&auml;t&auml;&auml;n pelaajat-listaan. Huom! <code>Tilasto</code>-luokka palauttaa merkkijonoja, joten joudut muuntamaan merkkijonoja my&ouml;s numeroiksi. Esimerkiksi numeromuotoinen <code>ottelut</code>on muutettava <code>int</code>:iksi <code>Integer.parseInt</code>-metodilla.</p>
		<p>Jos merkkijonon metodi <code>split</code>ei ole tuttu, se jakaa merkkijonon useampaan osaan annetun merkin kohdalta. Esimerkiksi komento <code>merkkijono.split(";");</code>palauttaa merkkijonosta taulukon, jossa alkuper&auml;isen merkkijonon puolipisteell&auml; erotetut osat ovat kukin omassa taulukon indeksiss&auml;.</p>
		<p>Voit k&auml;ytt&auml;&auml; testauksen apuna seuraavaa p&auml;&auml;ohjelmaa:</p>
		<pre class="sh_java">
        Tilasto tilasto = new Tilasto();

        PelaajatTilastosta pelaajienHakija = new PelaajatTilastosta();
        ArrayList&lt;Pelaaja&gt; pelaajat = pelaajienHakija.haePelaajat(tilasto);

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println( pelaaja );
        }
</pre>
		<h4>
			Maali ja sy&ouml;tt&ouml;p&ouml;rssi</h4>
		<p>Haluamme tulostaa my&ouml;s maalintekij&auml;p&ouml;rssin eli pelaajien tiedot maalim&auml;&auml;r&auml;n mukaan j&auml;rjestettyn&auml; sek&auml; sy&ouml;tt&ouml;p&ouml;rssin. <a href="http://www.nhl.com/ice/app?component=completePointLeadersList&amp;page=statshome&amp;service=direct">NHL:n</a> kotisivu tarjoaa t&auml;m&auml;nkaltaisen toiminnallisuuden, eli selaimessa n&auml;ytett&auml;v&auml; lista on mahdollista saada j&auml;rjestetty&auml; halutun kriteerin mukaan.</p>
		<p>Edellinen teht&auml;v&auml; m&auml;&auml;ritteli pelaajien suuruusj&auml;rjestyksen perustuvan kokonaispistem&auml;&auml;r&auml;&auml;n. Luokalla voi olla vain yksi <code>compareTo</code>-metodi, joten joudumme muunlaisia j&auml;rjestyksi&auml; saadaksemme turvautumaan muihin keinoihin.</p>
		<p>Vaihtoehtoiset j&auml;rjest&auml;mistavat toteutetaan erillisten luokkien avulla. Pelaajien vaihtoehtoisten j&auml;rjestyksen m&auml;&auml;r&auml;&auml;v&auml;n luokkien tulee toteuttaa <code>Comparator&lt;Pelaaja&gt;</code>-rajapinta. J&auml;rjestyksen m&auml;&auml;r&auml;&auml;v&auml;n luokan olio vertailee kahta parametrina saamaansa pelaajaa. Metodeja on ainoastaan yksi <code>compare(Pelaaja p1, Pelaaja p2)</code>, jonka tulee palauttaa negatiivinen arvo, jos pelaaja <code>p1</code>on j&auml;rjestyksess&auml; ennen pelaajaa <code>p2</code>, positiivinen arvo jos <code>p2</code>on j&auml;rjestyksess&auml; ennen <code>p1</code>:st&auml; ja 0 muuten.</p>
		<p>Periaatteena on luoda jokaista j&auml;rjest&auml;mistapaa varten oma vertailuluokka, esim. maalip&ouml;rssin j&auml;rjestyksen m&auml;&auml;rittelev&auml; luokka:</p>
		<pre class="sh_java">
import java.util.Comparator;

public class Maali implements Comparator&lt;Pelaaja&gt; {
    public int compare(Pelaaja p1, Pelaaja p2) {
        // maalien perusteella tapahtuvan vertailun koodi t&auml;nne
    }
}
</pre>
		<p>Tee <code>Comparator</code>-rajapinnan toteuttavat luokat <code>Maali</code>ja <code>Syotto</code>, ja niille vastaavat maali- ja sy&ouml;tt&ouml;p&ouml;rssien generoimiseen sopivat sopivat vertailufunktiot.</p>
		<p>J&auml;rjest&auml;minen tapahtuu edelleen luokan <code>Collections</code>metodin <code>sort</code>avulla. Metodi saa nyt toiseksi parametrikseen j&auml;rjestyksen m&auml;&auml;r&auml;&auml;v&auml;n luokan olion:</p>
		<pre class="sh_java">
Maali maalintekijat = new Maali();
Collections.sort(pelaajat, maalintekijat);
System.out.println(&quot;NHL parhaat maalintekij&auml;t\n&quot;);

// tulostetaan maalip&ouml;rssi
</pre>
		<p>J&auml;rjestyksen m&auml;&auml;rittelev&auml; olio voidaan my&ouml;s luoda suoraan sort-kutsun yhteydess&auml;:</p>
		<pre class="sh_java">
Collections.sort(pelaajat, new Maali());
System.out.println(&quot;NHL parhaat maalintekij&auml;t\n&quot;);

// tulostetaan maalip&ouml;rssi
</pre>
		<p>Kun sort-metodi saa j&auml;rjestyksen m&auml;&auml;rittelev&auml;n olion parametrina, se k&auml;ytt&auml;&auml; olion <code>compareTo()</code>-metodia pelaajia j&auml;rjest&auml;ess&auml;&auml;n.</p>
		<p>Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/notes-java/data/collections/comparators.html">t&auml;&auml;ll&auml;</a></p>
		<h3>
			M&auml;kihyppy</h3>
		<p>Harjoitellaan taas ohjelman rakenteen omatoimista suunnittelua. K&auml;ytt&ouml;liittym&auml;n ulkomuoto ja vaadittu toiminnallisuus on m&auml;&auml;ritelty ennalta -- rakenteen saat toteuttaa vapaasti.</p>
		<p>M&auml;kihyppy on suomalaisille eritt&auml;in rakas laji, jossa pyrit&auml;&auml;n hypp&auml;&auml;m&auml;&auml;n hyppyrim&auml;est&auml; mahdollisimman pitk&auml;lle mahdollisimman tyylikk&auml;&auml;sti. T&auml;ss&auml; teht&auml;v&auml;ss&auml; tulee toteuttaa simulaattori m&auml;kihyppykilpailulle.</p>
		<p>Simulaattori kysyy ensin k&auml;ytt&auml;j&auml;lt&auml; hypp&auml;&auml;jien nimi&auml;. Kun k&auml;ytt&auml;j&auml; antaa tyhj&auml;n merkkijonon (eli painaa enteri&auml;) hypp&auml;&auml;j&auml;n nimeksi siirryt&auml;&auml;n hyppyvaiheeseen. Hyppyvaiheessa hypp&auml;&auml;j&auml;t hypp&auml;&auml;v&auml;t yksitellen k&auml;&auml;nteisess&auml; pistej&auml;rjestyksess&auml;. Hypp&auml;&auml;j&auml; jolla on v&auml;hiten pisteit&auml; ker&auml;ttyn&auml; hypp&auml;&auml; aina kierroksen ensimm&auml;isen&auml;, toiseksi v&auml;hiten pisteit&auml; omaava toisena jne, ..., eniten pisteit&auml; ker&auml;nnyt viimeisen&auml;.</p>
		<p>Hypp&auml;&auml;j&auml;n yhteispisteet lasketaan yksitt&auml;isten hyppyjen pisteiden summana. Yksitt&auml;isen hypyn pisteytys lasketaan hypyn pituudesta (k&auml;yt&auml; satunnaista kokonaisluku v&auml;lilt&auml; 60-120) ja tuomari&auml;&auml;nist&auml;. Jokaista hyppy&auml; kohden annetaan 5 tuomari&auml;&auml;nt&auml; (satunnainen luku v&auml;lilt&auml; 10-20). Tuomari&auml;&auml;ni&auml; laskettaessa otetaan huomioon vain kolme keskimm&auml;ist&auml; &auml;&auml;nt&auml;: pienint&auml; ja suurinta &auml;&auml;nt&auml; ei oteta huomioon. Esimerkiksi jos Mikael hypp&auml;&auml; 61 metri&auml; ja saa tuomari&auml;&auml;net 11, 12, 13, 14 ja 15, on h&auml;nen hyppyns&auml; yhteispisteet 100.</p>
		<p>Kierroksia hyp&auml;t&auml;&auml;n niin monta kuin ohjelman k&auml;ytt&auml;j&auml; haluaa. Kun k&auml;ytt&auml;j&auml; haluaa lopettaa tulostetaan lopuksi kilpailun lopputulokset. Lopputuloksissa tulostetaan hypp&auml;&auml;j&auml;t, hypp&auml;&auml;jien yhteispisteet ja hypp&auml;&auml;jien hypp&auml;&auml;mien hyppyjen pituudet. Lopputulokset on j&auml;rjestetty hypp&auml;&auml;jien yhteispisteiden mukaan siten, ett&auml; eniten pisteit&auml; ker&auml;nnyt on ensimm&auml;inen.</p>
		<p>Teht&auml;v&auml;n tekemisess&auml; on hy&ouml;ty&auml; <em>muun muassa</em> metodeista <code>Collections.sort</code>ja <code>Collections.reverse</code>. Kannattaa aluksi hahmotella mink&auml;laisia luokkia ja olioita ohjelmassa voisi olla. On my&ouml;s hyv&auml; pyrki&auml; tilanteeseen, jossa k&auml;ytt&ouml;liittym&auml;luokka on ainut luokka joka kutsuu tulostuskomentoa.</p>
		<pre>
Kumpulan m&auml;kiviikot

Sy&ouml;t&auml; kilpailun osallistujat yksi kerrallaan, tyhj&auml;ll&auml; merkkijonolla siirtyy hyppyvaiheeseen.
  Osallistujan nimi: Mikael
  Osallistujan nimi: Mika
  Osallistujan nimi:

Kilpailu alkaa!

Kirjoita &quot;hyppaa&quot; niin hyp&auml;t&auml;&auml;n, muuten lopetetaan: hyppaa

1. kierros

Hyppyj&auml;rjestys:
  1. Mikael (0 pistett&auml;)
  2. Mika (0 pistett&auml;)

Kierroksen 1 tulokset
  Mikael
    pituus: 95
    tuomaripisteet: [15, 11, 10, 14, 14]
  Mika
    pituus: 112
    tuomaripisteet: [14, 12, 18, 18, 17]

Kirjoita &quot;hyppaa&quot; niin hyp&auml;t&auml;&auml;n, muuten lopetetaan: hyppaa

2. kierros

Hyppyj&auml;rjestys:
  1. Mikael (134 pistett&auml;)
  2. Mika (161 pistett&auml;)

Kierroksen 2 tulokset
  Mikael
    pituus: 96
    tuomaripisteet: [20, 19, 15, 13, 18]
  Mika
    pituus: 61
    tuomaripisteet: [12, 11, 15, 17, 11]

Kirjoita &quot;hyppaa&quot; niin hyp&auml;t&auml;&auml;n, muuten lopetetaan: hyppaa

3. kierros

Hyppyj&auml;rjestys:
  1. Mika (260 pistett&auml;)
  2. Mikael (282 pistett&auml;)

Kierroksen 3 tulokset
  Mika
    pituus: 88
    tuomaripisteet: [11, 19, 13, 10, 15]
  Mikael
    pituus: 63
    tuomaripisteet: [12, 19, 19, 12, 12]

Kirjoita &quot;hyppaa&quot; niin hyp&auml;t&auml;&auml;n, muuten lopetetaan: lopeta

Kiitos!

Kilpailun lopputulokset:
Sija    Nimi
1       Mikael (388 pistett&auml;)
          hyppyjen pituudet: 95 m, 96 m, 63 m
2       Mika (387 pistett&auml;)
          hyppyjen pituudet: 112 m, 61 m, 88 m
</pre>
		<p><strong>Huom!</strong> Testien kannalta on oleellista ett&auml; <em>k&auml;ytt&ouml;liittym&auml;</em> toimii kuten yll&auml; kuvattu. <em>Teht&auml;v&auml; on nelj&auml;n yksitt&auml;isen teht&auml;v&auml;pisteen arvoinen.</em></p>
		<p><strong>Ohjelman tulee k&auml;ynnisty&auml; kun teht&auml;v&auml;pohjassa oleva main-metodi suoritetaan, teht&auml;v&auml;ss&auml; saa luoda vain yhden Scanner-olion.</strong></p>
	</div>
	<p>Screencast jossa tehd&auml;&auml;n viikon 1 ja 2 ydinasioita hy&ouml;dynt&auml;v&auml; hieman isompi sovellus:</p>
	<p><iframe allowfullscreen="" frameborder="0" height="450" src="http://www.youtube.com/embed/LFxtwce8chM" width="700"></iframe></p>
</div>
<!--
<hr />Viikko 2 loppuu<hr />
--><!--

VK3:

- Pakkaus
- Interface jatkuu, monta rajapintaa
  - Comparator
- Tiedosto + poikkeus
  - Lukeminen
  - Kirjoittaminen
- Set
  - HashSet
  - TreeSet

-->
<div class="week" data-week-number="9">
	<h2>
		Single responsibility principle</h2>
	<p>Isompia ohjelmia suunniteltaessa pohditaan usein mille luokalle mink&auml;kin asian toteuttaminen kuuluu. Jos kaikki ohjelmaan kuuluva toiminnallisuus asetetaan samaan luokkaan, on tuloksena v&auml;ist&auml;m&auml;tt&auml; kaaos. Ohjelmistojen suunnittelun osa-alue <em>oliosuunnittelu</em> sis&auml;lt&auml;&auml; periaatteen <em>Single responsibility principle</em>, jota meid&auml;n kannattaa seurata.</p>
	<p>Single responsibility principle sanoo ett&auml; jokaisella luokalla tulee olla vain yksi vastuu ja selke&auml; teht&auml;v&auml;. Jos luokalla on yksi selke&auml; teht&auml;v&auml;, on teht&auml;v&auml;ss&auml; tapahtuvien muutosten toteuttaminen helppoa -- muutos tulee tehd&auml; vain yhteen luokkaan. <em>Jokaisella luokalla tulisi olla vain yksi syy muuttua</em>.</p>
	<p>Tutkitaan seuraavaa luokkaa <code>Tyontekija</code>, jolla on metodit palkan laskemiseen ja tuntien raportointiin.</p>
	<pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // ty&ouml;ntekij&auml;&auml;n liittyv&auml;t konstruktorit ja metodit

    public double laskePalkka() {
        // palkan laskemiseen liittyv&auml; logiikka
    }

    public String raportoiTunnit() {
        // ty&ouml;tuntien raportointiin liittyv&auml; logiikka
    }
}
</pre>
	<p>Vaikka yll&auml; olevasta esimerkist&auml; puuttuu konkreettiset toteutukset, tulisi h&auml;lytyskellojen soida. Luokalla <code>Tyontekija</code>on ainakin kolme eri vastuualuetta. Se kuvaa sovelluksessa ty&ouml;ntekij&auml;&auml;, se toteuttaa palkanlaskennan teht&auml;v&auml;&auml; palkan laskemisesta, ja tuntiraportointij&auml;rjestelm&auml;n teht&auml;v&auml;&auml; ty&ouml;tuntien raportoinnista. Yll&auml; oleva luokka pilkkoa kolmeen osaan: yksi osa kuvaa ty&ouml;ntekij&auml;&auml;, toinen osa palkanlaskentaa ja kolmas osa tuntikirjanpitoa.</p>
	<pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // ty&ouml;ntekij&auml;&auml;n liittyv&auml;t konstruktorit ja metodit
}
</pre>
	<pre class="sh_java">
public class Palkanlaskenta {
    // oliomuuttujat

    // palkanlaskentaan liittyv&auml;t metodit

    public double laskePalkka(Henkilo henkilo) {
        // palkan laskemiseen liittyv&auml; logiikka
    }
}
</pre>
	<pre class="sh_java">
public class Tuntikirjanpito {
    // oliomuuttujat

    // tuntikirjanpitoon liittyv&auml;t metodit

    public String luoTuntiraportti(Henkilo henkilo) {
        // ty&ouml;tuntien raportointiin liittyv&auml; logiikka
    }
}
</pre>
	<p><em>Jokainen muuttuja, jokainen koodirivi, jokainen metodi, jokainen luokka, ja jokainen ohjelma pit&auml;isi olla vain yht&auml; tarkoitusta varten. Usein ohjelman &quot;parempi&quot; rakenne on ohjelmoijalle selke&auml;&auml; vasta kun ohjelma on toteutettu jo kertaalleen. T&auml;m&auml; on t&auml;ysin hyv&auml;ksytt&auml;v&auml;&auml;: viel&auml; t&auml;rke&auml;mp&auml;&auml; on se, ett&auml; ohjelmaa pyrit&auml;&auml;n muuttamaan aina selke&auml;mp&auml;&auml;n suuntaan. <strong>Refaktoroi eli muokkaa ohjelmaasi aina tarpeen tullen!</strong></em></p>
	<h2>
		Luokkien organisointi pakkauksiin</h2>
	<p>Suurempia ohjelmia suunniteltaessa ja toteutettaessa luokkam&auml;&auml;r&auml; kasvaa helposti suureksi. Luokkien m&auml;&auml;r&auml;n kasvaessa niiden tarjoamien toiminnallisuuksien ja metodien muistaminen vaikeutuu. J&auml;rkev&auml; luokkien niment&auml; helpottaa toiminnallisuuksien muistamista. J&auml;rkev&auml;n nimenn&auml;n lis&auml;ksi l&auml;hdekooditiedostot kannattaa jakaa toiminnallisuutta, k&auml;ytt&ouml;tarkoitusta ja/tai tahoa kuvaaviin pakkauksiin. Pakkaukset (<em>package</em>) ovat k&auml;yt&auml;nn&ouml;ss&auml; hakemistoja, joihin l&auml;hdekooditiedostot organisoidaan. Windowsissa ja puhekieless&auml; hakemistoja (engl. directory) kutsutaan usein kansioiksi. Me k&auml;yt&auml;mme kuitenkin termi&auml; hakemisto.</p>
	<p>Ohjelmointiymp&auml;rist&ouml;t tarjoavat valmiit ty&ouml;kalut pakkausten hallintaan. Olemme t&auml;h&auml;n menness&auml; luoneet luokkia ja rajapintoja vain projektiin liittyv&auml;n l&auml;hdekoodipakkaukset-osion (<code>Source Packages</code>) oletuspakkaukseen (<code>default package</code>). Uuden pakkauksen voi luoda NetBeansissa projektin pakkauksiin liittyv&auml;ss&auml; <code>Source Packages</code>-osiossa oikeaa hiirennappia painamalla ja valitsemalla <code>New -&gt; Java Package...</code>. Luodun pakkauksen sis&auml;lle voidaan luoda luokkia aivan kuten oletuspakkaukseenkin (<code>default package</code>).</p>
	<p>Pakkaus, jossa luokka sijaitsee, n&auml;kyy l&auml;hdekooditiedoston alussa ennen muita komentoja olevasta lauseesta <code>package <em>pakkaus</em></code>. Esimerkiksi alla oleva luokka <code>Sovellus</code>sijaitsee pakkauksessa <code>kirjasto</code>.</p>
	<pre class="sh_java">
package kirjasto;

public class Sovellus {

    public static void main(String[] args) {
        System.out.println(&quot;Hello packageworld!&quot;);
    }
}
</pre>
	<p>Pakkaukset voivat sis&auml;lt&auml;&auml; pakkauksia. Esimerkiksi pakkausm&auml;&auml;rittelyss&auml; <code>package kirjasto.domain</code>pakkaus <code>domain</code>on pakkauksen <code>kirjasto</code>sis&auml;ll&auml;. Asettamalla pakkauksia pakkausten sis&auml;&auml;n rakennetaan sovelluksen luokille ja rajapinnoille hierarkiaa. Esimerkiksi kaikki Javan luokat sijaitsevat pakkauksen <code>java</code>alla olevissa pakkauksissa. Pakkausnime&auml; <code>domain</code>k&auml;ytet&auml;&auml;n usein kuvaamaan sovellusalueen k&auml;sitteisiin liittyvien luokkien s&auml;ilytyspaikkaa. Esimerkiksi luokka <code>Kirja</code>voisi hyvin olla pakkauksen <code>kirjasto.domain</code>sis&auml;ll&auml; sill&auml; se kuvaa kirjastosovellukseen liittyv&auml;&auml; k&auml;sitett&auml;.</p>
	<pre class="sh_java">
package kirjasto.domain;

public class Kirja {
    private String nimi;

    public Kirja(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }
}
</pre>
	<p>Pakkauksissa olevia luokkia tuodaan luokan k&auml;ytt&ouml;&ouml;n <code>import</code>-lauseen avulla. Esimerkiksi <code>kirjasto</code>-pakkauksessa oleva luokka <code>Sovellus</code>saisi k&auml;ytt&ouml;&ouml;ns&auml; pakkauksessa <code>kirjasto.domain</code>olevan luokan m&auml;&auml;rittelyll&auml; <code>import kirjasto.domain.Kirja</code>.</p>
	<pre class="sh_java">
package kirjasto;

import kirjasto.domain.Kirja;

public class Sovellus {

    public static void main(String[] args) {
        Kirja kirja = new Kirja(&quot;pakkausten ABC!&quot;);
        System.out.println(&quot;Hello packageworld: &quot; + kirja.getNimi());
    }
}
</pre>
	<pre>
Hello packageworld: pakkausten ABC!
</pre>
	<p>Import-lauseet asetetaan l&auml;hdekooditiedostossa pakkausm&auml;&auml;rittelyn j&auml;lkeen mutta ennen luokkam&auml;&auml;rittely&auml;. Niit&auml; voi olla my&ouml;s useita -- esimerkiksi kun haluamme k&auml;ytt&auml;&auml; useita luokkia. Javan valmiit luokat sijaitsevat yleens&auml; ottaen pakkauksen <code>java</code>alipakkauksissa. Luokkiemme alussa usein esiintyv&auml;t lauseet <code>import java.util.ArrayList</code>ja <code>import java.util.Scanner;</code>alkavat nyt toivottavasti vaikuttaa merkityksellisimmilt&auml;.</p>
	<p>Jatkossa <em>kaikissa</em> teht&auml;viss&auml;mme k&auml;ytet&auml;&auml;n pakkauksia. Luodaan seuraavaksi ensimm&auml;iset pakkaukset itse.</p>
	<div class="tehtavat">
		<h3>
			Ensimm&auml;isi&auml; pakkauksia</h3>
		<h4>
			K&auml;ytt&ouml;liittym&auml;</h4>
		<p>Luo projektipohjaan pakkaus <code>fi.mooc.observer</code>. Rakennetaan t&auml;m&auml;n pakkauksen sis&auml;lle sovelluksen toiminta. Lis&auml;&auml; sovellukseen pakkaus <code>ui</code>(t&auml;m&auml;n j&auml;lkeen pit&auml;isi olla k&auml;yt&ouml;ss&auml; pakkaus <code>fi.mooc.observer.ui</code>), ja lis&auml;&auml; sinne rajapinta <code>Kayttoliittyma</code>.</p>
		<p>Rajapinnan <code>Kayttoliittyma</code>tulee m&auml;&auml;ritell&auml; metodi <code>void paivita()</code>. Luo samaan pakkaukseen luokka <code>Tekstikayttoliittyma</code>, joka toteuttaa rajapinnan <code>Kayttoliittyma</code>. Toteuta luokassa <code>Tekstikayttoliittyma</code>rajapinnan <code>Kayttoliittyma</code>vaatima metodi <code>public void paivita()</code>siten, ett&auml; sen ainut teht&auml;v&auml; on merkkijonon &quot;<code>Päivitetään käyttöliittymää</code>&quot;-tulostaminen <code>System.out.println</code>-metodikutsulla.</p>
		<h4>
			Sovelluslogiikka</h4>
		<p>Luo t&auml;m&auml;n j&auml;lkeen pakkaus <code>fi.mooc.observer.logiikka</code>, ja lis&auml;&auml; sinne luokka <code>Sovelluslogiikka</code>. Sovelluslogiikan APIn tulee olla seuraavanlainen.</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>public Sovelluslogiikka(Kayttoliittyma kayttoliittyma)</code></li>
			<li>
				Sovelluslogiikka-luokan konstruktori. Saa parametrina Kayttoliittyma-rajapinnan toteuttavan luokan.</li>
			<br />
			<li>
				<code>public void suorita(int montaKertaa)</code></li>
			<li>
				Tulostaa <code>montaKertaa</code>-muuttujan m&auml;&auml;rittelem&auml;n m&auml;&auml;r&auml;n merkkijonoa &quot;Sovelluslogiikka toimii&quot;. Jokaisen &quot;Sovelluslogiikka toimii&quot; -tulostuksen j&auml;lkeen tulee kutsua konstruktorin parametrina saadun rajapinnan <code>Kayttoliittyma</code>-toteuttaman olion m&auml;&auml;rittelem&auml;&auml; <code>paivita()</code>-metodia.</li>
			<br />
		</ul>
		<p>&nbsp;</p>
		<p>Voit testata sovelluksen toimintaa seuraavalla p&auml;&auml;ohjelmaluokalla.</p>
		<pre class="sh_java">
import fi.mooc.observer.logiikka.Sovelluslogiikka;
import fi.mooc.observer.ui.Kayttoliittyma;
import fi.mooc.observer.ui.Tekstikayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Tekstikayttoliittyma();
        new Sovelluslogiikka(kayttoliittyma).suorita(3);
    }
}
</pre>
		<p>Ohjelman tulostuksen tulee olla seuraava:</p>
		<pre>
Sovelluslogiikka toimii
P&auml;ivitet&auml;&auml;n k&auml;ytt&ouml;liittym&auml;&auml;
Sovelluslogiikka toimii
P&auml;ivitet&auml;&auml;n k&auml;ytt&ouml;liittym&auml;&auml;
Sovelluslogiikka toimii
P&auml;ivitet&auml;&auml;n k&auml;ytt&ouml;liittym&auml;&auml;
</pre>
	</div>
	<h3>
		Konkreettinen hakemistorakenne</h3>
	<p>Kaikki NetBeansissa n&auml;kyv&auml;t projektit ovat tietokoneesi <em><a href="http://fi.wikipedia.org/wiki/Tiedostoj%C3%A4rjestelm%C3%A4" target="_blank">tiedostoj&auml;rjestelm&auml;ss&auml;</a></em>. Jokaiselle projektille on olemassa oma hakemisto (eli kansio), jonka sis&auml;ll&auml; on projektiin liittyv&auml;t tiedostot ja hakemistot.</p>
	<p>Projektin hakemistossa <code>src</code>on ohjelmaan liittyv&auml;t l&auml;hdekoodit. Jos luokan pakkauksena on kirjasto, sijaitsee se projektin l&auml;hdekoodihakemistoon <code>src</code>sis&auml;ll&auml; olevassa hakemistossa <code>kirjasto</code>. Jos olet kiinnostunut, NetBeansissa voi k&auml;yd&auml; katsomassa projektien konkreettista rakennetta <em>Files</em>-v&auml;lilehdelt&auml; joka on normaalisti <em>Projects</em>-v&auml;lilehden vieress&auml;. Jos et n&auml;e v&auml;lilehte&auml; <em>Files</em>, saa sen n&auml;kyville valitsemalla vaihtoehdon <em>Files</em> valikosta <em>Window</em>.</p>
	<p>Sovelluskehityst&auml; tehd&auml;&auml;n normaalisti <em>Projects</em>-v&auml;lilehdelt&auml;, jossa NetBeans on piilottanut projektiin liittyvi&auml; tiedostoja joista ohjelmoijan ei tarvitse v&auml;litt&auml;&auml;.</p>
	<h3>
		N&auml;kyvyysm&auml;&auml;reet ja pakkaukset</h3>
	<p>Olemme aiemmin tutustuneet kahteen n&auml;kyvyysm&auml;&auml;reeseen. N&auml;kyvyysm&auml;&auml;reell&auml; <code>private</code>varustetut metodit ja muuttujat ovat n&auml;kyviss&auml; vain sen luokan sis&auml;ll&auml; joka m&auml;&auml;rittelee ne. Niit&auml; ei voi k&auml;ytt&auml;&auml; luokan ulkopuolelta. N&auml;kyvyysm&auml;&auml;reell&auml; <code>public</code>varustetut metodit ja muuttujat ovat taas kaikkien k&auml;ytett&auml;viss&auml;.</p>
	<pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    private void tulostaOtsikko() {
        System.out.println(&quot;************&quot;);
        System.out.println(&quot;* KIRJASTO *&quot;);
        System.out.println(&quot;************&quot;);
    }
}
</pre>
	<p>Yll&auml; olevasta <code>Kayttoliittyma</code>-luokasta tehdyn olion konstruktori ja <code>kaynnista</code>-metodi on kutsuttavissa mist&auml; tahansa ohjelmasta. Metodi <code>tulostaOtsikko</code>ja <code>lukija</code>-muuttuja on k&auml;yt&ouml;ss&auml; vain luokan sis&auml;ll&auml;.</p>
	<p>Pakkausn&auml;kyvyytt&auml; k&auml;ytett&auml;ess&auml; muuttujille tai metodeille ei aseteta mit&auml;&auml;n n&auml;kyvyyteen liittyv&auml;&auml; etuliitett&auml;. Muutetaan yll&auml; olevaa esimerkki&auml; siten, ett&auml; metodilla <code>tulostaOtsikko</code>on pakkausn&auml;kyvyys.</p>
	<pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    void tulostaOtsikko() {
        System.out.println(&quot;************&quot;);
        System.out.println(&quot;* KIRJASTO *&quot;);
        System.out.println(&quot;************&quot;);
    }
}
</pre>
	<p>Nyt <em>saman pakkauksen sis&auml;ll&auml;</em> olevat luokat voivat k&auml;ytt&auml;&auml; metodia <code>tulostaOtsikko</code>.</p>
	<pre class="sh_java">
package kirjasto.ui;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // onnistuu!
    }
}
</pre>
	<p>Jos luokka on eri pakkauksessa, ei metodia <code>tulostaOtsikko</code>pysty k&auml;ytt&auml;m&auml;&auml;n.</p>
	<pre class="sh_java">
package kirjasto;

import java.util.Scanner;
import kirjasto.ui.Kayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // ei onnistu!
    }
}
</pre>
	<h2>
		Monta rajapintaa</h2>
	<p>Rajapintaluokan alussa on sanat <code>public interface <em>RajapinnanNimi</em></code>, miss&auml; <em>RajapinnanNimi</em> on rajapintaluokan nimi. Rajapintaluokka sis&auml;lt&auml;&auml; yhden tai useamman metodin, jotka sen toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>, ja m&auml;&auml;rittelee ett&auml; <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>
	<pre class="sh_java">
package sovellus.domain;

public interface Tunnistettava {
    String getTunnus();
}
</pre>
	<p>Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Toteutetaan luokka <code>Henkilo</code>, joka toteuttaa rajapinnan tunnistettava. Henkilo-luokan metodi <code>getTunnus</code>palauttaa aina henkil&ouml;n henkil&ouml;tunnuksen.</p>
	<pre class="sh_java">
package sovellus.domain;

public class Henkilo implements Tunnistettava {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }
}
</pre>
	<p>Rajapintojen vahvuus on se, ett&auml; rajapinta on my&ouml;s <em>muuttujatyyppi</em>. Kaikki rajapinnan toteuttavista luokista tehdyt oliot ovat my&ouml;s rajapinnan tyyppisi&auml;. T&auml;m&auml; helpottaa sovellusten rakentamista huomattavasti.</p>
	<p>Tehd&auml;&auml;n luokka <code>Henkilorekisteri</code>, josta voimme hakea henkil&ouml;it&auml; <code>Tunnistettava</code>-rajapinnan avulla. Yksitt&auml;isten henkil&ouml;iden hakemisen lis&auml;ksi <code>Henkilorekisteri</code>tarjoaa metodin kaikkien henkil&ouml;iden hakemiseen listana.</p>
	<pre class="sh_java">
public class Henkilorekisteri {
    private HashMap&lt;String, Henkilo&gt; henkilot;

    public Henkilorekisteri(HashMap&lt;String, Henkilo&gt; henkilot) {
        this.henkilot = henkilot;
    }

    public void lisaaHenkilo(Henkilo henkilo) {
        this.henkilot.put(henkilo.getTunnus(), henkilo);
    }

    public void haeHenkiloTunnuksella(Tunnistettava tunnistettava) {
        this.henkilot.get(tunnistettava.getTunnus());
    }

    public List&lt;Henkilo&gt; getHenkilot() {
        return new ArrayList&lt;Henkilo&gt;(henkilot.values());
    }
}
</pre>
	<p>Ent&auml; jos haluaisimme j&auml;rjest&auml;&auml; henkil&ouml;listan aakkosj&auml;rjestykseen?</p>
	<p>Yksi ratkaisu on <em>Tilastot kuntoon</em> -teht&auml;v&auml;ss&auml; esitelty <code>Comparator</code>-rajapinnan k&auml;ytt&ouml;. Comparator-rajapinnan avulla tapahtuvan nimen vertailun voi toteuttaa esimerkiksi seuraavasti. Toteutetaan ensiksi <code>Comparator</code>-rajapinnan toteuttava luokka <code>NimiJarjestys</code>.</p>
	<pre class="sh_java">
import java.util.Comparator;

public class NimiJarjestys implements Comparator&lt;Henkilo&gt; {

    @Override
    public int compare(Henkilo h1, Henkilo h2) {
        return h1.getNimi().compareTo(h2.getNimi());
    }
}
</pre>
	<p>Luokan <code>NimiJarjestys</code>metodi <code>compare</code>vertaa kahden parametrina annetun henkil&ouml;n nimi&auml; toisiinsa. Luokan avulla voimme toteuttaa henkil&ouml;rekisterin metodia <code>getHenkilot</code>palauttaman listan j&auml;rjest&auml;misen seuraavasti.</p>
	<pre class="sh_java">
    public List&lt;Henkilo&gt; getHenkilot() {
        ArrayList&lt;Henkilo&gt; lista = new ArrayList&lt;Henkilo&gt;(this.henkilot.values());
        Collections.sort(lista, new NimiJarjestys());
        return lista;
    }
</pre>
	<p>Luomme ensin metodissa <code>henkilot</code>-listan, jonka annamme <code>Collections</code>-luokan <code>sort</code>-metodille. Metodi <code>sort</code>saa toisena parametrinaan <code>NimiJarjestys</code>-luokan ilmentym&auml;n, joka kertoo miten <code>henkilot</code>-listalla olevat oliot tulee j&auml;rjest&auml;&auml;.</p>
	<p>Comparator-rajapinnan toteuttamaa luokkaa ei kuitenkaan tarvitse toteuttaa t&auml;ss&auml; tapauksessa. Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Henkilo</code>-luokalla lis&auml;ksi <code>Comparable</code>-rajapinnan. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa tulee meid&auml;n toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Henkilo</code>rajapinta <code>Comparable</code>.</p>
	<pre class="sh_java">
package sovellus.domain;

public class Henkilo implements Tunnistettava, Comparable&lt;Henkilo&gt; {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }

    @Override
    public int compareTo(Henkilo toinen) {
        return this.nimi.compareTo(toinen.getNimi());
    }
}
</pre>
	<p>Nyt henkil&ouml;st&ouml;rekisterin listaa-metodi on seuraavanlainen ja p&auml;&auml;semme eroon turhasta <code>NimiJarjesta</code>-luokasta.</p>
	<pre class="sh_java">
    public List&lt;Henkilo&gt; getHenkilot() {
        ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;(henkilot.values());
        Collections.sort(henkilot);
        return henkilot;
    }
</pre>
	<h3>
		Kassaesimerkki</h3>
	<p>Pohditaan seuraavaksi kauppojen kassalaitteessa olevaan lukijalaitteeseen liittyv&auml;&auml; tuotteen tunnistamistoimintoa. Oletetaan ett&auml; tuotteet sis&auml;lt&auml;v&auml;t niihin liittyv&auml;n viivakoodin, nimen ja hinnan. Tuotteita kuvastava <code>Tuote</code>-olio toteuttaa aiemmin m&auml;&auml;ritellyn rajapinnan <code>Tunnistettava</code>.</p>
	<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava {
    private String viivakoodi;
    private String nimi;
    private int hinta;

    public Tuote(String viivakoodi, String nimi, int hinta) {
        this.viivakoodi = viivakoodi;
        this.nimi = nimi;
        this.hinta = hinta;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }
}
</pre>
	<p>Toteutetaan seuraavaksi <code>Lukijalaite</code>, joka osaa muuntaa tunnistettavat oliot tuotteiksi. Lukijalaitteen tulee lukea ja tunnistaa tuotteet rajapinnan <code>Tunnistettava</code>-avulla. Toteutetaan luokka <code>Lukijalaite</code>siten, ett&auml; se sis&auml;lt&auml;&auml; hajautustaulun, josta tuotteet l&ouml;ytyv&auml;t tunnisteen perusteella. Lukijalaite on osa sovelluksen logiikkaa, joten lis&auml;t&auml;&auml;n se pakkaukseen <code>sovellus.logiikka</code>.</p>
	<pre class="sh_java">
package sovellus.logiikka;

public class Lukijalaite {
    private HashMap&lt;String, Tuote&gt; tuotteet;

    public Lukijalaite(HashMap&lt;String, Tuote&gt; tuotteet) {
        this.tuotteet = tuotteet;
    }

    public Tuote tunnista(Tunnistettava tunnistettava) {
        return this.tuotteet.get(tunnistettava.getTunnus());
    }
}
</pre>
	<p>Lukijalaite-olio palauttaa <code>Tuote</code>-olion jos sen tunnus l&ouml;ytyy lukijalaitteen sis&auml;lt&auml;m&auml;st&auml; hajautustaulusta. Luodaan seuraavaksi kassa, joka k&auml;ytt&auml;&auml; lukijalaitetta tuotteiden lis&auml;&auml;miseen ostettujen tuotteiden listalle. Kassalla on metodi <code>public void osta</code>, jolle annetaan luokan <code>Tunnistettava</code>-ilmentym&auml; parametrina. Ostaminen lis&auml;&auml; lukijalaitteella tunnistetun tuotteen ostettujen listalle. Jos tuotetta ei tunnisteta, ei tehd&auml; mit&auml;&auml;n. Metodi <code>tulostaOstokset</code>tulostaa ostettujen tuotteiden nimet.</p>
	<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getNimi());
        }
    }
}
</pre>
	<p>Huomaamme t&auml;ss&auml; vaiheessa ett&auml; tuotteiden lukeminen listalta, joka on tulostettu tuotteiden lis&auml;ysj&auml;rjestyksess&auml;, on hyvin kuormittavaa asiakkaalle. Muokataan tulostusta siten, ett&auml; tuotteet listataan aakkosj&auml;rjestyksess&auml;. Lis&auml;t&auml;&auml;n <code>Tuote</code>-luokalle rajapinta <code>Comparable</code>, jonka avulla tuotteet voidaan j&auml;rjest&auml;&auml; aakkosj&auml;rjestyksess&auml;.</p>
	<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava, Comparable&lt;Tuote&gt; {
    private String viivakoodi;
    private String nimi;
    private int hinta;

    public Tuote(String viivakoodi, String nimi, int hinta) {
        this.viivakoodi = viivakoodi;
        this.nimi = nimi;
        this.hinta = hinta;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }

    @Override
    public int compareTo(Tuote tuote) {
        return this.nimi.compareTo(tuote.getNimi());
    }
}
</pre>
	<p>Muokataan viel&auml; kassaan liittyv&auml;&auml; toiminnallisuutta siten, ett&auml; tuotteet j&auml;rjestet&auml;&auml;n tarvittaessa. Huomaa ett&auml; tuotteita tarvitsee j&auml;rjest&auml;&auml; vain silloin kun tuotteita <em>ostetaan</em>. Ostaminen on ainut tilanne, jossa tuotteita sis&auml;lt&auml;v&auml;n listan j&auml;rjestys mahdollisesti muuttuu. T&auml;ll&ouml;in ostokset ovat aina j&auml;rjestyksess&auml; metodia <code>tulostaOstokset</code>kutsuttaessa.</p>
	<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
        Collections.sort(this.tuotteet);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getNimi());
        }
    }
}
</pre>
	<div class="tehtavat">
		<h3>
			Muuttaminen</h3>
		<p>Muuttokuormaa pakattaessa esineit&auml; lis&auml;t&auml;&auml;n muuttolaatikoihin siten, ett&auml; tarvittujen muuttolaatikoiden m&auml;&auml;r&auml; on mahdollisimman pieni. T&auml;ss&auml; teht&auml;v&auml;ss&auml; simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineell&auml; on tilavuus, ja muuttolaatikoilla on maksimitilavuus.</p>
		<p><em>Huom! T&auml;ss&auml; ei tarvitse ottaa esineiden ulkomuotoa huomioon!</em></p>
		<h4>
			Tavara ja Esine</h4>
		<p>Muuttomiehet siirt&auml;v&auml;t tavarat my&ouml;hemmin rekka-autoon (ei toteuteta t&auml;ss&auml;), joten toteutetaan ensin kaikkia esineit&auml; ja laatikoita kuvaava <code>Tavara</code>-rajapinta.</p>
		<p>Tavara-rajapinnan tulee m&auml;&auml;ritell&auml; metodi <code>int getTilavuus()</code>, jonka avulla tavaroita k&auml;sittelev&auml;t saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code>pakkaukseen <code>muuttaminen.domain</code>.</p>
		<p>Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code>luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Muuta luokkaa <code>Esine</code>siten, ett&auml; se toteuttaa rajapinnan <code>Tavara</code>.</p>
		<p>Lis&auml;&auml; luokalle <code>Esine</code>my&ouml;s metodit <code>public String getNimi()</code>ja korvaa metodi <code>public String toString()</code>versiolla, joka tulostaa &quot;<code>nimi (tilavuus dm^3)</code>&quot;. Esineen pit&auml;isi toimia nyt jotakuinkin seuraavasti</p>
		<pre class="sh_java">
    Tavara esine = new Esine(&quot;hammasharja&quot;, 2);
    System.out.println(esine);
</pre>
		<pre>
hammasharja (2 dm^3)
</pre>
		<h4>
			Esine vertailtavaksi ja Muuttolaatikko</h4>
		<p>Pakatessamme esineit&auml; muuttolaatikkoon haluamme aloittaa pakkaamisen j&auml;rjestyksess&auml; olevista esineist&auml;. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code>siten, ett&auml; esineiden <em>luonnollinen j&auml;rjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineell&auml; rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.</p>
		<pre class="sh_java">
    List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
    esineet.add(new Esine(&quot;passi&quot;, 2));
    esineet.add(new Esine(&quot;hammasharja&quot;, 1));
    esineet.add(new Esine(&quot;sirkkeli&quot;, 100));

    Collections.sort(esineet);
    System.out.println(esineet);
</pre>
		<pre>
[hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
</pre>
		<p>Toteuta t&auml;m&auml;n j&auml;lkeen pakkaukseen <code>muuttaminen.domain</code>luokka <code>Muuttolaatikko</code>, jonka tulee toteuttaa rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code>saa selville muuttolaatikon t&auml;m&auml;nhetkisen tilavuuden. Rajapinnan <code>Tavara</code>lis&auml;ksi Muuttolaatikolla on seuraavanlainen API</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>public Muuttolaatikko(int maksimitilavuus)</code></li>
			<li>
				Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.</li>
			<br />
			<li>
				<code>public boolean lisaaTavara(Tavara tavara)</code></li>
			<li>
				Lis&auml;&auml; muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.</li>
			<br />
		</ul>
		<p>&nbsp;</p>
		<p>Toteuta viel&auml; luokalle <code>Muuttolaatikko</code>rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code>tulee saada selville muuttolaatikossa olevien tavaroiden t&auml;m&auml;nhetkisen yhteistilavuuden.</p>
		<h4>
			Esineiden pakkaaminen</h4>
		<p>Seuraavaksi toteutetaan esineiden pakkaustoiminnallisuus.</p>
		<p>Toteuta luokka <code>Pakkaaja</code>pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code>konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>. Kokonaisluku <code>laatikoidenTilavuus</code>m&auml;&auml;rittelee mink&auml; kokoisia muuttolaatikoita pakkaaja k&auml;ytt&auml;&auml;.</p>
		<p>Toteuta t&auml;m&auml;n j&auml;lkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaEsineet(List&lt;Esine&gt; esineet)</code>, joka pakkaa esineet muuttolaatikoihin.</p>
		<p>Tee metodista sellainen ett&auml; kaikki parametrina annetussa listassa olevat esineet p&auml;&auml;tyv&auml;t palautetussa listassa oleviin muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>
		<h4>
			Tehokkaampi pakkaaminen</h4>
		<p>Alla on kuvattu er&auml;s hieman tehokkaampi pakkaustapa <em>pseudokoodina</em>, eli ohjelmointikielen tapaisena koodina. Pseudokoodia k&auml;ytet&auml;&auml;n muun muassa ohjelmointikieliriippumattomaan algoritmien eli ohjelmien kuvaamiseen.</p>
		<pre>
pakkaaEsineet( esineet ):
    jarjesta( esineet )

    laatikot = [] // huom, kannattaa k&auml;ytt&auml;&auml; ArrayListi&auml;

    while esineet is not empty:
        Muuttolaatikko pakattu = pakkaaLaatikko( esineet )
        laatikot.add( pakattu )

    return laatikot

pakkaaLaatikko( esineet ):
    Muuttolaatikko laatikko = new Muuttolaatikko

    lisaaSuuria( esineet, laatikko )
    lisaaPienia( esineet, laatikko )

    return laatikko

lisaaSuuria( esineet, laatikko ):
    while esineet is not empty:
        esine = suurin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return

lisaaPienia(List esineet, Muuttolaatikko laatikko):
    while esineet is not empty:
        esine = pienin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return
</pre>
		<p>Muokkaa luokkaa <code>Pakkaaja</code>siten, ett&auml; se toimii samoin tai paremmin kuin yll&auml; kuvattu l&auml;hestymistapa.</p>
		<p>Metodissa <code>pakkaaEsineet</code>pakataan muuttolaatikoita niin pitk&auml;&auml;n kun <code>esineet</code>-listalla on esineit&auml;. Muuttolaatikkoa pakattaessa algoritmi lis&auml;&auml; laukkuun ensiksi niin paljon suurimpia esineit&auml; kuin laatikkoon mahtuu. Kun laatikkoon ei en&auml;&auml; mahdu suurimpia esineit&auml;, aletaan t&auml;ytt&auml;m&auml;&auml;n sit&auml; pienimmill&auml; esineill&auml;.</p>
		<p>Toteutuksesta: Kun esineesi ovat j&auml;rjestyksess&auml;, suurin tavara l&ouml;ytyy indeksist&auml; <code>esinelistan koko - 1</code>, pienin tavara l&ouml;ytyy indeksist&auml; <code>0</code>. &Auml;l&auml; k&auml;yt&auml; t&auml;ss&auml; <code>Collections.min</code>ja <code>Collections.max</code>-metodeja, sill&auml; ne eiv&auml;t osaa arvata ett&auml; <code>ArrayList</code>-lista on jo j&auml;rjestyksess&auml;.</p>
		<p>Poista esineit&auml; <code>esineet</code>-listalta sit&auml; mukaa kun niit&auml; on lis&auml;tty muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>
		<p><em>Huom!</em> Saadaksesi pisteen t&auml;st&auml; viimeisest&auml; teht&auml;v&auml;st&auml; algoritmisi tulee toimia <em>v&auml;hint&auml;&auml;n</em> yht&auml; hyvin kuin yll&auml; kuvattu algoritmi. Hyvyydell&auml; tarkoitetaan sit&auml;, ett&auml; pakkaukseen kulunut aika tulee olla v&auml;hint&auml;&auml;n yht&auml; pieni kuin pseudokoodiratkaisun. Muuttolaatikkojen m&auml;&auml;r&auml;n tulee my&ouml;s olla v&auml;hint&auml;&auml;n yht&auml; pieni.</p>
		<p>Voit k&auml;ytt&auml;&auml; seuraavaa metodia satunnaisten esineiden luomiseen.</p>
		<pre class="sh_java">
    public static List&lt;Esine&gt; luoEsineet(int kpl, int maxTilavuus) {
        Random rand = new Random();

        List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
        for (int i = 0; i &lt; kpl; i++) {
            esineet.add(new Esine(&quot;hammasharja&quot;, 1 + rand.nextInt(maxTilavuus)));
        }

        return esineet;
    }
</pre>
		<p>Yll&auml; kuvatulla algoritmilla pakkaamisen pit&auml;isi toimia nopeasti jopa 100000 esinett&auml; sis&auml;lt&auml;vill&auml; listoilla. Voit testata pakkaajasi nopeutta esimerkiksi seuraavasti:</p>
		<pre class="sh_java">
        List&lt;Esine&gt; esineet = luoEsineet(100000, 10);
        Pakkaaja pakkaaja = new Pakkaaja(50);

        long start = System.nanoTime();
        List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaEsineet(esineet);
        long kulunutAika = ((System.nanoTime() - start) / 1000000);

        System.out.println(&quot;Pakkaukseen kului &quot; + kulunutAika + &quot; ms.&quot;);
        System.out.println(&quot;Tarvittiin &quot; + laatikot.size() + &quot; laatikkoa.&quot;);
</pre>
		<h3>
			Tekstiseikkailu</h3>
		<p>Teht&auml;v&auml;sarjassa tehd&auml;&auml;n laajennettava tekstiseikkailupelin runko. Seikkailu koostuu <em>kohdista</em>, joissa jokaisessa ruudulle tulee teksti&auml;. Kohdat voivat olla joko v&auml;livaiheita, kysymyksi&auml;, tai monivalintakohtia. Monivalinta-tyyppisen kohdan n&auml;ytt&auml;m&auml; teksti voi olla esimerkiksi seuraavanlainen:</p>
		<pre>
Huoneessa on kaksi ovea. Kumman avaat?

1. Vasemmanpuoleisen.
2. Oikeanpuoleisen.
3. Juoksen pakoon.
</pre>
		<p>K&auml;ytt&auml;j&auml; vastaa kohdassa esitett&auml;v&auml;&auml;n tekstiin. Yll&auml; olevaan tekstiin voi vastata <code>1</code>, <code>2</code>tai <code>3</code>, ja vastauksesta riippuu, minne k&auml;ytt&auml;j&auml; siirtyy seuraavaksi.</p>
		<p>Peliin tullaan toteuttamaan kohtia kuvaava rajapinta ja tekstik&auml;ytt&ouml;liittym&auml;, jonka kautta peli&auml; pelataan.</p>
		<p><em>Huom!</em> Toteuta kaikki teht&auml;v&auml;n vaiheet pakkaukseen &quot;seikkailu&quot;</p>
		<h4 class="req">
			Kohta ja V&auml;livaihe</h4>
		<p>Peliss&auml; voi olla hyvinkin erilaisia kohtia, ja edell&auml; olleessa esimerkiss&auml; ollut monivalinta on vain er&auml;s vaihtoehto.</p>
		<p>Toteuta kohdan k&auml;ytt&auml;ytymist&auml; kuvaava rajapinta <code>Kohta</code>. Rajapinnalla <code>Kohta</code>tulee olla metodi <code>String teksti()</code>, joka palauttaa kohdassa tulostettavan tekstin. Metodin <code>teksti</code>lis&auml;ksi kohdalla tulee olla metodi <code>Kohta seuraavaKohta(String vastaus)</code>, jonka toteuttavat luokat palauttavat seuraavan kohdan vastauksen perusteella.</p>
		<p>Toteuta t&auml;m&auml;n j&auml;lkeen yksinkertaisin tekstiseikkailun kohta, eli ei-interaktiivinen tekstiruutu, josta p&auml;&auml;see etenem&auml;&auml;n mill&auml; tahansa sy&ouml;tteell&auml;. Toteuta ei-interaktiivista tekstiruutua varten luokka <code>Valivaihe</code>, jolla on seuraavanlainen API.</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				Luokka toteuttaa rajapinnan <code>Kohta</code>.</li>
			<li>
				Konstruktori ottaa parametrikseen k&auml;ytt&auml;j&auml;lle n&auml;ytett&auml;v&auml;n tekstin.</li>
			<li>
				<code>public String teksti()</code>-metodi palauttaa konstruktorissa annetun tekstin sek&auml; rivin <code>"(jatka painamalla enteriä)"</code>. (Rivinvaihto saadaan aikaan merkill&auml; &quot;\n&quot;.)</li>
			<li>
				<code>public void asetaSeuraava(Kohta seuraava)</code>-metodilla voidaan asettaa <code>Kohta</code>-olio, jonka <code>seuraavaKohta(String vastaus)</code>aina palauttaa (vastauksesta riippumatta).</li>
		</ul>
		<p>&nbsp;</p>
		<p>Testaa ohjelmaasi seuraavalla esimerkill&auml;:</p>
		<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Valivaihe alkuteksti = new Valivaihe(&quot;Olipa kerran ohjelmoija.&quot;);
    Valivaihe johdanto = new Valivaihe(&quot;Joka alkoi ohjelmoimaan Javalla.&quot;);
    alkuteksti.asetaSeuraava(johdanto);

    Kohta nykyinen = alkuteksti;
    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(lukija.nextLine());
    if (nykyinen == null) {
        System.out.println(&quot;Virhe ohjelmassa!&quot;);
    }

    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(lukija.nextLine());
    if (nykyinen != null) {
        System.out.println(&quot;Virhe ohjelmassa!&quot;);
    }
</pre>
		<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteri&auml;)

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteri&auml;)

</pre>
		<h4>
			K&auml;ytt&ouml;liittym&auml;</h4>
		<p>Pelin k&auml;ytt&ouml;liittym&auml; (luokka <code>Kayttoliittyma</code>) saa konstruktorin parametrina <code>Scanner</code>-olion ja <code>Kohta</code>-rajapinnan toteuttavan pelin aloittavan olion. Luokka tarjoaa metodin <code>public void kaynnista()</code>, joka k&auml;ynnist&auml;&auml; pelin suorituksen.</p>
		<p>K&auml;ytt&ouml;liittym&auml; k&auml;sittelee kaikkia kohtia <code>Kohta</code>-rajapinnan kautta. K&auml;ytt&ouml;liittym&auml;n tulee jokaisessa kohdassa kysy&auml; kohtaan liittyv&auml;lt&auml; metodilta <code>teksti</code>teksti&auml;, joka k&auml;ytt&auml;j&auml;lle n&auml;ytet&auml;&auml;n. T&auml;m&auml;n j&auml;lkeen k&auml;ytt&ouml;liittym&auml; kysyy k&auml;ytt&auml;j&auml;lt&auml; vastauksen, ja antaa sen parametrina kohta-olion metodille <code>seuraavaKohta</code>. Metodi <code>seuraavaKohta</code>palauttaa vastauksen perusteella seuraavan kohdan, johon pelin on m&auml;&auml;r&auml; siirty&auml;. Peli loppuu, kun metodi <code>seuraavaKohta</code>palauttaa arvon <code>null</code>.</p>
		<p>Koska p&auml;&auml;ohjelma tulee k&auml;ytt&auml;m&auml;&auml;n kohtia vain <code>Kohta</code>-rajapinnan kautta, voidaan peliin lis&auml;t&auml; vaikka mink&auml;laisia kohtia p&auml;&auml;ohjelmaa muuttamatta. Riitt&auml;&auml; tehd&auml; uusia <code>Kohta</code>-rajapinnan toteuttavia luokkia.</p>
		<p>Toteuta luokka <code>Kayttoliittyma</code>, ja testaa sen toimintaa seuraavalla esimerkill&auml;</p>
		<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);
        Valivaihe alku = new Valivaihe(&quot;Olipa kerran ohjelmoija.&quot;);
        Valivaihe johdanto = new Valivaihe(&quot;Joka alkoi ohjelmoimaan Javalla.&quot;);
        Valivaihe loppu = new Valivaihe(&quot;Ja p&auml;&auml;tti muuttaa Helsinkiin.&quot;);

        alku.asetaSeuraava(johdanto);
        johdanto.asetaSeuraava(loppu);

        new Kayttoliittyma(lukija, alku).kaynnista();
</pre>
		<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteri&auml;)
&gt;

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteri&auml;)
&gt;

Ja p&auml;&auml;tti muuttaa Helsinkiin.
(jatka painamalla enteri&auml;)
&gt;

</pre>
		<p>K&auml;yt&auml; seuraavaa metodia k&auml;ytt&ouml;liittym&auml;n <code>kaynnista</code>-metodina. Yrit&auml; piirt&auml;&auml; paperille mit&auml; k&auml;y kun k&auml;ytt&ouml;liittym&auml; k&auml;ynnistet&auml;&auml;n.</p>
		<pre class="sh_java">
    public void kaynnista() {
        Kohta nykyinen = alkukohta;

        while (nykyinen != null) {
            System.out.println(nykyinen.teksti());
            System.out.print(&quot;&gt; &quot;);
            String vastaus = lukija.nextLine();

            nykyinen = nykyinen.seuraavaKohta(vastaus);
            System.out.println(&quot;&quot;);
        }
    }
</pre>
		<p>K&auml;ytt&ouml;liittym&auml;n <code>kaynnista</code>-metodi sis&auml;lt&auml;&auml; siis toistolauseen, jossa ensin tulostetaan k&auml;sitelt&auml;v&auml;n kohdan teksti. T&auml;m&auml;n j&auml;lkeen kysyt&auml;&auml;n k&auml;ytt&auml;j&auml;lt&auml; sy&ouml;tett&auml;. K&auml;ytt&auml;j&auml;n sy&ouml;te annetaan vastauksena k&auml;sitelt&auml;v&auml;n kohdan <code>seuraavaKohta</code>-metodille. Metodi <code>seuraavaKohta</code>palauttaa kohdan, jota k&auml;sitell&auml;&auml;n seuraavalla toiston kierroksella. Jos palautettu kohta oli <code>null</code>, lopetetaan toisto.</p>
		<h4>
			Kysymyksi&auml;</h4>
		<p>Tekstiseikkailussa voi olla kysymyksi&auml;, joihin on annettava oikea vastaus ennen kuin pelaaja p&auml;&auml;see eteenp&auml;in. Tee luokka <code>Kysymys</code>seuraavasti:</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				Luokka toteuttaa <code>Kohta</code>-rajapinnan.</li>
			<li>
				Konstruktori saa parametreina kysymystekstin ja oikean vastauksen.</li>
			<li>
				Seuraavan kohdan voi asettaa <code>asetaSeuraava</code>-metodilla.</li>
			<li>
				Jos <code>seuraavaKohta</code>-metodia kutsutaan oikealla vastauksella, metodi palauttaa seuraavan kohdan, muuten metodi ei p&auml;&auml;st&auml; etenem&auml;&auml;n ja palauttaa arvon <code>this</code>, eli viitteen t&auml;h&auml;n olioon.</li>
		</ul>
		<p>&nbsp;</p>
		<p>Luokkaa voi testata seuraavalla p&auml;&auml;ohjelmalla:</p>
		<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Kysymys alku = new Kysymys(&quot;Min&auml; vuonna Javan ensimm&auml;inen versio julkaistiin?&quot;, &quot;1995&quot;);
    Valivaihe hyva = new Valivaihe(&quot;Hyv&auml;! Lis&auml;tietoa: Javan alkuper&auml;inen ideoija on James Gosling.&quot;);

    alku.asetaSeuraava(hyva);

    new Kayttoliittyma(lukija, alku).kaynnista();
</pre>
		<pre>
Min&auml; vuonna Javan ensimm&auml;inen versio julkaistiin?
&gt; 2000

Min&auml; vuonna Javan ensimm&auml;inen versio julkaistiin?
&gt; 1995

Hyv&auml;! Lis&auml;tietoa: Javan alkuper&auml;inen ideoija on James Gosling.
(jatka painamalla enteri&auml;)
&gt;
</pre>
		<h4 class="req">
			Monivalintakysymykset</h4>
		<p>T&auml;ll&auml; hetkell&auml; tekstiseikkailu tukee v&auml;livaiheita ja yksinkertaisia kysymyksi&auml;. Tekstiseikkailu on siis lineaarinen, eli lopputulokseen ei voi k&auml;yt&auml;nn&ouml;ss&auml; vaikuttaa. Lis&auml;t&auml;&auml;n seikkailuun monivalintakysymyksi&auml;, joiden avulla pelin kehitt&auml;j&auml; voi luoda vaihtoehtoista toimintaa.</p>
		<p>Esimerkki vaihtoehtoisesta toiminnasta:</p>
		<pre>
Kello on 13:37 ja p&auml;&auml;t&auml;t menn&auml; sy&ouml;m&auml;&auml;n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; 1

Ruoka on loppu :(
(jatka painamalla enteri&auml;)
&gt;
</pre>
		<pre>
Kello on 13:37 ja p&auml;&auml;t&auml;t menn&auml; sy&ouml;m&auml;&auml;n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; 2

Mainio valinta!
(jatka painamalla enteri&auml;)
&gt;
</pre>
		<p>Toteuta luokka <code>Monivalinta</code>, jonka API on seuraavanlainen</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				Toteuttaa rajapinnan <code>Kohta</code>.</li>
			<br />
			<li>
				<code>public Monivalinta(String teksti)</code></li>
			<li>
				Luokan konstruktori saa parametrina n&auml;ytett&auml;v&auml;n tekstin.</li>
			<br />
			<li>
				<code>public void lisaaVaihtoehto(String valinta, Kohta seuraava)</code></li>
			<li>
				Lis&auml;&auml; vaihtoehdon ja siihen liittyv&auml;n seuraavan kohdan. Yhdess&auml; monivalintakysymyksess&auml; voi olla rajaton m&auml;&auml;r&auml; vaihtoehtoja.</li>
			<br />
			<li>
				<code>public String teksti()</code></li>
			<li>
				Palauttaa merkkijonona sek&auml; konstruktorissa annetun perustekstin ett&auml; kaikki valintavaihtoehdot. Valintavaihtoehdot tulee olla eritelty numeroilla.</li>
			<br />
			<li>
				<code>public Kohta seuraavaKohta(String valinta)</code></li>
			<li>
				Palauttaa k&auml;ytt&auml;j&auml;n valitsemaa vaihtoehtoa vastaavan kohdan. K&auml;ytt&auml;j&auml; valitsee aina kirjoittamalla numeron. Huom! Voit muuttaa merkkijonon numeroksi luokan <code>Integer</code>luokkametodilla <code>parseInt</code>.</li>
			<br />
		</ul>
		<p>&nbsp;</p>
		<p>Testaa ohjelmasi toimintaa seuraavalla p&auml;&auml;ohjelmalla:</p>
		<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Monivalinta lounas = new Monivalinta(&quot;Kello on 13:37 ja p&auml;&auml;t&auml;t menn&auml; sy&ouml;m&auml;&auml;n. Minne menet?&quot;);
    Monivalinta chemicum = new Monivalinta(&quot;Lounasvaihtoehtosi ovat seuraavat:&quot;);

    Valivaihe exactum = new Valivaihe(&quot;Exactumista on kaikki loppu, joten menet Chemicumiin.&quot;);

    exactum.asetaSeuraava(chemicum);

    lounas.lisaaVaihtoehto(&quot;Exactumiin&quot;, exactum);
    lounas.lisaaVaihtoehto(&quot;Chemicumiin&quot;, chemicum);

    Valivaihe nom = new Valivaihe(&quot;Olipas hyv&auml;&auml;&quot;);

    chemicum.lisaaVaihtoehto(&quot;Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta&quot;, nom);
    chemicum.lisaaVaihtoehto(&quot;Jauhelihakebakot, paprikakastiketta&quot;, nom);
    chemicum.lisaaVaihtoehto(&quot;Mausteista kalapataa&quot;, nom);

    new Kayttoliittyma(lukija, lounas).kaynnista();
</pre>
		<pre>
Kello on 13:37 ja p&auml;&auml;t&auml;t menn&auml; sy&ouml;m&auml;&auml;n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; 1

Exactumista on kaikki loppu, joten menet Chemicumiin.
(jatka painamalla enteri&auml;)
&gt;

Lounasvaihtoehtosi ovat seuraavat:
1. Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta
2. Jauhelihakebakot, paprikakastiketta
3. Mausteista kalapataa
&gt; 2

Olipas hyv&auml;&auml;
(jatka painamalla enteri&auml;)
&gt;

</pre>
		<p><em>Luokan <code>Monivalinta</code>sis&auml;inen toteutus saattaa olla haastava. Kannattaa esimerkiksi k&auml;ytt&auml;&auml; listaa vastausvaihtoehtojen (merkkijonojen) tallentamiseen, ja hajautustaulua kohtien tallentamiseen valintavaihtoehdon indeksill&auml;. </em></p>
	</div>
	<h2>
		Poikkeustilanteet</h2>
	<p>Poikkeustilanteet ovat tilanteita joissa ohjelman suoritus ei ole edennyt toivotusti. Ohjelma on saattanut esimerkiksi kutsua <em>null</em>-viitteeseen liittyv&auml;&auml; metodia, jolloin k&auml;ytt&auml;j&auml;lle <em>heitet&auml;&auml;n</em> poikkeus <code>NullPointerException</code>. Jos yrit&auml;mme hakea taulukon ulkopuolella olevaa indeksi&auml;, k&auml;ytt&auml;j&auml;lle heitet&auml;&auml;n poikkeus <code>IndexOutOfBoundsException</code>. Kaikki poikkeukset ovat tyyppi&auml; <code>Exception</code>.</p>
	<p>Poikkeukset k&auml;sitell&auml;&auml;n <code>try { } catch (Exception e) { }</code>-lohkorakenteella. Avainsanan <code>try</code>aloittaman lohkon sis&auml;ll&auml; on <em>mahdollisesti</em> poikkeuksen heitt&auml;v&auml; ohjelmakoodi. Avainsanan <code>catch</code>aloittaman lohkon sis&auml;ll&auml; taas m&auml;&auml;ritell&auml;&auml;n mit&auml; tehd&auml;&auml;n jos try-lohkossa suoritettavassa koodissa tapahtuu poikkeus. Catch-lauseelle m&auml;&auml;ritell&auml;&auml;n kiinniotettavan poikkeuksen tyyppi (<code>catch (Exception e)</code>).</p>
	<pre class="sh_java">
    try {
        // poikkeuksen mahdollisesti heitt&auml;v&auml; ohjelmakoodi
    } catch (Exception e) {
        // lohko johon p&auml;&auml;dyt&auml;&auml;n poikkeustilanteessa
    }
</pre>
	<p>Merkkijonon numeroksi muuttava <code>Integer</code>-luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank">parseInt</a></code>-metodi heitt&auml;&auml; poikkeuksen <code>NumberFormatException</code>jos sille parametrina annettu merkkijono ei ole muunnettavissa numeroksi. Toteutetaan ohjelma, joka yritt&auml;&auml; muuntaa k&auml;ytt&auml;j&auml;n sy&ouml;tt&auml;m&auml;n merkkijonon numeroksi.</p>
	<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    System.out.print(&quot;Sy&ouml;t&auml; numero: &quot;);

    int numero = Integer.parseInt(lukija.nextLine());
</pre>
	<pre>
Sy&ouml;t&auml; numero: tatti
Exception in thread &quot;...&quot; java.lang.NumberFormatException: For input string: &quot;tatti&quot;
</pre>
	<p>Yll&auml; oleva ohjelma heitt&auml;&auml; poikkeuksen kun k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; virheellisen numeron. Ohjelman suoritus p&auml;&auml;ttyy virhetilanteeseen, eik&auml; suoritusta voi en&auml;&auml; jatkaa. Lis&auml;t&auml;&auml;n ohjelmaan poikkeusk&auml;sittely. Kutsu, joka saattaa heitt&auml;&auml; poikkeuksen asetetaan <code>try</code>-lohkon sis&auml;&auml;n, ja virhetilanteessa tapahtuva toiminta <code>catch</code>-lohkon sis&auml;&auml;n.</p>
	<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print(&quot;Sy&ouml;t&auml; numero: &quot;);

    try {
        int numero = Integer.parseInt(lukija.nextLine());
    } catch (Exception e) {
        System.out.println(&quot;Et sy&ouml;tt&auml;nyt kunnollista numeroa.&quot;);
    }
</pre>
	<pre>
Sy&ouml;t&auml; numero: 5
</pre>
	<pre>
Sy&ouml;t&auml; numero: enp&auml;s!
Et sy&ouml;tt&auml;nyt kunnollista numeroa.
</pre>
	<p>Avainsanan <code>try</code>m&auml;&auml;rittelem&auml;n lohkon sis&auml;lt&auml; siirryt&auml;&auml;n <code>catch</code>-lohkoon heti poikkeuksen tapahtuessa. Visualisoidaan t&auml;t&auml; lis&auml;&auml;m&auml;ll&auml; tulostuslause <code>try</code>-lohkossa metodia <code>Integer.parseInt</code>kutsuvan rivin j&auml;lkeen.</p>
	<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print(&quot;Sy&ouml;t&auml; numero: &quot;);

    try {
        int numero = Integer.parseInt(lukija.nextLine());
        System.out.println(&quot;Hienosti sy&ouml;tetty!&quot;);
    } catch (Exception e) {
        System.out.println(&quot;Et sy&ouml;tt&auml;nyt kunnollista numeroa.&quot;);
    }
</pre>
	<pre>
Sy&ouml;t&auml; numero: 5
Hienosti sy&ouml;tetty!
</pre>
	<pre>
Sy&ouml;t&auml; numero: enp&auml;s!
Et sy&ouml;tt&auml;nyt kunnollista numeroa.
</pre>
	<p>Ohjelmalle sy&ouml;tetty merkkijono <code>enpäs!</code>annetaan parametrina <code>Integer.parseInt</code>-metodille, joka heitt&auml;&auml; poikkeuksen jos parametrina saadun merkkijonon muuntaminen luvuksi ep&auml;onnistuu. Huomaa ett&auml; <code>catch</code>-lohkossa oleva koodi suoritetaan <em>vain</em> poikkeustapauksissa -- muulloin ohjelma ei p&auml;&auml;se sinne.</p>
	<p>Tehd&auml;&auml;n luvun muuntajasta hieman hy&ouml;dyllisempi: Tehd&auml;&auml;n siit&auml; metodi, joka kysyy numeroa yh&auml; uudestaan kunnes k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; oikean numeron. Metodista p&auml;&auml;see pois <em>vain</em> jos k&auml;ytt&auml;j&auml; sy&ouml;tt&auml;&auml; oikean luvun.</p>
	<pre class="sh_java">
public int lueLuku(Scanner lukija) {
    while (true) {
        System.out.print(&quot;Sy&ouml;t&auml; numero: &quot;);

        try {
            int numero = Integer.parseInt(lukija.nextLine());
            return numero;
        } catch (Exception e) {
            System.out.println(&quot;Et sy&ouml;tt&auml;nyt kunnollista numeroa.&quot;);
        }
    }
}
</pre>
	<p>Metodin <code>lueLuku</code>kutsuminen voisi toimia esimerkiksi seuraavasti</p>
	<pre>
Sy&ouml;t&auml; numero: enp&auml;s!
Et sy&ouml;tt&auml;nyt kunnollista numeroa.
Sy&ouml;t&auml; numero: Matilla on ovessa tatti.
Et sy&ouml;tt&auml;nyt kunnollista numeroa.
Sy&ouml;t&auml; numero: 43

</pre>
	<h3>
		Poikkeusten heitt&auml;minen</h3>
	<p>Metodit ja konstruktorit voivat <em>heitt&auml;&auml;</em> poikkeuksia. Heitett&auml;vi&auml; poikkeuksia on karkeasti ottaen kahdenlaisia. On poikkeuksia jotka on pakko k&auml;sitell&auml;, ja on poikkeuksia joita ei ole pakko k&auml;sitell&auml;. Pakosti k&auml;sitelt&auml;v&auml;t poikkeukset k&auml;sitell&auml;&auml;n joko <code>try-catch</code>-lohkossa, tai <em>heitt&auml;m&auml;ll&auml; ne ulos metodista</em>. Rajapintoihin liittyneess&auml; <em>Julkaisupalvelu</em>-esimerkiss&auml; on Javan metodi <code>Thread.sleep</code>, jonka mahdollisesti heitt&auml;m&auml; poikkeus on <em>pakko</em> k&auml;sitell&auml;. Sen k&auml;sittely tapahtuu esimerkiksi <code>try-catch</code>-lauseella, seuraavassa esimerkiss&auml; olemme v&auml;litt&auml;m&auml;tt&auml; mahdollisista poikkeustilanteista ja j&auml;timme <code>catch</code>-lohkon tyhj&auml;ksi.</p>
	<pre class="sh_java">
    try {
        // nukutaan 1000 millisekuntia
        Thread.sleep(1000);
    } catch (Exception e) {
        // ei tehd&auml; mit&auml;&auml;n poikkeustilanteessa
    }
</pre>
	<p>Jos poikkeusta ei k&auml;sitell&auml;, tulee metodin antaa vastuu poikkeuksen k&auml;sittelyst&auml; metodin kutsujalle. Vastuun siirto tapahtuu heitt&auml;m&auml;ll&auml; poikkeus metodista eteenp&auml;in sanomalla <code>throws Exception</code>.</p>
	<pre class="sh_java">
    public void nuku(int sekuntia) <strong>throws Exception</strong> {
        Thread.sleep(sekuntia * 1000);
    }
</pre>
	<p>Nyt metodia <code>nuku</code>-kutsuvan metodin tulee joko k&auml;sitell&auml; poikkeus <code>try-catch</code>-lohkossa, tai siirt&auml;&auml; poikkeuksen k&auml;sittelyn vastuuta eteenp&auml;in heitt&auml;&auml; poikkeus eteenp&auml;in. Palaamme poikkeuksiin, jotka on pakko k&auml;sitell&auml; tarkemmin tiedostojen k&auml;sittelyn yhteydess&auml;.</p>
	<p>Osa poikkeuksista, kuten <code>Integer.parseInt</code>-metodin heitt&auml;m&auml; <code>NumberFormatException</code>, on sellaisia joihin ohjelmoijan ei ole pakko varautua. Poikkeukset, joihin k&auml;ytt&auml;j&auml;n ei tarvitse varautua ovat aina my&ouml;s tyyppi&auml; tyyppi&auml; <code>RuntimeException</code>-- palaamme siihen <em>miksi</em> muuttujilla voi olla useita eri tyyppej&auml; tarkemmin ensi viikolla.</p>
	<p>Voimme itse heitt&auml;&auml; poikkeuksen l&auml;hdekoodista <code>throw</code>-komennolla. Esimerkiksi <code>NumberFormatException</code>-luokasta luodun poikkeuksen heitt&auml;minen tapahtuisi komennolla <code>throw new NumberFormatException()</code>.</p>
	<p>Er&auml;s poikkeus johon k&auml;ytt&auml;j&auml;n ei ole pakko varautua on <code>IllegalArgumentException</code>. Poikkeuksella <code>IllegalArgumentException</code>kerrotaan ett&auml; metodille tai konstruktorille annettujen parametrien arvot ovat <em>v&auml;&auml;r&auml;nlaiset</em>. IllegalArgumentException-poikkeusta k&auml;ytet&auml;&auml;n esimerkiksi silloin kun halutaan varmistaa ett&auml; parametreilla on tietyt arvot. Luodaan luokka <code>Arvosana</code>, joka saa konstruktorin parametrina kokonaislukutyyppisen arvosanan.</p>
	<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>
	<p>Haluamme seuraavaksi <em>validoida</em> Arvosana-luokan konstruktorin parametrina saadun arvon. Arvosanan tulee olla aina v&auml;lill&auml; 0-5. Jos arvosana on jotain muuta, haluamme <em>heitt&auml;&auml; poikkeuksen</em>. Lis&auml;t&auml;&auml;n <code>Arvosana</code>-luokan konstruktoriin ehtolause, joka tarkistaa onko arvosana arvov&auml;lin 0-5 ulkopuolella. Jos on, heitet&auml;&auml;n poikkeus <code>IllegalArgumentException</code>sanomalla <code>throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");</code>.</p>
	<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        if (arvosana &lt; 0 || arvosana &gt; 5) {
            throw new IllegalArgumentException(&quot;Arvosanan tulee olla v&auml;lill&auml; 0-5&quot;);
        }
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>
	<pre class="sh_java">
    Arvosana arvosana = new Arvosana(3);
    System.out.println(arvosana.getArvosana());

    Arvosana virheellinenArvo = new Arvosana(22);
    // tapahtuu poikkeus, t&auml;st&auml; ei jatketa eteenp&auml;in
</pre>
	<pre>
3
Exception in thread &quot;...&quot; java.lang.IllegalArgumentException: Arvosanan tulee olla v&auml;lill&auml; 0-5
</pre>
	<div class="tehtavat">
		<h3>
			Parametrien validointi</h3>
		<p>Harjoitellaan hieman parametrien validointia <code>IllegalArgumentException</code>-poikkeuksen avulla. Teht&auml;v&auml;pohjassa tulee kaksi luokkaa, <code>Henkilo</code>ja <code>Laskin</code>. Muuta luokkia seuraavasti:</p>
		<h4>
			Henkil&ouml;n validointi</h4>
		<p>Luokan <code>Henkilo</code>konstruktorin tulee varmistaa ett&auml; parametrina annettu nimi ei ole null, tyhj&auml; tai yli 40 merkki&auml; pitk&auml;. My&ouml;s i&auml;n tulee olla v&auml;lilt&auml; 0-120. Jos joku edell&auml;olevista ehdoista ei p&auml;de, tulee konstruktorin heitt&auml;&auml; <code>IllegalArgumentException</code>-poikkeus.</p>
		<h4>
			Laskimen validointi</h4>
		<p>Luokan <code>Laskin</code>metodeja tulee muuttaa seuraavasti: Metodin <code>kertoma</code>tulee toimia vain jos parametrina annetaan ei-negatiivinen luku (0 tai suurempi). Metodin <code>binomikerroin</code>tulee toimia vain jos parametrit ovat ei-negatiivisia ja osajoukon koko on pienempi kuin joukon koko. Jos jompikumpi metodeista saa ep&auml;kelpoja arvoja metodikutsujen yhteydess&auml;, tulee metodien heitt&auml;&auml; poikkeus <code>IllegalArgumentException</code>.</p>
	</div>
	<h3>
		Poikkeukset ja rajapinnat</h3>
	<p>Rajapintaluokilla ei ole metodirunkoa, mutta metodim&auml;&auml;rittely on vapaasti rajapinnan suunnittelijan toteutettavissa. Rajapintaluokat voivat m&auml;&auml;ritell&auml; my&ouml;s poikkeusten heiton. Esimerkiksi seuraavan rajapinnan <code>Tiedostopalvelin</code>toteuttavat luokat heitt&auml;v&auml;t <em>mahdollisesti</em> poikkeuksen <code>lataa</code>- ja <code>tallenna</code>-metodissa.</p>
	<pre class="sh_java">
public interface Tiedostopalvelin {
    String lataa(String tiedosto) throws Exception;
    void tallenna(String tiedosto, String merkkijono) throws Exception;
}
</pre>
	<p>Jos rajapinta m&auml;&auml;rittelee metodeille <code>throws Exception</code>-m&auml;&auml;reet, eli ett&auml; metodit heitt&auml;v&auml;t mahdollisesti poikkeuksen, tulee samat m&auml;&auml;reet olla my&ouml;s rajapinnan toteuttavassa luokassa. Luokan ei kuitenkaan ole pakko heitt&auml;&auml; poikkeusta kuten allaolevasta esimerkist&auml; n&auml;kee.</p>
	<pre class="sh_java">
public class Tekstipalvelin implements Tiedostopalvelin {

    private Map&lt;String, String&gt; data;

    public Tekstipalvelin() {
        this.data = new HashMap&lt;String, String&gt;();
    }

    @Override
    public String lataa(String tiedosto) throws Exception {
        return this.data.get(tiedosto);
    }

    @Override
    public void tallenna(String tiedosto, String merkkijono) throws Exception {
        this.data.put(tiedosto, merkkijono);
    }
}
</pre>
	<h3>
		Poikkeuksen tiedot</h3>
	<p>Poikkeusten k&auml;sittelytoiminnallisuuden sis&auml;lt&auml;m&auml; <code>catch</code>-lohko m&auml;&auml;rittelee catch-osion sis&auml;ll&auml; poikkeuksen johon varaudutaan <code>catch (<em>Exception e</em>)</code>. Poikkeuksen tiedot tallennetaan <code>e</code>-muuttujaan.</p>
	<pre class="sh_java">
    try {
        // ohjelmakoodi, joka saattaa heitt&auml;&auml; poikkeuksen
    } catch (Exception e) {
        // poikkeuksen tiedot ovat tallessa muuttujassa e
    }
</pre>
	<p>Luokka <code>Exception</code>tarjoaa hy&ouml;dyllisi&auml; metodeja. Esimerkiksi metodi <code>printStackTrace()</code>tulostaa <em>polun</em>, joka kertoo mist&auml; p&auml;&auml;dyttiin poikkeukseen. Tutkitaan seuraavaa metodin <code>printStactTrace()</code>tulostamaa virhett&auml;.</p>
	<pre>
Exception in thread &quot;main&quot; java.lang.NullPointerException
  at pakkaus.Luokka.tulosta(Luokka.java:43)
  at pakkaus.Luokka.main(Luokka.java:29)
</pre>
	<p>Poikkeuspolun lukeminen tapahtuu alhaalta yl&ouml;sp&auml;in. Alimpana on ensimm&auml;inen kutsu, eli ohjelman suoritus on alkanut luokan <code>Luokka</code>metodista <code>main()</code>. Luokan <code>Luokka</code>main-metodin rivill&auml; 29 on kutsuttu metodia <code>tulosta()</code>. Metodin <code>tulosta</code>rivill&auml; 43 on tapahtunut poikkeus <code>NullPointerException</code>. Poikkeuksen tiedot ovatkin hyvin hy&ouml;dyllisi&auml; virhekohdan selvitt&auml;misess&auml;.</p>
	<h2 id="file">
		Tiedostojen k&auml;sittely</h2>
	<p>Huomattava osa ohjelmista k&auml;sittelee jollain tavalla tallennettua tietoa. Otetaan ensiaskeleet tiedostojen k&auml;sittelyyn Javassa. Javan API tarjoaa luokan <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">File</a>, jonka sis&auml;lt&ouml; voidaan lukea kurssilla jo tutuksi tulleen <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokan avulla.</p>
	<p>Luokan <code>File</code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">API-kuvausta</a> lukiessamme huomaamme <code>File</code>-luokalla on konstruktori <code>File(String pathname)</code>(<em>Creates a new File instance by converting the given pathname string into an abstract pathname</em>). Voimme siis antaa avattavan tiedoston polun <code>File</code>-luokan konstruktorille.</p>
	<p><em>NetBeans-ohjelmointiymp&auml;rist&ouml;ss&auml; tiedostoille on oma v&auml;lilehti nimelt&auml; <em>Files</em>. Files-v&auml;lilehdell&auml; on m&auml;&auml;ritelty kaikki projektiin liittyv&auml;t tiedostot. Jos projektin <em>juureen</em>, eli ei yhdenk&auml;&auml;n hakemiston sis&auml;lle, lis&auml;t&auml;&auml;n tiedosto, voidaan siihen viitata projektin sis&auml;lt&auml; suoraan tiedoston nimell&auml;. Tiedosto-olion luominen tapahtuu antamalla sille parametrina polku tiedostoon, esimerkiksi seuraavasti</em></p>
	<pre class="sh_java">
    File tiedosto = new File(&quot;tiedoston-nimi.txt&quot;);
</pre>
	<h3>
		Tiedoston lukeminen</h3>
	<p>Scanner-luokan konstruktorille voi antaa my&ouml;s muita lukemisl&auml;hteit&auml; kuin <code>System.in</code>-sy&ouml;tt&ouml;virran. Lukemisl&auml;hteen&auml; voi olla n&auml;pp&auml;imist&ouml;n lis&auml;ksi muun muassa tiedosto. Scanner tarjoaa tiedoston lukemiseen samat metodit kuin n&auml;pp&auml;imist&ouml;lt&auml; sy&ouml;tetyn sy&ouml;tteen lukemiseen. Seuraavassa esimerkiss&auml; avataan tiedosto ja tulostetaan kaikki tiedoston sis&auml;lt&auml;m&auml;n tekstit <code>System.out.println</code>-komennolla.</p>
	<pre class="sh_java">
        // tiedosto mist&auml; luetaan
        File tiedosto = new File(&quot;tiedosto.txt&quot;);

        Scanner lukija = new Scanner(tiedosto);
        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            System.out.println(rivi);
        }

        lukija.close();
</pre>
	<p>Scanner-luokan konstruktori <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#Scanner(java.io.File)" target="_blank">public Scanner(File source)</a></code>(<em>Constructs a new Scanner that produces values scanned from the specified file.</em>) heitt&auml;&auml; <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileNotFoundException.html" target="_blank">FileNotFoundException</a></code>-poikkeuksen jos luettavaa tiedostoa ei l&ouml;ydy. Poikkeus <code>FileNotFoundException</code>ei ole tyyppi&auml; <code>RuntimeException</code>, joten se tulee joko k&auml;sitell&auml; tai heitt&auml;&auml; eteenp&auml;in. T&auml;ss&auml; vaiheessa riitt&auml;&auml; tiet&auml;&auml; ett&auml; ohjelmointiymp&auml;rist&ouml; kertoo jos sinun tulee k&auml;sitell&auml; poikkeus erikseen. Luodaan ensin vaihtoehto, jossa poikkeus k&auml;sitell&auml;&auml;n tiedostoa avattaessa.</p>
	<pre class="sh_java">
    public void lueTiedosto(File tiedosto) {
        // tiedosto mist&auml; luetaan
        Scanner lukija = null;

        try {
            lukija = new Scanner(tiedosto);
        } catch (Exception e) {
            System.out.println(&quot;Tiedoston lukeminen ep&auml;onnistui. Virhe: &quot; + e.getMessage());
            return; // poistutaan metodista
        }

        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            System.out.println(rivi);
        }

        lukija.close();
    }
</pre>
	<p>Toinen vaihtoehto poikkeuksen k&auml;sittelyyn on poikkeuksen k&auml;sittelyvastuun siirt&auml;minen metodin kutsujalle. Poikkeuksen k&auml;sittelyvastuu siirret&auml;&auml;n metodin kutsujalle lis&auml;&auml;m&auml;ll&auml; metodiin m&auml;&auml;re <code>throws <em>PoikkeuksenTyyppi</em></code>, eli esimerkiksi <code>throws Exception</code>sill&auml; kaikki poikkeukset ovat tyyppi&auml; <code>Exception</code>. Kun metodilla on m&auml;&auml;re <code>throws Exception</code>, tiet&auml;v&auml;t kaikki sit&auml; kutsuvat ett&auml; se saattaa heitt&auml;&auml; poikkeuksen johon tulee varautua.</p>
	<pre class="sh_java">
    public void lueTiedosto(File tiedosto) throws Exception {
        // tiedosto mist&auml; luetaan
        Scanner lukija = new Scanner(tiedosto);

        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            System.out.println(rivi);
        }

        lukija.close();
    }
</pre>
	<p>Esimerkki avaa tiedoston <code>tiedosto.txt</code>projektin juuripolusta ja tulostaa sen rivi rivilt&auml; k&auml;ytt&auml;j&auml;lle n&auml;kyville. Lopuksi lukija suljetaan, jolloin tiedosto my&ouml;s suljetaan. M&auml;&auml;re <code>throws Exception</code>kertoo ett&auml; metodi saattaa heitt&auml;&auml; poikkeuksen. Samanlaisen m&auml;&auml;reen voi laittaa kaikkiin metodeihin jotka k&auml;sittelev&auml;t tiedostoja.</p>
	<p>Huomaa ett&auml; <code>Scanner</code>-olio ei liit&auml; rivinvaihtomerkkej&auml; osaksi <code>nextLine</code>-metodin palauttamaa merkkijonoa. Yksi vaihtoehto tiedoston lukemiseen siten, ett&auml; rivinvaihdot s&auml;ilyv&auml;t, on <code>StringBuilder</code>-olion k&auml;ytt&auml;minen lukemisessa siten, ett&auml; jokaisen rivin j&auml;lkeen lis&auml;t&auml;&auml;n rivinvaihtomerkki.</p>
	<pre class="sh_java">
    public String lueTiedostoMerkkijonoon(File tiedosto) throws Exception {
        // tiedosto mist&auml; luetaan
        Scanner lukija = new Scanner(tiedosto);

        StringBuilder stringBuilder = new StringBuilder();

        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            stringBuilder.append(rivi);
            stringBuilder.append(&quot;\n&quot;);
        }

        lukija.close();
        return stringBuilder.toString();
    }
</pre>
	<p>Koska k&auml;yt&auml;mme tiedoston lukemiseen <code>Scanner</code>-luokkaa, k&auml;yt&ouml;ss&auml;mme on kaikki Scanner-luokan tarjoamat metodit. Esimerkiksi metodi <code>hasNext()</code>palauttaa totuusarvon <code>true</code>, jos luettavassa tiedostossa on viel&auml; luettavaa j&auml;ljell&auml;, ja metodi <code>next()</code>lukee seuraavan sanan metodin palauttamaan <code>String</code>-olioon.</p>
	<p>Seuraava ohjelma luo <code>Scanner</code>-olion, joka avaa tiedoston <code>tiedosto.txt</code>. Sen j&auml;lkeen se tulostaa joka viidennen sanan tiedostosta.</p>
	<pre class="sh_java">
        File tiedosto = new File(&quot;tiedosto.txt&quot;);
        Scanner lukija = new Scanner(tiedosto);

        int monesko = 0;
        while (lukija.hasNext()) {
            monesko++;
            String sana = lukija.next();

            if (monesko % 5 == 0) {
                System.out.println(sana);
            }
        }
</pre>
	<p>Alla on ensin luetun tiedoston sis&auml;lt&auml;m&auml; teksti ja sitten ohjelman tulostus</p>
	<pre>
Poikkeukset (exceptions) ovat &quot;poikkeuksellisia tilanteita&quot; kesken normaalin ohjelmansuorituksen:
tiedosto loppuu, merkkijono ei kelpaa kokonaisluvuksi, odotetun olion tilalla onkin null-arvo,
taulukon indeksi menee ohjelmointivirheen takia sopimattomaksi, ...
</pre>
	<pre>
tilanteita&quot;
loppuu,
odotetun
taulukon
sopimattomaksi,
</pre>
	<h3>
		Merkist&ouml;ongelmista</h3>
	<p>Teksti&auml; tiedostosta luettaessa (tai tiedostoon tallennettaessa) Java joutuu p&auml;&auml;ttelem&auml;&auml;n k&auml;ytt&ouml;j&auml;rjestelm&auml;n k&auml;ytt&auml;m&auml;n merkist&ouml;n. Merkist&ouml;n tuntemusta tarvitaan sek&auml; tekstin tallentamiseen tietokoneen kovalevylle bin&auml;&auml;rimuotoiseksi ett&auml; bin&auml;&auml;rimuotoisen datan tekstiksi k&auml;&auml;nt&auml;miseksi.</p>
	<p>Merkist&ouml;ihin on kehitetty standardeja, joista &quot;UTF-8&quot; on nyky&auml;&auml;n yleisin. UTF-8 -merkist&ouml; sis&auml;lt&auml;&auml; sek&auml; jokap&auml;iv&auml;isess&auml; k&auml;yt&ouml;ss&auml; olevien aakkosten ett&auml; erikoisempien merkkien kuten Japanin kanji-merkist&ouml;n tai shakkipelin nappuloiden tallentamiseen ja lukemiseen tarvittavat tiedot. Ohjelmointimieless&auml; merkist&ouml;&auml; voi hieman yksinkertaistaen ajatella hajautustauluna merkist&auml; numeroon ja numerosta merkkiin. Merkist&auml; numeroon oleva hajautustaulu kuvaa mink&auml;laisena bin&auml;&auml;rilukuna kukin merkki tallennetaan tiedostoon. Numerosta merkkiin oleva hajautustaulu taas kuvaa miten tiedostoa luettaessa saadut luvut muunnetaan merkeiksi.</p>
	<p>L&auml;hes jokaisella k&auml;ytt&ouml;j&auml;rjestelm&auml;valmistajalla on my&ouml;s omat standardinsa. Osa tukee ja haluaa osallistua avoimien standardien k&auml;ytt&ouml;&ouml;n, osa ei. Mik&auml;li sinulla on ongelmia &auml;&auml;kk&ouml;sellisten sanojen kanssa (eritoten mac ja windows k&auml;ytt&auml;j&auml;t) voit kertoa <code>Scanner</code>-oliota luodessa k&auml;ytett&auml;v&auml;n merkist&ouml;n. T&auml;ll&auml; kurssilla k&auml;yt&auml;mme aina merkist&ouml;&auml; &quot;UTF-8&quot;.</p>
	<p>UTF-8 -merkist&ouml;&auml; k&auml;ytt&auml;v&auml;n tiedostoa lukevan Scanner-olion voi luoda seuraavasti:</p>
	<pre class="sh_java">
    File tiedosto = new File(&quot;esimerkkitiedosto.txt&quot;);
    Scanner lukija = new Scanner(tiedosto, &quot;UTF-8&quot;);
</pre>
	<p>Toinen vaihtoehto merkist&ouml;n asettamiseksi on ymp&auml;rist&ouml;muuttujan k&auml;ytt&auml;minen. Macintosh ja Windows-k&auml;ytt&auml;j&auml;t voivat asettaa ymp&auml;rist&ouml;muuttujan <code>JAVA_TOOL_OPTIONS</code>arvoksi merkkijonon <code>-Dfile.encoding=UTF8</code>. T&auml;ll&ouml;in Java k&auml;ytt&auml;&auml; oletuksena aina UTF-8 -merkist&ouml;&auml;.</p>
	<div class="tehtavat">
		<h3>
			Tiedoston analyysi</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; tehd&auml;&auml;n tiedoston analysointity&ouml;kalu, joka tarjoaa rivien ja merkkien laskemistoiminnallisuuden.</p>
		<h4>
			Rivien laskeminen</h4>
		<p>Tee pakkaukseen <code>tiedosto</code>luokka <code>Analyysi</code>, jolla on konstruktori <code>public Analyysi(File tiedosto)</code>. Toteuta luokalle metodi <code>public int rivimaara()</code>, joka palauttaa konstruktorille annetun tiedoston rivim&auml;&auml;r&auml;n.</p>
		<h4>
			Merkkien laskeminen</h4>
		<p>Toteuta luokkaan <code>Analyysi</code>metodi <code>public int merkkeja()</code>, joka palauttaa luokan konstruktorille annetun tiedoston merkkien m&auml;&auml;r&auml;n.</p>
		<p>Voit itse p&auml;&auml;tt&auml;&auml; miten reagoidaan jos konstruktorin parametrina saatua tiedostoa ei ole olemassa.</p>
		<pre class="sh_java">
    File tiedosto = new File(&quot;src/testitiedosto.txt&quot;);
    Analyysi analyysi = new Analyysi(tiedosto);
    System.out.println(&quot;Rivej&auml;: &quot; + analyysi.rivimaara());
    System.out.println(&quot;Merkkej&auml;: &quot; + analyysi.merkkeja());
</pre>
		<pre>
Rivej&auml;: 3
Merkkej&auml;: 67
</pre>
		<h3>
			Sanatutkimus</h3>
		<p>Tee luokka Sanatutkimus, jolla voi tehd&auml; erilaisia tutkimuksia tiedoston sis&auml;lt&auml;mille sanoille. Toteuta luokka pakkaukseen <code>sanatutkimus</code>.</p>
		<p>Kotimaisten kielten tutkimuskeskus (Kotus) on julkaissut netiss&auml; suomen kielen sanalistan. T&auml;ss&auml; teht&auml;v&auml;ss&auml; k&auml;ytet&auml;&auml;n listan muokattua versiota, joka l&ouml;ytyy teht&auml;v&auml;pohjasta <code>src</code>-hakemistosta nimell&auml; <code>sanalista.txt</code>, eli suhteellisesta polusta <code>"src/sanalista.txt"</code>.</p>
		<p>Tiedosto l&ouml;ytyy projektin p&auml;&auml;hakemistosta. Kun tiedosto on NetBeans-projektisi p&auml;&auml;hakemistossa, voit k&auml;ytt&auml;&auml; sen polkuna lyhytt&auml; muotoa &quot;sanalista.txt&quot;.</p>
		<p>Mik&auml;li sinulla on ongelmia &auml;&auml;kk&ouml;sellisten sanojen kanssa (mac ja windows k&auml;ytt&auml;j&auml;t) luo <code>Scanner</code>-olio antaen sille parametrina merkist&ouml; &quot;UTF-8&quot; seuraavasti: <code> Scanner lukija = new Scanner(tiedosto, "UTF-8");</code>Ongelmat liittyv&auml;t erityisesti testien suoritukseen.</p>
		<h4 class="req">
			Sanojen m&auml;&auml;r&auml;</h4>
		<p>Luo Sanatutkimus-luokalle konstruktori <code>public Sanatutkimus(File tiedosto)</code>joka luo uuden Sanatutkimus-olion, joka tutkii parametrina annettavaa tiedostoa.</p>
		<p>Tee luokkaan metodi <code>public int sanojenMaara()</code>, joka lukee tiedostossa olevat sanat ja tulostaa niiden m&auml;&auml;r&auml;n. T&auml;ss&auml; vaiheessa sanoilla ei tarvitse tehd&auml; mit&auml;&auml;n, riitt&auml;&auml; laskea niiden m&auml;&auml;r&auml;. Voit olettaa, ett&auml; tiedostossa on vain yksi sana rivi&auml; kohti.</p>
		<h4 class="req">
			z-kirjain</h4>
		<p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimenZSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, joissa on z-kirjain. T&auml;llaisia sanoja ovat esimerkiksi jazz ja zombi.</p>
		<h4 class="req">
			l-p&auml;&auml;te</h4>
		<p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimeenLPaattyvatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka p&auml;&auml;ttyv&auml;t l-kirjaimeen. T&auml;llaisia sanoja ovat esimerkiksi kannel ja sammal.</p>
		<p><em>Huom! Jos luet tiedoston uudestaan ja uudestaan jokaisessa metodissa huomaat viimeist&auml;&auml;n t&auml;ss&auml; vaiheessa copy-paste koodia. Kannattaa mietti&auml; olisiko tiedoston lukeminen helpompi tehd&auml; osana konstruktoria tai metodina, jota konstruktori kutsuu. Metodeissa voitaisiin k&auml;ytt&auml;&auml; t&auml;ll&ouml;in jo luettua listaa ja luoda siit&auml; aina uusi, hakuehtoihin sopiva lista...</em></p>
		<h4>
			Palindromit</h4>
		<p>Tee luokkaan metodi <code>public List&lt;String&gt; palindromit()</code>, joka palauttaa tiedoston kaikki sanat, jotka ovat palindromeja. T&auml;llaisia sanoja ovat esimerkiksi ala ja enne.</p>
		<h4 class="req">
			Kaikki vokaalit</h4>
		<p>Tee luokkaan metodi <code>public List&lt;String&gt; kaikkiVokaalitSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka sis&auml;lt&auml;v&auml;t kaikki suomen kielen vokaalit (aeiouy&auml;&ouml;). T&auml;llaisia sanoja ovat esimerkiksi my&ouml;h&auml;iselokuva ja ymp&auml;rist&ouml;nsuojelija.</p>
	</div>
	<h3 id="tiedostostoon_kirjoitus">
		Tiedostoon kirjoittaminen</h3>
	<p>Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html">FileWriter</a></code>tarjoaa toiminnallisuuden tiedostoon kirjoittamiseen. Luokan <code>FileWriter</code>konstruktorille annetaan parametrina kohdetiedoston sijaintia kuvaava merkkijono.</p>
	<pre class="sh_java">
        FileWriter kirjoittaja = new FileWriter(&quot;tiedosto.txt&quot;);
        kirjoittaja.write(&quot;Hei tiedosto!\n&quot;); // rivinvaihto tulee my&ouml;s kirjoittaa tiedostoon!
        kirjoittaja.write(&quot;Lis&auml;&auml; teksti&auml;\n&quot;);
        kirjoittaja.write(&quot;Ja viel&auml; lis&auml;&auml;&quot;);
        kirjoittaja.close(); // sulkemiskutsu sulkee tiedoston ja varmistaa ett&auml; kirjoitettu teksti menee tiedostoon
</pre>
	<p>Esimerkiss&auml; kirjoitetaan tiedostoon &quot;tiedosto.txt&quot; merkkijono &quot;Hei tiedosto!&quot;, jota seuraa rivinvaihto, ja viel&auml; hieman lis&auml;&auml; teksti&auml;. Huomaa ett&auml; tiedostoon kirjoitettaessa metodi <code>write</code>ei lis&auml;&auml; rivinvaihtoja, vaan ne tulee lis&auml;t&auml; itse.</p>
	<p>Sek&auml; <code>FileWriter</code>-luokan konstruktori ett&auml; <code>write</code>-metodi heitt&auml;&auml; mahdollisesti poikkeuksen, joka tulee joko k&auml;sitell&auml; tai siirt&auml;&auml; kutsuvan metodin vastuulle. Metodi, jolle annetaan parametrina kirjoitettavan tiedoston nimi ja kirjoitettava sis&auml;lt&ouml; voisi n&auml;ytt&auml;&auml; seuraavalta.</p>
	<pre class="sh_java">
public class Tallentaja {

    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }
}
</pre>
	<p>Yll&auml; olevassa <code>kirjoitaTiedostoon</code>-metodissa luodaan ensin <code>FileWriter</code>-olio, joka kirjoittaa parametrina annetussa sijainnissa sijaitsevaan tiedostoon <code>tiedostonNimi</code>. T&auml;m&auml;n j&auml;lkeen kirjoitetaan tiedostoon <code>write</code>-metodilla. Konstruktorin ja <code>write</code>-metodin mahdollisesti heitt&auml;m&auml; poikkeus tulee k&auml;sitell&auml; joko <code>try-catch</code>-lohkolla tai siirt&auml;m&auml;ll&auml; poikkeuksen k&auml;sittely vastuuta eteenp&auml;in. Metodissa <code>kirjoitaTiedostoon</code>k&auml;sittelyvastuu on siirretty eteenp&auml;in.</p>
	<p>Luodaan <code>main</code>-metodi jossa kutsutaan <code>Tallentaja</code>-olion <code>kirjoitaTiedostoon</code>-metodia. Poikkeusta ei ole pakko k&auml;sitell&auml; <code>main</code>-metodissakaan, vaan se voi ilmoittaa heitt&auml;v&auml;ns&auml; mahdollisesti poikkeuksen m&auml;&auml;rittelyll&auml; <code>throws Exception</code>.</p>
	<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        Tallentaja tallentaja = new Tallentaja();
        tallentaja.kirjoitaTiedostoon(&quot;paivakirja.txt&quot;, &quot;Rakas p&auml;iv&auml;kirja, t&auml;n&auml;&auml;n oli kiva p&auml;iv&auml;.&quot;);
    }
</pre>
	<p>Yll&auml; olevaa metodia kutsuttaessa luodaan tiedosto &quot;paivakirja.txt&quot; johon kirjoitetaan teksti &quot;Rakas p&auml;iv&auml;kirja, t&auml;n&auml;&auml;n oli kiva p&auml;iv&auml;.&quot;. Jos tiedosto on jo olemassa, pyyhkiytyy vanhan tiedoston sis&auml;lt&ouml; uutta kirjoittaessa. Metodilla <code>append()</code>voidaan lis&auml;t&auml; olemassaolevan tiedoston per&auml;&auml;n teksti&auml;, jolloin olemassaolevaa teksti&auml; ei poisteta. Lis&auml;t&auml;&auml;n <code>Tallentaja</code>-luokalle metodi <code>lisaaTiedostoon()</code>, joka lis&auml;&auml; parametrina annetun tekstin tiedoston loppuun.</p>
	<pre class="sh_java">
public class Tallentaja {
    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }

    public void lisaaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.append(teksti);
        kirjoittaja.close();
    }
}
</pre>
	<p>Joskus tiedoston per&auml;&auml;n metodilla <code>append</code>kirjoittamisen sijasta on helpompi kirjoittaa koko tiedosto uudelleen.</p>
	<div class="tehtavat">
		<h3>
			Muistava sanakirja</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; laajennetaan aiemmin toteutettua sanakirjaa siten, ett&auml; sanakirjaan voi lukea sanat tiedostosta sek&auml; tallettaa sanat tiedostoon. Teht&auml;v&auml;n&auml;si on luoda luokka <code>OmaMuistavaSanakirja</code>, joka toteuttaa teht&auml;v&auml;pohjassa annetun rajapinnan <code>MuistavaSanakirja</code>. Toteuta luokka pakkaukseen <code>sanakirja</code>, jossa rajapintakin sijaitsee.</p>
		<p>Teht&auml;v&auml;pohjan rajapinnan koodi:</p>
		<pre class="sh_java">
package sanakirja;

public interface MuistavaSanakirja {
    void lisaa(String sana, String kaannos);
    String kaanna(String sana);
    void poista(String sana);

    void lataa() throws IOException;
    void talleta() throws IOException;
}
</pre>
		<p>Rajapinnan metodien kuvaukset:</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>void lisaa(String sana, String kaannos)</code></li>
			<li>
				lis&auml;&auml; sanan sanakirjaan</li>
			<br />
			<li>
				<code>String kaanna(String sana)</code></li>
			<li>
				palauttaa k&auml;&auml;nn&ouml;ksen annetulle sanalle</li>
			<br />
			<li>
				<code>void poista(String sana)</code></li>
			<li>
				poistaa annetun sanan ja sen k&auml;&auml;nn&ouml;ksen sanakirjasta</li>
			<br />
			<li>
				<code>void lataa() throws IOException</code></li>
			<li>
				lataa tiedostosta sanat sanakirjaan, lataamisessa tapahtuvia poikkeuksia (<code>IOException</code>) ei tule k&auml;sitell&auml;</li>
			<br />
			<li>
				<code>void talleta() throws IOException</code></li>
			<li>
				tallettaa sanakirjan sanat tiedostoon, talletuksessa tapahtuvia poikkeuksia (<code>IOException</code>) ei tule k&auml;sitell&auml;</li>
			<br />
		</ul>
		<p>&nbsp;</p>
		<p>Voit kopioida metodien <code>lisaa</code>ja <code>kaanna</code>toteutukset suoraan aiemmasta sanakirjateht&auml;v&auml;st&auml;. Toteuta n&auml;iden lis&auml;ksi metodi <code>poista</code>.</p>
		<h4 class="req">
			Sanojen luku tiedostosta</h4>
		<p>Toteuta luokalle <code>OmaMuistavaSanakirja</code>konstruktori, joka ottaa ainoaksi parametrikseen tiedoston nimen merkkijonona.</p>
		<p>Toteuta sanakirjalle my&ouml;s metodi <code>lataa</code>, joka lukee sanakirjan sis&auml;ll&ouml;n tiedostosta (jonka nimi on annettu konstruktorissa).</p>
		<p>Tiedosto koostuu tekstiriveist&auml; jossa on sana-k&auml;&auml;nn&ouml;s-pareja:</p>
		<pre>
olut beer
apina monkey
ohjelmoija programmer
opiskelija student
</pre>
		<p><b>Huom: </b> jotta ohjelma l&ouml;yt&auml;&auml; tiedoston, pit&auml;&auml; se sijoittaa projektin juureen. T&auml;m&auml; onnistuu valitsemalla NetBeansista <i>file -&gt; new file -&gt; other</i>. Sanakirjaprojektin tulee olla p&auml;&auml;projektina kun luot tiedoston. Voit editoida tiedostoa joko NetBeansilla tai tekstieditorilla.</p>
		<p><b>Huom2:</b> voit lukea sy&ouml;tteen kahdella tavalla, joko Scannerin metodilla <code>next</code>yksitt&auml;inen sana kerrallaa tai <code>nextLine</code>:ll&auml; rivi kerrallaan. Jos luet rivi kerrallaan, pit&auml;&auml; rivi hajoittaa kahdeksi merkkijonoksi (esim. &quot;olut beer&quot; -&gt; &quot;olut&quot;, &quot;beer&quot;) jotta lis&auml;ys sanakirjaan onnistuu. T&auml;m&auml; voidaan tehd&auml; esim. <code>split</code>-komennolla:</p>
		<pre class="sh_java">
   String rivi = lukija.nextLine();
   String[] osat = rivi.split(&quot; &quot;);
   // nyt osat[0] on rivin ensimm&auml;inen sana ja osat[1] toinen
</pre>
		<p>Sanakirjaa k&auml;ytet&auml;&auml;n siis esimerkiksi n&auml;in:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        MuistavaSanakirja sanakirja = new OmaMuistavaSanakirja(&quot;suomi-englanti.txt&quot;);
        sanakirja.lataa();

        // voit testata t&auml;ss&auml; k&auml;&auml;nn&ouml;ksi&auml;
    }
</pre>
		<h4 class="req">
			Sanojen talletus tiedostoon</h4>
		<p>Tee sanakirjalle metodi <code>talleta</code>, jota kutsuttaessa sanakirjan sis&auml;lt&ouml; kirjoitetaan tiedostoon.</p>
		<p>Talletus kannattanee hoitaa siten, ett&auml; koko k&auml;&auml;nn&ouml;slista kirjoitetaan uudelleen vanhan tiedoston p&auml;&auml;lle, eli materiaalissa esitelty&auml; <code>append</code>-komentoa ei kannata k&auml;ytt&auml;&auml;.</p>
		<p>Varmista ett&auml; ohjelmasi toimii, eli ett&auml; uuden k&auml;ynnistyksen j&auml;lkeen edellisess&auml; suorituksessa talletetut sanat l&ouml;ytyv&auml;t sanakirjasta.</p>
		<p>Talletusominaisuutta voi k&auml;ytt&auml;&auml; vaikkapa n&auml;in:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        MuistavaSanakirja sanakirja = new OmaMuistavaSanakirja(&quot;suomi-englanti.txt&quot;);
        sanakirja.lataa();

        // lis&auml;&auml; uusia sanoja, poista vanhoja

        sanakirja.talleta();
    }
</pre>
		<h4>
			Olematon tiedosto</h4>
		<p>Muokaa viel&auml; ohjelmasi sellaiseksi, ett&auml; metodi <code>lataa</code>toimii (eli ei tee mit&auml;&auml;n) jos sanakirjatiedostoa ei ole viel&auml; olemassa. Voit poistaa sanakirjan esim. valitsemalla <i>window -&gt; files -&gt; delete</i>.</p>
	</div>
	<h2>
		Joukoista ja hajautustauluista</h2>
	<p>Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code>kuvaa joukon toiminnallisuutta. Joukossa on kutakin alkioita korkeintaan yksi kappale, eli yht&auml;k&auml;&auml;n samanlaista oliota ei ole kahdesti. Olioiden samankaltaisuuden tarkistaminen toteutetaan <code>equals</code>ja <code>hashCode</code>-metodeja k&auml;ytt&auml;m&auml;ll&auml;. Ehdimme jo aiemmin pikaisesti tutustua <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>-luokkaan, joka on er&auml;s Javan <code>Set</code>-rajapinnan toteutus. Toteutetaan sen avulla luokka <code>Tehtavakirjanpito</code>, joka tarjoaa mahdollisuuden teht&auml;vien kirjanpitoon ja tehtyjen teht&auml;vien tulostamiseen. Oletetaan ett&auml; teht&auml;v&auml;t ovat aina kokonaislukuja.</p>
	<pre class="sh_java">
public class Tehtavakirjanpito {
    private Set&lt;Integer&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashSet&lt;Integer&gt;();
    }

    public void lisaa(int tehtava) {
        this.tehdytTehtavat.add(tehtava);
    }

    public void tulosta() {
        for (int tehtava: this.tehdytTehtavat) {
            System.out.println(tehtava);
        }
    }
}
</pre>
	<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(2);
        kirjanpito.lisaa(3);

        kirjanpito.tulosta();
</pre>
	<pre>
1
2
3
</pre>
	<p>Yll&auml; oleva ratkaisu toimii tilanteessa, jossa emme tarvitse tietoa k&auml;ytt&auml;jist&auml; eri k&auml;ytt&auml;jien tekemist&auml; teht&auml;vist&auml;. Muutetaan teht&auml;vien tallennuslogiikkaa siten, ett&auml; teht&auml;v&auml;t tallennetaan <em>k&auml;ytt&auml;j&auml;kohtaisesti</em> hajautustaulua hy&ouml;dynt&auml;en. K&auml;ytt&auml;j&auml;t tunnistetaan k&auml;ytt&auml;j&auml;n yksil&ouml;iv&auml;ll&auml; merkkijonolla (esimerkiksi opiskelijanumero), ja jokaiselle k&auml;ytt&auml;j&auml;lle on oma joukko tehdyist&auml; teht&auml;vist&auml;.</p>
	<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new HashSet&lt;Integer&gt;());
        }

        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + &quot;: &quot; + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>
	<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(&quot;Mikael&quot;, 3);
        kirjanpito.lisaa(&quot;Mikael&quot;, 4);
        kirjanpito.lisaa(&quot;Mikael&quot;, 3);
        kirjanpito.lisaa(&quot;Mikael&quot;, 3);

        kirjanpito.lisaa(&quot;Pekka&quot;, 4);
        kirjanpito.lisaa(&quot;Pekka&quot;, 4);

        kirjanpito.lisaa(&quot;Matti&quot;, 1);
        kirjanpito.lisaa(&quot;Matti&quot;, 2);

        kirjanpito.tulosta();
</pre>
	<pre>
Matti: [1, 2]
Pekka: [4]
Mikael: [3, 4]
</pre>
	<p>Huomaamme ett&auml; k&auml;ytt&auml;jien nimet eiv&auml;t tulostu esimerkiksi j&auml;rjestyksess&auml;. T&auml;m&auml; selittyy sill&auml; ett&auml; <code>HashMap</code>-tyyppisess&auml; hajautustaulussa alkioiden tallennus tapahtuu <code>hashCode</code>-metodin palauttaman hajautusarvon perusteella, eik&auml; se liity mill&auml;&auml;n tavalla alkioiden j&auml;rjestykseen. Tehd&auml;&auml;n viel&auml; toinen testi, jossa tarkistetaan p&auml;teek&ouml; sama my&ouml;s <code>HashSet</code>-joukolle. Luodaan uusi <code>HashSet</code>-joukko, ja lis&auml;t&auml;&auml;n siihen merkkijonoja.</p>
	<pre class="sh_java">
        Set&lt;String&gt; nimet = new HashSet&lt;String&gt;();
        nimet.add(&quot;Matti&quot;);
        nimet.add(&quot;Mikael&quot;);
        nimet.add(&quot;Pekka&quot;);
        nimet.add(&quot;Arto&quot;);

        System.out.println(nimet);
</pre>
	<pre>
[Arto, Matti, Pekka, Mikael]
</pre>
	<p>Alkiot eiv&auml;t ole j&auml;rjestyksess&auml;. J&auml;rjestyksess&auml; olevat tulostukset ovat yleens&auml; ottaen paljon mielekk&auml;&auml;mpi&auml; kuin ei-j&auml;rjestyksess&auml; olevat, ja olemmekin k&auml;ytt&auml;neet kurssilla jo aikaa <code>Comparable</code>- ja <code>Comparator</code>-rajapintojen kanssa.</p>
	<h3>
		TreeSet</h3>
	<p>Rajapinnan <code>Set</code>toteuttava luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeSet.html" target="_blank">TreeSet</a></code>pit&auml;&auml; joukossa olevia alkioita j&auml;rjestyksess&auml;. Jos <code>TreeSet</code>-luokan konstruktorille ei anneta parametreja, j&auml;rjestet&auml;&auml;n siihen lis&auml;tt&auml;v&auml;n alkiot niiden <em>luonnollisen j&auml;rjestyksen</em> mukaan, eli <code>Comparable</code>-rajapinnan m&auml;&auml;r&auml;&auml;m&auml;n j&auml;rjestyksen mukaan. Muutetaan edell&auml; ollutta esimerkki&auml; siten ett&auml; k&auml;yt&auml;mme <code>TreeSet</code>-oliota nimien tallentamiseen.</p>
	<pre class="sh_java">
        Set&lt;String&gt; nimet = new TreeSet&lt;String&gt;();
        nimet.add(&quot;Matti&quot;);
        nimet.add(&quot;Mikael&quot;);
        nimet.add(&quot;Pekka&quot;);
        nimet.add(&quot;Arto&quot;);

        System.out.println(nimet);
</pre>
	<pre>
[Arto, Matti, Mikael, Pekka]
</pre>
	<p>Luokan <code>TreeSet</code>parametritonta konstruktoria k&auml;ytett&auml;ess&auml; tallennettavien olioiden tulee toteuttaa rajapinta <code>Comparable</code>. Jos oliot eiv&auml;t toteuta rajapintaa <code>Comparable</code>ja haluaisimme silti ne j&auml;rjestykseen, voimme luoda luokasta <code>TreeSet</code>ilmentym&auml;n joka ottaa <code>Comparator</code>-rajapinnan toteuttavan olion konstruktorin parametrina. T&auml;ll&ouml;in kaikki alkiot j&auml;rjestet&auml;&auml;n <code>Comparator</code>-rajapinnan toteuttavan olion m&auml;&auml;r&auml;&auml;m&auml;&auml;n j&auml;rjestykseen.</p>
	<p>Luodaan oma <code>Comparator</code>-rajapinnan toteutus, joka j&auml;rjest&auml;&auml; k&auml;&auml;nt&auml;&auml; merkkijonot ja j&auml;rjest&auml;&auml; merkkijonot niiden k&auml;&auml;nteisess&auml; j&auml;rjestyksess&auml;. Luokka <code>KaanteinenJarjestys</code>k&auml;yt&auml;nn&ouml;ss&auml; j&auml;rjest&auml;&auml; merkkijonot siis vertailemalla ensin merkkijonojen viimeist&auml; kirjainta, sitten toiseksi viimeist&auml; jne -- mutta on niin fiksu ett&auml; osaa hy&ouml;dynt&auml;&auml; <code>String</code>-luokan valmiina tarjoamaa <code>compareTo</code>-metodia.</p>
	<pre class="sh_java">
public class KaanteinenJarjestys implements Comparator&lt;String&gt; {

    @Override
    public int compare(String t, String t1) {
        t = kaanna(t);
        t1 = kaanna(t1);
        return t.compareTo(t1);
    }

    private String kaanna(String merkkijono) {
        if (merkkijono == null) {
            return &quot;&quot;;
        }

        StringBuilder stringBuilder = new StringBuilder(merkkijono);
        stringBuilder.reverse();
        return stringBuilder.toString();
    }
}
</pre>
	<pre class="sh_java">
        Set&lt;String&gt; nimet = new TreeSet&lt;String&gt;(new KaanteinenJarjestys());
        nimet.add(&quot;Matti&quot;);
        nimet.add(&quot;Mikael&quot;);
        nimet.add(&quot;Pekka&quot;);
        nimet.add(&quot;Arto&quot;);

        System.out.println(nimet);
</pre>
	<pre>
[Pekka, Matti, Mikael, Arto]
</pre>
	<div class="tehtavat">
		<h3>
			Duplikaattien poistaja</h3>
		<p>Teht&auml;v&auml;n&auml;si on toteuttaa pakkaukseen <code>tyokalut</code>luokka <code>OmaDuplikaattienPoistaja</code>, joka tallettaa annetut merkkijonot siten, ett&auml; annetuista merkkijonoista poistetaan samanlaiset merkkijonot (eli duplikaatit). Lis&auml;ksi luokka pit&auml;&auml; kirjaa duplikaattien m&auml;&auml;r&auml;st&auml;. Luokan tulee toteuttaa teht&auml;v&auml;pohjassa annettu rajapinta <code>DuplikaattienPoistaja</code>, jossa on seuraavat toiminnot:</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>void lisaa(String merkkijono)</code></li>
			<li>
				tallettaa merkkijonon, jos se ei ole duplikaatti</li>
			<br />
			<li>
				<code>int getHavaittujenDuplikaattienMaara()</code></li>
			<li>
				palauttaa t&auml;h&auml;n menness&auml; havaittujen duplikaattien m&auml;&auml;r&auml;n</li>
			<br />
			<li>
				<code>Set&lt;String&gt; getUniikitMerkkijonot()</code></li>
			<li>
				palauttaa <code>Set&lt;String&gt;</code>-rajapinnan toteuttavan olion, jossa on kaikki uniikit lis&auml;tyt merkkijonot (ei siis duplikaatteja!)</li>
			<br />
			<li>
				<code>void tyhjenna()</code></li>
			<li>
				poistaa talletetut merkkijonot ja nollaa havaittujen duplikaattien m&auml;&auml;r&auml;n</li>
			<br />
		</ul>
		<p>&nbsp;</p>
		<p>Rajapinnan koodi:</p>
		<pre class="sh_java">
package tyokalut;

import java.util.Set;

public interface DuplikaattienPoistaja {
    void lisaa(String merkkijono);
    int getHavaittujenDuplikaattienMaara();
    Set&lt;String&gt; getUniikitMerkkijonot();
    void tyhjenna();
}
</pre>
		<p>Rajapintaa voi k&auml;ytt&auml;&auml; esimerkiksi n&auml;in:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        DuplikaattienPoistaja poistaja = new OmaDuplikaattienPoistaja();
        poistaja.lisaa(&quot;eka&quot;);
        poistaja.lisaa(&quot;toka&quot;);
        poistaja.lisaa(&quot;eka&quot;);

        System.out.println(&quot;Duplikaattien m&auml;&auml;r&auml; nyt: &quot; +
            poistaja.getHavaittujenDuplikaattienMaara());

        poistaja.lisaa(&quot;vika&quot;);
        poistaja.lisaa(&quot;vika&quot;);
        poistaja.lisaa(&quot;uusi&quot;);

        System.out.println(&quot;Duplikaattien m&auml;&auml;r&auml; nyt: &quot; +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println(&quot;Uniikit merkkijonot: &quot; +
            poistaja.getUniikitMerkkijonot());

        poistaja.tyhjenna();

        System.out.println(&quot;Duplikaattien m&auml;&auml;r&auml; nyt: &quot; +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println(&quot;Uniikit merkkijonot: &quot; +
            poistaja.getUniikitMerkkijonot());
    }
</pre>
		<p>Yll&auml; oleva ohjelma tulostaisi: (merkkijonojen j&auml;rjestys saa vaihdella, sill&auml; ei ole merkityst&auml;)</p>
		<pre>
Duplikaattien m&auml;&auml;r&auml; nyt: 1
Duplikaattien m&auml;&auml;r&auml; nyt: 2
Uniikit merkkijonot: [eka, toka, vika, uusi]
Duplikaattien m&auml;&auml;r&auml; nyt: 0
Uniikit merkkijonot: []
</pre>
	</div>
	<h3>
		TreeMap</h3>
	<p>Joukkojen j&auml;rjestyksess&auml; pit&auml;minen onnistuu <code>Set</code>rajapinnan toteuttavan <code>TreeSet</code>-olion avulla. Aiemmassa <code>Tehtavakirjanpito</code>-esimerkiss&auml; henkil&ouml;kohtaiset teht&auml;v&auml;pisteet tallennettiin <code>Map</code>-rajapinnan toteuttavaan <code>HashMap</code>-olioon. Kuten <code>HashSet</code>, <code>HashMap</code>ei pid&auml; alkioita j&auml;rjestyksess&auml;. Rajapinnasta <code>Map</code>on olemassa toteutus <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a></code>, jossa hajautustaulun avaimia pidet&auml;&auml;n j&auml;rjestyksess&auml;. Muutetaan <code>Tehtavakirjanpito</code>-luokkaa siten, ett&auml; henkil&ouml;kohtaiset pisteet tallennetaan <code>TreeMap</code>-tyyppiseen hajautustauluun.</p>
	<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new TreeMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new TreeSet&lt;Integer&gt;());
        }

        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + &quot;: &quot; + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>
	<p>Muunsimme samalla <code>Set</code>-rajapinnan toteutukseksi <code>TreeSet</code>-luokan. Huomaa ett&auml; koska olimme k&auml;ytt&auml;neet rajapintoja, muutoksia tuli hyvin pieneen osaan koodista. Etsi kohdat jotka muuttuivat!</p>
	<p>K&auml;ytt&auml;j&auml;kohtaiset teht&auml;v&auml;t voidaan nyt tulostaa j&auml;rjestyksess&auml;.</p>
	<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(&quot;Mikael&quot;, 3);
        kirjanpito.lisaa(&quot;Mikael&quot;, 4);
        kirjanpito.lisaa(&quot;Mikael&quot;, 3);
        kirjanpito.lisaa(&quot;Mikael&quot;, 3);

        kirjanpito.lisaa(&quot;Pekka&quot;, 4);
        kirjanpito.lisaa(&quot;Pekka&quot;, 4);

        kirjanpito.lisaa(&quot;Matti&quot;, 1);
        kirjanpito.lisaa(&quot;Matti&quot;, 2);

        kirjanpito.tulosta();
</pre>
	<pre>
Matti: [1, 2]
Mikael: [3, 4]
Pekka: [4]
</pre>
	<p>Luokka <code>TreeMap</code>vaatii ett&auml; <em>avaimena</em> k&auml;ytetyn luokan tulee toteuttaa <code>Comparable</code>-rajapinta. Jos luokka ei toteuta rajapintaa <code>Comparable</code>, voidaan luokalle <code>TreeMap</code>antaa konstruktorin parametrina <code>Comparator</code>-luokan toteuttama olio aivan kuten <code>TreeSet</code>-luokalle.</p>
	<div class="tehtavat">
		<h3>
			Sanakirja usealle k&auml;&auml;nn&ouml;kselle</h3>
		<p>Jatketaan viel&auml; sanakirjan laajentamista. Teht&auml;v&auml;n&auml;si on toteuttaa pakkaukseen <code>sanakirja</code>luokka <code>OmaUseanKaannoksenSanakirja</code>, joka voi tallettaa useamman k&auml;&auml;nn&ouml;ksen samalle sanalle. Luokan tulee toteuttaa teht&auml;v&auml;pohjassa annettu rajapinta <code>UseanKaannoksenSanakirja</code>, jossa on seuraavat toiminnot:</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>void lisaa(String sana, String kaannos)</code></li>
			<li>
				lis&auml;&auml; k&auml;&auml;nn&ouml;ksen sanalle s&auml;ilytt&auml;en vanhat k&auml;&auml;nn&ouml;kset</li>
			<br />
			<li>
				<code>Set&lt;String&gt; kaanna(String sana)</code></li>
			<li>
				palauttaa <code>Set</code>-olion, jossa on kaikki k&auml;&auml;nn&ouml;kset sanalle, tai <code>null</code>-viitteen, jos sanaa ei ole sanakirjassa</li>
			<br />
			<li>
				<code>void poista(String sana)</code></li>
			<li>
				poistaa sanan ja sen kaikki k&auml;&auml;nn&ouml;kset sanakirjasta</li>
			<br />
		</ul>
		<p>&nbsp;</p>
		<p>Rajapinnan koodi:</p>
		<pre class="sh_java">
package sanakirja;

import java.util.Set;

public interface UseanKaannoksenSanakirja {
    void lisaa(String sana, String kaannos);
    Set&lt;String&gt; kaanna(String sana);
    void poista(String sana);
}
</pre>
		<pre class="sh_java">
    UseanKaannoksenSanakirja sanakirja = new OmaUseanKaannoksenSanakirja();
    sanakirja.lisaa(&quot;kuusi&quot;, &quot;six&quot;);
    sanakirja.lisaa(&quot;kuusi&quot;, &quot;spruce&quot;);

    sanakirja.lisaa(&quot;pii&quot;, &quot;silicon&quot;);
    sanakirja.lisaa(&quot;pii&quot;, &quot;pi&quot;);

    System.out.println(sanakirja.kaanna(&quot;kuusi&quot;));
    sanakirja.poista(&quot;pii&quot;);
    System.out.println(sanakirja.kaanna(&quot;pii&quot;));
</pre>
		<pre>
[six, spruce]
null
</pre>
		<h3>
			S&auml;hk&ouml;posteja</h3>
		<p>Teht&auml;v&auml;n&auml;si on toteuttaa s&auml;hk&ouml;postiohjelmaan komponentti, joka s&auml;il&ouml;&ouml; viestej&auml;. Teht&auml;v&auml;pohjan mukana tulee luokka <code>Sahkoposti</code>, joka esitt&auml;&auml; s&auml;hk&ouml;postiviesti&auml;. Luokalla <code>Sahkoposti</code>on oliomuuttujat:</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				saapumisaika (yksinkertaisesti kokonaisluku)</li>
			<li>
				l&auml;hett&auml;j&auml;</li>
			<li>
				otsikko</li>
			<li>
				sis&auml;lt&ouml;</li>
		</ul>
		<p>&nbsp;</p>
		<p>Toteutetaan t&auml;ss&auml; luokka <code>Viestivarasto</code>, joka tarjoaa s&auml;hk&ouml;postien hallintaan liittyvi&auml; toimintoja.</p>
		<h4>
			Viestivarasto, lis&auml;&auml;minen ja hakeminen</h4>
		<p>Luo pakkaukseen <code>posti</code>luokka <code>Viestivarasto</code>, ja lis&auml;&auml; sille seuraavat metodit:</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>public void lisaa(Sahkoposti s)</code>lis&auml;&auml; viestin</li>
			<li>
				<code>public Sahkoposti hae(String otsikko)</code>palauttaa viestin jolla on annettu otsikko tai <em>null</em> jos sellaista ei ole.</li>
		</ul>
		<p>&nbsp;</p>
		<p>Voit olettaa ett&auml; mill&auml;&auml;n kahdella viestill&auml; ei ole samaa otsikkoa.</p>
		<h4>
			Ajan perusteella hakeminen</h4>
		<p>Lis&auml;&auml; luokkaan <code>Viestivarasto</code>seuraavat metodit</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<code>public Sahkoposti hae(int aika)</code>palauttaa viestin joka saapui annettuun aikaan tai <em>null</em> jos sellaista ei ole. Voit olettaa ett&auml; mill&auml;&auml;n kahdella viestill&auml; ei ole samaa saapumisaikaa.</li>
			<li>
				<code>public Sahkoposti haeUusinViesti()</code>hakee uusimman viestin (eli sen jonka saapumisaika on isoin) ai <em>null</em> jos sellaista ei ole.</li>
			<li>
				<code>public Sahkoposti haeUusinViesti(int ylaraja)</code>hakee uusimman viestin joka on saapunut ennen annettua aikaa tai <em>null</em> jos sellaista ei ole.</li>
		</ul>
		<p>&nbsp;</p>
		<p><em>Huom!</em> Kannattaa k&auml;ytt&auml;&auml; kahta erillist&auml; rakennetta viestien tallentamiseen. Otsikon perusteella tallentamiseen voit k&auml;ytt&auml;&auml; <code>HashMap</code>pia, ja viestien tallentamiseen ajan mukaan <code>TreeMap</code>pia. N&auml;in saat toteutettua hae-operaatiot tehokkaasti. Tutustu my&ouml;s <code>TreeMap</code>in metodeihin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#lastKey()" target="_blank">lastKey()</a></code>ja <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#floorKey()" target="_blank">floorKey()</a></code>.</p>
		<h3>
			Numerotiedustelu</h3>
		<p>Tehd&auml;&auml;n sovellus jonka avulla on mahdollista hallinnoida ihmisten puhelinnumeroita ja osoitteita.</p>
		<p>Teht&auml;v&auml;n voi suorittaa 1-4 pisteen laajuisena. Yhden pisteen laajuuteen on toteutettava seuraavat toiminnot:</p>
		<ul>
			<li>
				1 puhelinnumeron lis&auml;ys henkil&ouml;lle</li>
			<li>
				2 henkil&ouml;n puhelinnumeroiden haku</li>
			<li>
				3 numeroa vastaavan henkil&ouml;n nimen haku</li>
		</ul>
		<p>kahteen pisteeseen vaadittaan edellisten lis&auml;ksi</p>
		<ul>
			<li>
				4 osoitteen lis&auml;ys henkil&ouml;lle</li>
			<li>
				5 henkil&ouml;n tietojen (osoite ja puhelinnumero) haku</li>
		</ul>
		<p>kolmeen pisteeseen vaadittaan toiminto</p>
		<ul>
			<li>
				6 henkil&ouml;n tietojen poisto</li>
		</ul>
		<p>ja t&auml;ysiin pisteeseen vaaditaan viel&auml;</p>
		<ul>
			<li>
				7 hakusanalla filtter&ouml;ity listaus (nimen mukaan aakkostettuna), hakusana voi esiinty&auml; henkil&ouml;n nimess&auml; tai osoitteessa</li>
		</ul>
		<p>Esimerkki ohjelman toiminnasta:</p>
		<pre>
numerotiedustelu
k&auml;ytett&auml;viss&auml; olevat komennot:
 1 lis&auml;&auml; numero
 2 hae numerot
 3 hae puhelinnumeroa vastaava henkil&ouml;
 4 lis&auml;&auml; osoite
 5 hae henkil&ouml;n tiedot
 6 poista henkil&ouml;n tiedot
 7 filtter&ouml;ity listaus
 x lopeta

komento: 1
kenelle: pekka
numero: 040-123456

komento: 2
kenen: jukka
  ei l&ouml;ytynyt

komento: 2
kenen: pekka
 040-123456

komento: 1
kenelle: pekka
numero: 09-222333

komento: 2
kenen: pekka
 040-123456
 09-222333

komento: 3
numero: 02-444123
 ei l&ouml;ytynyt

komento: 3
numero: 09-222333
 pekka

komento: 5
kenen: pekka
  osoite ei tiedossa
  puhelinnumerot:
   040-123456
   09-222333

komento: 4
kenelle: pekka
katu: ida ekmanintie
kaupunki: helsinki

komento: 5
kenen: pekka
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

komento: 4
kenelle: jukka
katu: korsontie
kaupunki: vantaa

komento: 5
kenen: jukka
  osoite: korsontie vantaa
  ei puhelinta

komento: 7
hakusana (jos tyhj&auml;, listataan kaikki): kk

 jukka
  osoite: korsontie vantaa
  ei puhelinta

 pekka
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

komento: 7
hakusana (jos tyhj&auml;, listataan kaikki): vantaa

 jukka
  osoite: korsontie vantaa
  ei puhelinta

komento: 7
hakusana (jos tyhj&auml;, listataan kaikki): seppo
 ei l&ouml;ytynyt

komento: 6
kenet: jukka

komento: 5
kenen: jukka
  ei l&ouml;ytynyt

komento: x
</pre>
		<p>Huomioita:</p>
		<ul>
			<li>
				Testien kannalta on oleellista ett&auml; <em>k&auml;ytt&ouml;liittym&auml;</em> toimii kuten yll&auml; olevassa esimerkiss&auml;. Sovellus voi itse p&auml;&auml;tt&auml;&auml; kuinka ep&auml;kelvot sy&ouml;tteet k&auml;sitell&auml;&auml;n. Testit sis&auml;lt&auml;v&auml;t vaan kelvollisia sy&ouml;tteit&auml;.</li>
			<li>
				<em><strong>Ohjelman tulee k&auml;ynnisty&auml; kun teht&auml;v&auml;pohjassa oleva main-metodi suoritetaan, teht&auml;v&auml;ss&auml; saa luoda vain yhden Scanner-olion.</strong></em></li>
			<li>
				Yksinkertaisuuden vuoksi oletetaan ett&auml; nimi on yksitt&auml;inen merkkijono, eli jos halutaan sukunimen mukaan aakkostetun tulostus viimeiseen toimintoon , nimi on annettava muodossa <em>mikkola pekka</em>.</li>
			<li>
				Henkil&ouml;ll&auml; voi olla useita puhelinnumeroja sek&auml; osoite. Henkil&ouml;ll&auml; ei kuitenkaan ole v&auml;ltt&auml;m&auml;tt&auml; yht&auml;&auml;n puhelinnumeroa tai osoite ei ole tiedossa.</li>
			<li>
				Jos henkil&ouml; poistetaan, ei mik&auml;&auml;n haku saa en&auml;&auml; palauttaa henkil&ouml;n tietoja.</li>
		</ul>
	</div>
</div>
<!--
<hr />Viikko 3 loppuu<hr />
--><!--

VK4:

- try - catch - finally
- Perintä
- Abstrakti luokka
- Polymorfismi

- Testit & Annotaatiot

-->
<div class="week" data-week-number="10">
	<h2>
		Olioiden monimuotoisuus</h2>
	<p>Olemme aiemmissa kappaleissa t&ouml;rm&auml;nneet tilanteisiin, joissa muuttujilla on oman tyyppins&auml; lis&auml;ksi muita tyyppej&auml;. Esimerkiksi kappaleessa <a href="#45">45</a> huomasimme ett&auml; <em>kaikki</em> oliot ovat tyyppi&auml; <code>Object</code>. Jos olio on jotain tietty&auml; tyyppi&auml;, esimerkiksi <code>Object</code>, voidaan se my&ouml;s esitt&auml;&auml; <code>Object</code>-tyyppisen&auml; muuttujana. Esimerkiksi <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a></code>on my&ouml;s tyyppi&auml; <code>Object</code>, joten kaikki <code>String</code>-tyyppiset muuttujat voidaan esitell&auml; <code>Object</code>tyypin avulla.</p>
	<pre class="sh_java">
    String merkkijono = &quot;merkkijono&quot;;
    Object merkkijonoString = &quot;toinen merkkijono&quot;;
</pre>
	<p>Merkkijono-olion asettaminen <code>Object</code>-tyyppiseen viitteeseen onnistuu.</p>
	<pre class="sh_java">
    String merkkijono = &quot;merkkijono&quot;;
    Object merkkijonoString = merkkijono;
</pre>
	<p>Toiseen suuntaan asettaminen ei onnistu. Koska <code>Object</code>-tyyppiset muuttujat eiv&auml;t ole tyyppi&auml; <code>String</code>, ei object-tyyppist&auml; muuttujaa voi asettaa <code>String</code>-tyyppiseen muuttujaan.</p>
	<pre class="sh_java">
    Object merkkijonoString = &quot;toinen merkkijono&quot;;
    String merkkijono = merkkijonoString; // EI ONNISTU!
</pre>
	<p>Mist&auml; t&auml;ss&auml; oikein on kyse?</p>
	<p>Muuttujilla on oman tyyppins&auml; lis&auml;ksi aina perimiens&auml; luokkien ja toteuttamiensa rajapintojen tyypit. Luokka <code>String</code>perii <code>Object</code>-luokan, joten <code>String</code>-oliot ovat aina my&ouml;s tyyppi&auml; <code>Object</code>. Luokka <code>Object</code>ei peri <code>String</code>-luokkaa, joten <code>Object</code>-tyyppiset muuttujat eiv&auml;t ole automaattisesti tyyppi&auml; <code>String</code>. Tutustutaan tarkemmin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</a></code>-luokan API-dokumentaatioon, erityisesti HTML-sivun yl&auml;osaan.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/perinta/string-api.png" /></p>
	<p>String-luokan API-dokumentaatio alkaa yleisell&auml; otsakkeella jota seuraa luokan pakkaus (<code>java.lang</code>). Pakkauksen j&auml;lkeen tulee luokan nimi (<code>Class String</code>), jota seuraa luokan <em>perint&auml;hierarkia</em>.</p>
	<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</a>
  </pre>
	<img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/perinta/perinta.gif" /><strong>java.lang.String</strong>
	<p>Perint&auml;hierarkia listaa luokat, jotka luokka on perinyt. Perityt luokat listataan perimisj&auml;rjestyksess&auml;, tarkasteltava luokka aina alimpana. String-luokan perint&auml;hierarkiasta n&auml;emme, ett&auml; <code>String</code>-luokka perii luokan <code>Object</code>. <em>Javassa jokainen luokka voi peri&auml; korkeintaan yhden luokan</em>, mutta v&auml;lillisesti niit&auml; voi peri&auml; useampia.</p>
	<p>Perint&auml;hierarkiaa voi ajatella my&ouml;s listana tyypeist&auml;, joita olio toteuttaa.</p>
	<p>Se, ett&auml; kaikki oliot ovat tyyppi&auml; <code>Object</code>helpottaa ohjelmointia. Jos tarvitsemme metodissa vain <code>Object</code>-luokassa m&auml;&auml;riteltyj&auml; toimintoja, voimme k&auml;ytt&auml;&auml; metodin parametrina tyyppi&auml; <code>Object</code>. Koska kaikki oliot ovat my&ouml;s tyyppi&auml; object, voi metodille antaa <em>mink&auml; tahansa</em> olion parametrina. Luodaan metodi <code>tulostaMonesti</code>, joka saa parametrinaan <code>Object</code>-tyyppisen muuttujan ja tulostusten lukum&auml;&auml;r&auml;n.</p>
	<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</pre>
	<p>Metodille <code>tulostaMonesti</code>voi antaa parametrina mink&auml; tahansa olion. Metodin <code>tulostaMonesti</code>sis&auml;ss&auml; oliolla on k&auml;yt&ouml;ss&auml;&auml;n vain <code>Object</code>-luokassa m&auml;&auml;ritellyt metodit koska olio <em>esitell&auml;&auml;n</em> metodissa <code>Object</code>-tyyppisen&auml;.</p>
	<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String merkkijono = &quot; o &quot;;
    List&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
    sanat.add(&quot;polymorfismi&quot;);
    sanat.add(&quot;perint&auml;&quot;);
    sanat.add(&quot;kapselointi&quot;);
    sanat.add(&quot;abstrahointi&quot;);

    tulostin.tulostaMonesti(merkkijono, 2);
    tulostin.tulostaMonesti(sanat, 3);
</pre>
	<pre>
 o
 o
[polymorfismi, perint&auml;, kapselointi, abstrahointi]
[polymorfismi, perint&auml;, kapselointi, abstrahointi]
[polymorfismi, perint&auml;, kapselointi, abstrahointi]
</pre>
	<div class="tehtavat">
		<h3>
			Olioiden samuus</h3>
		<p>Kaikki oliot ovat tyyppi&auml; <code>Object</code>, joten mink&auml; tahansa tyyppisen olion voi antaa parametrina <code>Object</code>-tyyppisi&auml; parametreja vastaanottavalle metodille.</p>
		<p>Teht&auml;v&auml;n mukana tulee rajapinta <code>Vertaaja</code>. Toteuta pakkaukseen <code>samuus</code>luokka <code>OlioidenVertaaja</code>, joka toteuttaa rajapinnan <code>Vertaaja</code>. Metodien tulee toimia seuraavasti:</p>
		<ul>
			<li>
				<font size="-1"><strong>public boolean samaOlio(Object o1, Object o2)</strong> metodi palauttaa true, mik&auml;li parametrina saatujen olioiden viitteet ovat samat, muutoin metodi palauttaa false. Olioiden viitteiden samuutta vertaillaan &quot;==&quot;-ilmaisulla.</font></li>
			<li>
				<font size="-1"><strong>public boolean vastaavat(Object o1, Object o2)</strong> metodi palauttaa true, mik&auml;li parametrina saadut oliot ovat samanlaiset. Muutoin metodi palauttaa false. K&auml;yt&auml; t&auml;ss&auml; vertailussa <code>equals</code>-metodia. Tarkemmin <code>equals</code>-metodin toiminnasta <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)">Javan Object luokan APIsta</a>. Huomaa, ett&auml; <code>equals</code>-metodin toiminta riippuu siit&auml;, onko verrattavan olion luokka korvannut <code>Object</code>-luokassa m&auml;&auml;ritellyn <code>equals</code>-metodin. </font></li>
			<li>
				<font size="-1"><strong>public boolean samaMerkkijonoEsitys(Object o1, Object o2)</strong> metodi palauttaa true, mik&auml;li parametrina saatujen olioiden merkkijonoesitykset (metodin <code>toString</code>-palauttamat merkkijonot) ovat samat. Muutoin metodi palauttaa false.</font></li>
		</ul>
		<p>Teht&auml;v&auml;n mukana tulee luokka <code>Henkilo</code>, jossa <code>equals</code>- ja <code>compareTo</code>-metodit on korvattu. Kokeile toteuttamiesi metodien toimintaa seuraavalla esimerkkikoodilla.</p>
		<pre class="sh_java">
   OlioidenVertaaja vertaaja = new OlioidenVertaaja();
   Henkilo henkilo1 = new Henkilo(&quot;221078-123X&quot;, &quot;Pekka&quot;, &quot;Helsinki&quot;);
   Henkilo henkilo2 = new Henkilo(&quot;221078-123X&quot;, &quot;Pekka&quot;, &quot;Helsinki&quot;);  // t&auml;ysin samansis&auml;lt&ouml;inen kuin eka
   Henkilo henkilo3 = new Henkilo(&quot;110934-123X&quot;, &quot;Pekka&quot;, &quot;Helsinki&quot;);  // eri pekka vaikka asuukin helsingiss&auml;

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo1));
   System.out.println(vertaaja.samaOlio(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo3));
   System.out.println(vertaaja.samaMerkkijonoEsitys(henkilo1, henkilo2));

   Henkilo henkilo4 = new Henkilo(&quot;221078-123X&quot;, &quot;Pekka&quot;, &quot;Savonlinna&quot;); // henkilo1:n pekka mutta asuinpaikka muuttuu

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo4));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo4));
   System.out.println(vertaaja.samaMerkkijonoEsitys(henkilo1, henkilo4));
</pre>
		<p>Yll&auml;olevan koodin tulostuksen pit&auml;isi olla seuraava:</p>
		<pre>
true
false
true
false
true
false
true
false
</pre>
	</div>
	<h3>
		Monimuotoisuus ja rajapinnat</h3>
	<p>Jatketaan <code>String</code>-luokan API-kuvauksen tarkastelua. Kuvauksessa olevaa perint&auml;hierarkiaa seuraa listaus luokan toteuttamista rajapinnoista.</p>
	<pre>
<strong>All Implemented Interfaces:</strong>
  <a href="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" title="interface in java.io">Serializable</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" title="class in java.lang">String</a>&gt;
</pre>
	<p>Luokka <code>String</code>toteuttaa rajapinnat <code>Serializable</code>, <code>CharSequence</code>, ja <code>Comparable&lt;String&gt;</code>. My&ouml;s rajapinta on tyyppi. Luokan String API-kuvauksen mukaan String-olion tyypiksi voi asettaa seuraavat rajapinnat.</p>
	<pre class="sh_java">
    Serializable serializableString = &quot;merkkijono&quot;;
    CharSequence charSequenceString = &quot;merkkijono&quot;;
    Comparable&lt;String&gt; comparableString = &quot;merkkijono&quot;;
</pre>
	<p>Koska metodeille voidaan m&auml;&auml;ritell&auml; metodin parametrin tyyppi, voimme m&auml;&auml;ritell&auml; metodeja jotka vastaanottavat <em>tietyn rajapinnan toteuttavan</em> olion. Kun metodille m&auml;&auml;ritell&auml;&auml;n parametrina rajapinta, sille voidaan antaa parametrina mik&auml; tahansa olio joka toteuttaa kyseisen rajapinnan -- metodi ei v&auml;lit&auml; olion oikeasta tyypist&auml;.</p>
	<p>T&auml;ydennet&auml;&auml;n <code>Tulostin</code>-luokkaa siten, ett&auml; sill&auml; on metodi <code>CharSequence</code>-rajapinnan toteuttavien olioiden merkkien tulostamiseen. Rajapinta <code>CharSequence</code>tarjoaa muunmuassa metodit <code>int length()</code>, jolla saa merkkijonon pituuden, ja <code>char charAt(int index)</code>, jolla saa merkin tietyss&auml; indeksiss&auml;.</p>
	<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }

    public void tulostaMerkit(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</pre>
	<p>Metodille <code>tulostaMerkit</code>voi antaa mink&auml; tahansa <code>CharSequence</code>-rajapinnan toteuttavan olion. N&auml;it&auml; on muunmuassa <code>String</code>ja <code>StringBuilder</code>. Metodi <code>tulostaMerkit</code>tulostaa annetun olion jokaisen merkin omalle rivilleen.</p>
	<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    StringBuilder sb = new StringBuilder();
    sb.append(&quot;toimii&quot;);

    tulostin.tulostaMerkit(sb);
</pre>
	<pre>
t
o
i
m
i
i
</pre>
	<div class="tehtavat">
		<h3>
			Joukkoja</h3>
		<p>Teht&auml;v&auml;n mukana tulee siirtymistoiminnallisuutta kuvaava rajapinta <code>Siirrettava</code>. Teht&auml;v&auml;ss&auml; toteutat luokat <code>Olio</code>ja <code>Lauma</code>, jotka molemmat ovat siirrett&auml;vi&auml;. Toteuta kaikki toiminnallisuus pakkaukseen <code>siirrettava</code>.</p>
		<h4>
			Olio -luokan toteuttaminen</h4>
		<p>Luo pakkaukseen <code>siirrettava</code>luokka <code>Olio</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Olion tulee tiet&auml;&auml; oma sijaintinsa (ilmaistaan x, y -koordinaatteina. Luokan <code>Olio</code>APIn tulee olla seuraava:</p>
		<ul>
			<li>
				<font size="-1"><strong>public Olio(int x, int y)</strong><br />
				Luokan konstruktori, joka saa olion aloitussijainnin x- ja y-koordinaatit parametrina</font></li>
			<li>
				<font size="-1"><strong>public String toString()</strong><br />
				Luo ja palauttaa oliosta merkkijonoesityksen. Olion merkkijonoesityksen tulee olla seuraavanlainen <code>"x: 3; y: 6"</code>. Huomaa ett&auml; koordinaatit on erotettu puolipisteell&auml; (<code>;</code>)</font></li>
			<li>
				<font size="-1"><strong>public void siirra(int dx, int dy)</strong><br />
				Siirt&auml;&auml; oliota parametrina saatujen arvojen verran. Muuttuja <code>dx</code>sis&auml;lt&auml;&auml; muutoksen koordinaattiin <code>x</code>, muuttuja <code>dy</code>sis&auml;lt&auml;&auml; muutoksen koordinaattiin <code>y</code>. Esimerkiksi jos muuttujan <code>dx</code>arvo on 5, tulee oliomuuttujan <code>x</code>arvoa kasvattaa viidell&auml;</font></li>
		</ul>
		<p>Kokeile luokan <code>Olio</code>toimintaa seuraavalla esimerkkikoodilla.</p>
		<pre class="sh_java">
     Olio olio = new Olio(20, 30);
     System.out.println(olio);
     olio.siirra(-10, 5);
     System.out.println(olio);
     olio.siirra(50, 20);
     System.out.println(olio);
</pre>
		<pre>
x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</pre>
		<h4>
			Lauman toteutus</h4>
		<p>Luo seuraavaksi pakkaukseen <code>siirrettava</code>luokka <code>Lauma</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Lauma koostuu useasta <code>Siirrettava</code>-rajapinnan toteutavasta oliosta, jotka tulee tallettaa esimerkiksi listarakenteeseen.</p>
		<p>Luokalla <code>Lauma</code>tulee olla seuraavanlainen API.</p>
		<ul>
			<li>
				<font size="-1"><strong>public String toString()</strong><br />
				Palauttaa merkkijonoesityksen lauman j&auml;senten sijainnista riveill&auml; erotettuna.</font></li>
			<li>
				<font size="-1"><strong>public void liitaLaumaan(Siirrettava siirrettava)</strong><br />
				Lis&auml;&auml; laumaan uuden <code>Siirrettava</code>-rajapinnan toteuttavan olion</font></li>
			<li>
				<font size="-1"><strong>public void siirra(int dx, int dy)</strong><br />
				Siirt&auml;&auml; laumaa parametrina saatujen arvojen verran. Huomaa ett&auml; t&auml;ss&auml; sinun tulee siirt&auml;&auml; jokaista lauman j&auml;sent&auml;.</font></li>
		</ul>
		<p>Kokeile ohjelmasi toimintaa alla olevalla esimerkkikoodilla.</p>
		<pre class="sh_java">
    Lauma lauma = new Lauma();
    lauma.liitaLaumaan(new Olio(73, 56));
    lauma.liitaLaumaan(new Olio(57, 66));
    lauma.liitaLaumaan(new Olio(46, 52));
    lauma.liitaLaumaan(new Olio(19, 107));
    System.out.println(lauma);
</pre>
		<pre>
x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</pre>
	</div>
	<h3>
		Olion tyyppi m&auml;&auml;r&auml;&auml; kutsutun metodin: Polymorfismi</h3>
	<p>Olion k&auml;yt&ouml;ss&auml; olevat metodit m&auml;&auml;rittyv&auml;t muuttujan tyypin kautta. Esimerkiksi <code>String</code>-tyyppinen olio, joka on esitelty <code>Object</code>-tyyppisen&auml; saa k&auml;ytt&ouml;&ouml;ns&auml; vain <code>Object</code>-luokassa m&auml;&auml;ritellyt metodit. Jos oliolla on monta eri tyyppi&auml;, on sill&auml; k&auml;yt&ouml;ss&auml; <em>jokaisen</em> tyypin m&auml;&auml;rittelem&auml;t metodit. Esimerkiksi <code>String</code>-tyyppisell&auml; oliolla on k&auml;yt&ouml;ss&auml; <code>String</code>-luokassa m&auml;&auml;ritellyt metodit, <code>Object</code>-luokassa m&auml;&auml;ritellyt metodit, ja toteutettujen rajapintojen m&auml;&auml;rittelem&auml;t metodit.</p>
	<p>Edellisess&auml; teht&auml;v&auml;ss&auml; toteutettiin metodi <code>samaMerkkijonoEsitys</code>kahden olion tulostuksen vertailuun. Metodille annetaan parametrina kaksi <code>Object</code>-tyyppist&auml; muuttujaa, joiden <code>toString</code>-metodin tuottamia tulostuksia vertaillaan. Koska parametrit ovat tyyppi&auml; <code>Object</code>, voi metodille antaa parametrina mink&auml; tahansa olion. Laajennetaan <code>Tulostin</code>-luokkaa esimerkki&auml; varten.</p>
	<pre class="sh_java">
public class Tulostin {
    private String merkki;

    public Tulostin(String merkki) {
        this.merkki = merkki;
    }

    public void tulostaMonesti(Object object, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }

    public void tulostaMerkit(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }

    @Override
    public String toString() {
        return this.merkki;
    }
}
</pre>
	<p>Luokan <code>Tulostaja</code><code>toString</code>-metodi palauttaa siis aina konstruktorissa annetun parametrin. Edellisess&auml; teht&auml;v&auml;ss&auml; toteutetun <code>samaMerkkijonoEsitys</code>-metodin toteutus on kutakuinkin seuraava.</p>
	<pre class="sh_java">
    public boolean samaMerkkijonoEsitys(Object eka, Object toka) {
        return eka.toString().equals(toka.toString());
    }
</pre>
	<pre class="sh_java">
    OlioidenVertaaja vertaaja = new OlioidenVertaaja();

    String merkkijono = &quot;tulostuksen vertailu&quot;;
    CharSequence merkkijonoSeq = &quot;tulostuksen vertailu&quot;;

    if (vertaaja.samaMerkkijonoEsitys(merkkijono, merkkijonoSeq)) {
        System.out.println(&quot;Vertailu 1. Sama merkkijonoesitys&quot;);
    } else {
        System.out.println(&quot;Vertailu 1. Eri merkkijonoesitys&quot;);
    }

    Tulostin tulostin = new Tulostin(&quot;Cannon&quot;);
    if (vertaaja.samaMerkkijonoEsitys(merkkijono, tulostin)) {
        System.out.println(&quot;Vertailu 2. Sama merkkijonoesitys&quot;);
    } else {
        System.out.println(&quot;Vertailu 2. Eri merkkijonoesitys&quot;);
    }
</pre>
	<pre>
Vertailu 1. Sama merkkijonoesitys
Vertailu 2. Eri merkkijonoesitys
</pre>
	<p>Ensimm&auml;isess&auml; vertailussa metodille <code>samaMerkkijonoEsitys</code>annetaan parametrina <code>String</code>- ja <code>CharSequence</code>-tyyppiset muuttujat. Toisessa esimerkiss&auml; parametrina annetaan <code>String</code>- ja <code>Tulostin</code>-tyyppiset muuttujat. Metodin <code>samaMerkkijonoEsitys</code>parametrit ovat <code>Object</code>-tyyppisi&auml;, ja metodissa voi k&auml;ytt&auml;&auml; vain <code>Object</code>-luokassa m&auml;&auml;riteltyj&auml; metodeja.</p>
	<p>Kysymykseksi nousee <em>Eik&ouml; metodin <code>samaMerkkijonoEsitys</code>pit&auml;isi k&auml;ytt&auml;&auml; <code>Object</code>-luokassa m&auml;&auml;ritelty&auml; <code>toString</code>-metodia, jolloin metodin palauttaman merkkijonon pit&auml;isi olla muotoa <code>pakkaus.Luokannimi@...</code>?</em></p>
	<p><em>Vastaus on ei.</em> Suoritettava metodi valitaan <em>olion</em> tyypin perusteella, ei muuttujan tyypin perusteella. Vaikka metodissa <code>samaMerkkijonoEsitys</code>k&auml;ytet&auml;&auml;n <code>Object</code>-tyyppisi&auml; muuttujia, voidaan metodille antaa parametrina mink&auml; tahansa tyyppisi&auml; olioita. Jos olion luokka (tai joku sen perim&auml; luokka) korvaa metodin <code>toString</code>, valitaan k&auml;ytt&ouml;&ouml;n aina korvaava metodi <code>Object</code>-luokassa m&auml;&auml;ritellyn sijaan.</p>
	<p>Hieman yleisemmin: <em>Suoritettava metodi valitaan aina olion perusteella riippumatta k&auml;ytetyn muuttujan tyypist&auml;. Oliot ovat monimuotoisia, eli olioita voi k&auml;ytt&auml;&auml; usean eri muuttujatyypin kautta. Suoritettava metodi liittyy aina olion todelliseen tyyppiin.</em> T&auml;t&auml; monimuotoisuutta kutsutaan polymorfismiksi.</p>
	<h2>
		Tallennustoiminnallisuuden eriytt&auml;minen</h2>
	<p>Ohjelmia rakennettaessa k&auml;ytet&auml;&auml;n usein ohjelmarakennetta, jossa tiedon tallennusmekanismi kapseloidaan sovelluslogiikalta n&auml;kym&auml;tt&ouml;m&auml;ksi. Tallennustoiminnallisuuden piilottaminen sovelluslogiikalta perustellaan Single Responsibility Principle -periaatteella. Jokaisella luokalla tulee olla vain yksi syy muuttua: jos sovelluslogiikkaa tarjoava luokka hoitaisi sovelluslogiikan lis&auml;ksi tiedon tallentamiseen liittyv&auml;&auml; toiminnallisuutta, olisi sill&auml; jo ainakin kaksi vastuuta ja syyt&auml; muuttua: sovelluslogiikassa tapahtuva muutos ja tallennuslogiikassa tapahtuva muutos. T&auml;m&auml; rikkoo Single Responsibility Principle -periatteen. Haluamme ett&auml; tallennukseen liittyv&auml; toiminnallisuus toteutetaan sovelluslogiikasta erillisen&auml;.</p>
	<p>Yleisin tapa tallennuslogiikan eriytt&auml;miseen on ns. DAO-suunnittelumalli. DAO-suunnittelumallissa tallennuslogiikan k&auml;ytt&auml;j&auml;lle tarjotaan rajapinta, jossa on m&auml;&auml;ritelty toiminnallisuudet luomiseen, hakemiseen, p&auml;ivitt&auml;miseen ja poistamiseen. Kunkin DAO-rajapinnan toteuttan vastuulla on yleens&auml; aina tietyntyyppisten olioiden tallentaminen. K&auml;ytet&auml;&auml;n seuraavassa esimerkiss&auml; luokkaa <code>Henkilo</code>, jolla on oliomuuttuja nimi ja henkil&ouml;n yksil&ouml;iv&auml; henkil&ouml;tunnus.</p>
	<pre class="sh_java">
public class Henkilo {

    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getHenkilotunnus() {
        return henkilotunnus;
    }

    public String getNimi() {
        return nimi;
    }
}
</pre>
	<p>Haluamme tallentaa henkil&ouml;it&auml;. M&auml;&auml;ritell&auml;&auml;n <code>Henkilo</code>-luokan ilmentymien tallentamiseen liittyv&auml; DAO-rajapinta, joka m&auml;&auml;rittelee toiminnallisuudet tallentamiseen, hakemiseen, ja poistamiseen.</p>
	<pre class="sh_java">
import java.util.Collection;

public interface HenkiloDAO {
    void talleta(Henkilo henkilo);
    Henkilo hae(String henkilotunnus);

    void poista(Henkilo henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Henkilo&gt; haeKaikki();
}
</pre>
	<p>Ohjelmoidessa l&auml;hdemme yleens&auml; pienest&auml; liikkelle. Luodaan rajapinnalle ensimm&auml;inen toteutus, jossa tallennetaan vain yksi henkil&ouml;. Luokka <code>YksinkertainenHenkiloDAO</code>tarjoaa konkreettista toiminnallisuutta vain osaan rajapinnan <code>HenkiloDAO</code>m&auml;&auml;rittelemist&auml; metodeista.</p>
	<pre class="sh_java">
import java.util.ArrayList;
import java.util.Collection;

public class YksinkertainenHenkiloDAO implements HenkiloDAO {

    private Henkilo henkilo;

    @Override
    public void talleta(Henkilo henkilo) {
        this.henkilo = henkilo;
    }

    @Override
    public Henkilo hae(String henkilotunnus) {
        return this.henkilo;
    }

    @Override
    public void poista(Henkilo henkilo) {
        this.henkilo = null;
    }

    @Override
    public void poista(String henkilotunnus) {
        this.henkilo = null;
    }

    @Override
    public void poistaKaikki() {
        this.henkilo = null;
    }

    @Override
    public Collection&lt;Henkilo&gt; haeKaikki() {
        Collection&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;();
        if (this.henkilo != null) {
            henkilot.add(this.henkilo);
        }

        return henkilot;
    }
}
</pre>
	<p>Yll&auml; oleva HenkiloDAO-rajapinnan toteutus k&auml;sittelee vain yht&auml; Henkilo-olioa.</p>
	<p><em>Mik&auml; t&auml;ss&auml; on nyt niin hienoa?</em></p>
	<p>Kuvittele seuraava ohjelmoinnissa usein eteen tuleva tilanne. Kehit&auml;t useammasta luokasta koostuvaa ohjelmistoa ja haluat testata olioiden yhteistoiminnallisuutta ennen kuin koko ohjelma on valmis. K&auml;ytt&auml;ess&auml;si rajapintoja voit vaihtaa rajapinnan toteuttavaa luokkaa muuttamatta rajapintaa k&auml;ytt&auml;v&auml;n luokan toiminnallisuutta. T&auml;m&auml; mahdollistaa ohjelman paloittain kehitt&auml;misen: voit aluksi toteuttaa vain pienen osan toiminnallisuudesta, ja testata ohjelman toimintaa sill&auml;. Yll&auml; olevaa tallentajaa voi k&auml;ytt&auml;&auml; esimerkiksi seuraavan k&auml;ytt&ouml;liittym&auml;luokan kautta:</p>
	<pre class="sh_java">
import java.util.Scanner;

public class Kayttoliittyma {

    private Scanner lukija;
    private HenkiloDAO henkiloDao;

    public Kayttoliittyma(Scanner lukija, HenkiloDAO henkiloDao) {
        this.lukija = lukija;
        this.henkiloDao = henkiloDao;
    }

    public void kaynnista() {
        while (true) {
            System.out.println(&quot;Toiminnallisuudet: &quot;);
            System.out.println(&quot;\t1. Lis&auml;&auml; henkil&ouml;&quot;);
            System.out.println(&quot;\t2. Listaa henkil&ouml;t&quot;);
            System.out.println(&quot;\t3. Lopeta&quot;);

            System.out.println(&quot;&quot;);
            System.out.print(&quot;Sy&ouml;t&auml; komento: &quot;);
            int komento = Integer.parseInt(this.lukija.nextLine());
            if (komento == 3) {
                break;
            }
        }
    }

    private void hoidaKomento(int komento) {
        if (komento == 1) {
            lisaaHenkilo();
        } else if (komento == 2) {
            listaaHenkilot();
        }
    }

    private void lisaaHenkilo() {
        System.out.print(&quot;Anna nimi: &quot;);
        String nimi = this.lukija.nextLine();
        System.out.print(&quot;Anna hetu: &quot;);
        String hetu = this.lukija.nextLine();

        this.henkiloDao.talleta(new Henkilo(nimi, hetu));
    }

    private void listaaHenkilot() {
        System.out.println(&quot;Listataan: &quot;);
        for (Henkilo henkilo : this.henkiloDao.haeKaikki()) {
            System.out.println(&quot;\t&quot; + henkilo.getNimi());
        }
    }
}
</pre>
	<p>K&auml;ytt&ouml;liittym&auml;ss&auml; tarjotaan toiminnallisuus vain lis&auml;&auml;miseen ja listaamiseen. Huomaa ett&auml; miss&auml;&auml;n p&auml;in k&auml;ytt&ouml;liittym&auml;luokkaa ei mainita luokkaa <code>YksinkertainenHenkiloDAO</code>. Henkil&ouml;iden lis&auml;&auml;minen ja listaaminen tapahtuu <code>HenkiloDAO</code>-rajapinnan kautta. K&auml;ytt&ouml;liittym&auml;n k&auml;ynnist&auml;v&auml;ss&auml; luokassa annetaan k&auml;ytt&ouml;liittym&auml;lle <code>HenkiloDAO</code>-rajapinnan toteuttava luokka.</p>
	<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    HenkiloDAO henkiloDao = new YksinkertainenHenkiloDAO();

    Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija, henkiloDao);
    kayttoliittyma.kaynnista();
</pre>
	<p>Kun sovellukseen toteutettu pieni osa toimii hyvin, voidaan HenkiloDAO-rajapinnan toteutusta laajentaa tai sille voidaan luoda uusi toteutus. Luodaan seuraavaksi hajautustaulua k&auml;ytt&auml;v&auml; toteutus <code>MuistiHenkiloDAO</code>. Hajautustaulua k&auml;ytt&auml;v&auml;ss&auml; toteutuksessa henkil&ouml;t tallennetaan hajautustaulun arvoina siten, ett&auml; avaimena k&auml;ytet&auml;&auml;n henkil&ouml;n henkil&ouml;tunnusta.</p>
	<pre class="sh_java">
public class MuistiHenkiloDAO implements HenkiloDAO {
    private Map&lt;String, Henkilo&gt; henkilot;

    public MuistiHenkiloDAO() {
        this.henkilot = new HashMap&lt;String, Henkilo&gt;();
    }

    @Override
    public void talleta(Henkilo henkilo) {
        this.henkilot.put(henkilo.getHenkilotunnus(), henkilo);
    }

    @Override
    public Henkilo hae(String henkilotunnus) {
        return this.henkilot.get(henkilotunnus);
    }

    @Override
    public void poista(Henkilo henkilo) {
        poista(henkilo.getHenkilotunnus());
    }

    @Override
    public void poista(String henkilotunnus) {
        this.henkilot.remove(henkilotunnus);
    }

    @Override
    public void poistaKaikki() {
        this.henkilot.clear();
    }

    @Override
    public Collection&lt;Henkilo&gt; haeKaikki() {
        return this.henkilot.values();
    }
}
</pre>
	<p>Huomaa ett&auml; k&auml;ytt&ouml;liittym&auml;luokan koodiin ei tarvitse koskea. K&auml;ytt&ouml;liittym&auml;ss&auml; k&auml;ytetyn <code>HenkiloDAO</code>-rajapinnan toteuttavan luokan vaihto tapahtuu helposti:</p>
	<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    HenkiloDAO henkiloDao = <strong>new MuistiHenkiloDAO();</strong>

    Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija, henkiloDao);
    kayttoliittyma.kaynnista();
</pre>
	<p>Rajapintojen k&auml;ytt&auml;minen ohjelmoinnissa, jonka erityistapaus juuri esitelty tallennuslogiikan l&auml;hestymistapa on, on mahtava tapa helpottaa ohjelman osatoiminnallisuuksien testaamista yhdess&auml;. L&auml;hestymistavan vahvuus tulee erityisesti esiin silloin, kun ohjelmaa on rakentamassa useampi ihminen samaan aikaan.</p>
	<div class="tehtavat">
		<h3>
			Data Access Object (DAO)</h3>
		<p>Harjoitellaan seuraavaksi Data Access Object-suunnittelumallia ja kerrataan tiedostojen k&auml;ytt&ouml;&auml;. T&auml;ss&auml; teht&auml;v&auml;ss&auml; toteutetaan valmiiksi annetusta <code>AlbumiDAO</code>-rajapinnasta kaksi erilaista toteutusta. Rajapinta m&auml;&auml;rittelee seuraavat toiminnot:</p>
		<ul>
			<li>
				<font size="-1"><strong>void talleta(Albumi albumi)</strong><br />
				Tallettaa annetun albumin rajapinnan toteutuksen edellytt&auml;m&auml;ll&auml; tavalla</font></li>
			<li>
				<font size="-1"><strong>Albumi hae(int id)</strong><br />
				Hakee annettua ID:t&auml; vastaavan albumin ja palauttaa sen - jos vastaavaa albumia ei l&ouml;ydy, palautetaan <code>null</code>-viite</font></li>
			<li>
				<font size="-1"><strong>void poista(Albumi albumi)</strong><br />
				Poistaa annetun albumin ID:t&auml; vastaavan albumin</font></li>
			<li>
				<font size="-1"><strong>void poista(int id)</strong><br />
				Poistaa annettua ID:t&auml; vastaavan albumin</font></li>
			<li>
				<font size="-1"><strong>void poistaKaikki()</strong><br />
				Poistaa kaikki albumit</font></li>
			<li>
				<font size="-1"><strong>Collection&lt;Albumi&gt; haeKaikki()</strong><br />
				Palauttaa kaikki talletetut albumit</font></li>
		</ul>
		<p>Rajapinnan koodi:</p>
		<pre class="sh_java">
package dao;

import java.util.Collection;

public interface AlbumiDAO {
    void talleta(Albumi albumi);
    Albumi hae(int id);

    void poista(Albumi albumi);
    void poista(int id);
    void poistaKaikki();

    Collection&lt;Albumi&gt; haeKaikki();
}
</pre>
		<p>Rajapinta k&auml;sittelee <code>Albumi</code>-olioita, joiden toteutus on seuraavanlainen:</p>
		<pre class="sh_java">
package dao;

public class Albumi {
    private int id;
    private String artisti;
    private String nimi;
    private int julkaisuVuosi;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getArtisti() {
        return artisti;
    }

    public void setArtisti(String artisti) {
        this.artisti = artisti;
    }

    public String getNimi() {
        return nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }

    public int getJulkaisuVuosi() {
        return julkaisuVuosi;
    }

    public void setJulkaisuVuosi(int julkaisuVuosi) {
        this.julkaisuVuosi = julkaisuVuosi;
    }

    @Override
    public String toString() {
        return id + &quot;: &quot; + artisti + &quot; - &quot; + nimi + &quot; (&quot; + julkaisuVuosi + &quot;)&quot;;
    }
}
</pre>
		<h4>
			Muistiin tallettava DAO-toteutus</h4>
		<p>Teht&auml;v&auml;n&auml;si on toteuttaa luokka <code>MuistiAlbumiDAO</code>, joka toteuttaa rajapinnan <code>AlbumiDAO</code>siten, ett&auml; albumeita talletetaan muistiin.</p>
		<p><b>Vinkki:</b> <code>Map</code>-rajapinnan toteuttavasta tietorakenteesta on hy&ouml;ty&auml; t&auml;ss&auml; teht&auml;v&auml;ss&auml;.</p>
		<p>Toteutusta voi k&auml;ytt&auml;&auml; esimerkiksi n&auml;in:</p>
		<pre class="sh_java">
        AlbumiDAO dao = new MuistiAlbumiDAO();

        Albumi albumi = new Albumi();
        albumi.setId(4);
        albumi.setArtisti(&quot;Porcupine Tree&quot;);
        albumi.setNimi(&quot;Deadwing&quot;);
        albumi.setJulkaisuVuosi(2005);

        dao.talleta(albumi);

        System.out.println(&quot;Albumi ID-numerolla 4: &quot; + dao.hae(4));

        Albumi albumi2 = new Albumi();
        albumi2.setId(137);
        albumi2.setArtisti(&quot;Flying Colors&quot;);
        albumi2.setNimi(&quot;Flying Colors&quot;);
        albumi2.setJulkaisuVuosi(2012);

        dao.talleta(albumi2);

        System.out.println(&quot;Kaikki talletetut albumit: &quot; + dao.haeKaikki());

        dao.poista(4);

        System.out.println(&quot;Kaikki talletetut albumit: &quot; + dao.haeKaikki());

        dao.poista(albumi2);

        System.out.println(&quot;Kaikki talletetut albumit: &quot; + dao.haeKaikki());
</pre>
		<p>Yll&auml;oleva esimerkkiohjelma tulostaa: (albumien j&auml;rjestys saattaa vaihdella)</p>
		<pre>
Albumi ID-numerolla 4: 4: Porcupine Tree - Deadwing (2005)
Kaikki talletetut albumit: [137: Flying Colors - Flying Colors (2012), 4: Porcupine Tree - Deadwing (2005)]
Kaikki talletetut albumit: [137: Flying Colors - Flying Colors (2012)]
Kaikki talletetut albumit: []
</pre>
		<h4>
			CSV-tiedostomuodon k&auml;sittely&auml;</h4>
		<p>Kertaa t&auml;ss&auml; vaiheessa kappale <a href="#53">53. Tiedostojen k&auml;sittely</a>.</p>
		<p>CSV (Comma Separated Values) on tiedostomuoto, jossa yht&auml; kokonaisuutta (esim. oliota) vastaa yksi rivi. Rivill&auml; arvot (olioiden kent&auml;t) on eroteltu pilkuilla.</p>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; k&auml;ytetyst&auml; <code>Albumi</code>-olioista on tarkoitus tuottaa seuraavan esimerkin kaltaisia CSV-tiedostoja:</p>
		<p>&nbsp;</p>
		<pre>
4,Porcupine Tree,Deadwing,2005
137,Flying Colors,Flying Colors,2012
</pre>
		<p>Pilkulla erotetut arvot ovat siis: ID, artistin nimi, albumin nimi ja julkaisuvuosi.</p>
		<p><b>Huom:</b> Tilannetta, jossa jokin arvo sis&auml;lt&auml;isi pilkun, ei tarvitse ottaa huomioon.</p>
		<p>Teht&auml;v&auml;n&auml;si on toteuttaa luokka <code>OmaCSVKasittelija</code>, joka toteuttaa rajapinnan <code>CSVKasittelija</code>. Rajapinnassa on seuraavat toiminnot:</p>
		<ul>
			<li>
				<font size="-1"><strong>void talleta(Collection&lt;Albumi&gt; albumit) throws IOException</strong> tallettaa annetut <code>Albumi</code>-oliot tiedostoon</font></li>
			<li>
				<font size="-1"><strong>Map&lt;Integer, Albumi&gt; lataa() throws IOException</strong> lukee tiedoston ja muodostaa siit&auml; <code>Albumi</code>-olioita, joista muodostetaan <code>Map&lt;Integer, Albumi&gt;</code>-rajapinnan toteuttava olio siten, ett&auml; avaimena on albumin ID kokonaislukuna. Metodin tulee palauttaa tyhj&auml; <code>Map</code>-olio, jos tiedostoa ei l&ouml;ydy (OmaCSVKasittelija ei siis saa heitt&auml;&auml; poikkeusta t&auml;ss&auml; tilanteessa).</font></li>
		</ul>
		<p>Luokalla <code>OmaCSVKasittelija</code>on lis&auml;ksi oltava konstruktori, jonka parametrina on k&auml;ytett&auml;v&auml;n tiedoston nimi: <code>public OmaCSVKasittelija(String tiedostonNimi)</code>.</p>
		<p>Rajapinnan koodi:</p>
		<pre class="sh_java">
package dao;

import java.io.IOException;
import java.util.Collection;
import java.util.Map;

public interface CSVKasittelija {
    void talleta(Collection&lt;Albumi&gt; albumit) throws IOException;
    Map&lt;Integer, Albumi&gt; lataa() throws IOException;
}
</pre>
		<p>Luokkaa voi k&auml;ytt&auml;&auml; esimerkiksi n&auml;in:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Albumi albumi = new Albumi();
        albumi.setId(4);
        albumi.setArtisti(&quot;Porcupine Tree&quot;);
        albumi.setNimi(&quot;Deadwing&quot;);
        albumi.setJulkaisuVuosi(2005);

        Albumi albumi2 = new Albumi();
        albumi2.setId(137);
        albumi2.setArtisti(&quot;Flying Colors&quot;);
        albumi2.setNimi(&quot;Flying Colors&quot;);
        albumi2.setJulkaisuVuosi(2012);

        List&lt;Albumi&gt; albumit = new ArrayList&lt;Albumi&gt;();
        albumit.add(albumi);
        albumit.add(albumi2);

        CSVKasittelija csvKasittelija = new OmaCSVKasittelija(&quot;albumit.csv&quot;);

        try {
            csvKasittelija.talleta(albumit);
        } catch (IOException e) {
            System.out.println(&quot;Poikkeus tallettaessa: &quot; + e);
            return;
        }

        Map&lt;Integer, Albumi&gt; ladatutAlbumit;
        try {
            ladatutAlbumit = csvKasittelija.lataa();
        } catch (IOException e) {
            System.out.println(&quot;Poikkeus ladatessa: &quot; + e);
            return;
        }

        System.out.println(&quot;Tiedostosta ladattiin albumit: &quot; + ladatutAlbumit);
    }
</pre>
		<p>Yll&auml;oleva esimerkkiohjelma tulostaa: (albumien j&auml;rjestys saattaa vaihdella)</p>
		<pre>
Tiedostosta ladattiin albumit: {137=137: Flying Colors - Flying Colors (2012), 4=4: Porcupine Tree - Deadwing (2005)}
</pre>
		<p>Muistathan aina sulkea tiedoston tallennuksen lopuksi! T&auml;ll&ouml;in viimeisetkin muutokset p&auml;&auml;tyv&auml;t varmasti tiedostoon.</p>
		<h4>
			CSV-tiedostomuotoon tallettava DAO-toteutus (hitaampi versio)</h4>
		<p>Tee luokka <code>HidasCSVAlbumiDAO</code>, joka toteuttaa <code>AlbumiDAO</code>-rajapinnan. Luokan tulee toimia siten, ett&auml; albumeita <b>ei talleteta muistiin</b>, vaan niit&auml; luetaan tiedostosta ja kirjoitetaan tiedostoon (CSV-muodossa) aina tarvittaessa. Jokaisen talletus- ja hakuoperaation tulee ensin lukea albumit tiedostosta. Jos tiedostoa ei l&ouml;ydy, tai sit&auml; ei saa luettua, tulee olettaa ettei albumeita ole viel&auml; tallennettu. Hy&ouml;dynn&auml; edellisess&auml; teht&auml;v&auml;ss&auml; luotua <code>OmaCSVKasittelija</code>-luokkaa.</p>
		<p>Luokalla <code>HidasCSVAlbumiDAO</code>t&auml;ytyy olla seuraava konstruktori:</p>
		<ul>
			<li>
				<font size="-1"><strong>public HidasCSVAlbumiDAO(CSVKasittelija csvKasittelija)</strong> - luokassa k&auml;ytet&auml;&auml;n talletukseen ja lukemiseen annettua <code>CSVKasittelija</code>-oliota.</font></li>
		</ul>
		<p>Voit k&auml;ytt&auml;&auml; ensimm&auml;isen kohdan esimerkki&auml; testatessa t&auml;t&auml; toteutusta, koska kumpikin toteuttaa saman rajapinnan. Kannattaa avata luotu CSV-tiedosto NetBeansissa ja katsoa mit&auml; ohjelma kirjoitti tiedostoon.</p>
		<h4>
			CSV-tiedostomuotoon tallettava DAO-toteutus (nopeampi versio)</h4>
		<p>Edellisen teht&auml;v&auml;n toteutus on nimens&auml; mukaisesti jokseenkin hidas, koska toteutus &quot;unohtaa&quot; aiemmin haetut tai tallennetut albumit. T&auml;m&auml;n vuoksi albumit joudutaan lukemaan aina uudestaan tiedostosta, mik&auml; on muistiin talletettujen olioiden k&auml;sittelyyn verrattuna moninkertaisesti hitaampaa.</p>
		<p>Tee luokka <code>NopeaCSVAlbumiDAO</code>, joka toteuttaa <code>AlbumiDAO</code>-rajapinnan. Luokan tulee toimia siten, ett&auml; annetun tiedoston sis&auml;lt&ouml; luetaan heti konstruktorissa ja talletetaan muistiin (vastaavalla tavalla kuin <code>MuistiAlbumiDAO</code>). T&auml;ll&ouml;in albumeja haettaessa tiedostoa ei tarvitse (eik&auml; pid&auml;!) lukea ollenkaan. Talletettaessa tai poistettaessa albumeja muutokset pit&auml;&auml; tehd&auml; muistissa oleviin albumeihin sek&auml; tallettaa tiedostoon.</p>
		<p>Luokalla <code>NopeaCSVAlbumiDAO</code>t&auml;ytyy olla seuraava konstruktori:</p>
		<ul>
			<li>
				<font size="-1"><strong>public NopeaCSVAlbumiDAO(CSVKasittelija csvKasittelija)</strong> - luokassa k&auml;ytet&auml;&auml;n talletukseen ja lukemiseen annettua <code>CSVKasittelija</code>-oliota.</font></li>
		</ul>
		<p>Voit k&auml;ytt&auml;&auml; ensimm&auml;isen kohdan esimerkki&auml; testatessa t&auml;t&auml; toteutusta, koska kumpikin toteuttaa saman rajapinnan. Kannattaa avata luotu CSV-tiedosto NetBeansissa ja katsoa mit&auml; ohjelma kirjoitti tiedostoon.</p>
	</div>
	<h2>
		Luokan ominaisuuksien periminen</h2>
	<p>Luokat ovat ohjelmoijan tapa ratkaistavan ongelma-alueen k&auml;sitteiden selkeytt&auml;miseen. Lis&auml;&auml;mme jokaisella luomallamme luokalla uutta toiminnallisuutta ohjelmointikieleen. Toiminnallisuutta tarvitaan kohtaamiemme ongelmien ratkomiseen -- ratkaisut syntyv&auml;t luokista luotujen olioiden v&auml;lisen interaktion avulla. Olio-ohjelmoinnissa olio on itsen&auml;inen kokonaisuus, jolla on olion tarjoamien metodien avulla muutettava tila. Olioita k&auml;ytet&auml;&auml;n yhteisty&ouml;ss&auml;; jokaisella oliolla on oma vastuualue. Esimerkiksi k&auml;ytt&ouml;liittym&auml;luokkamme ovat t&auml;h&auml;n menness&auml; hy&ouml;dynt&auml;neet <code>Scanner</code>-olioita.</p>
	<p>Jokainen Javan luokka perii luokan <code>Object</code>, eli jokainen luomamme luokka saa k&auml;ytt&ouml;&ouml;ns&auml; kaikki <code>Object</code>-luokassa m&auml;&auml;ritellyt metodit. Jos haluamme muuttaa <code>Object</code>-luokassa m&auml;&auml;riteltyjen metodien toiminnallisuutta tulee ne korvata (<code>Override</code>) m&auml;&auml;rittelem&auml;ll&auml; niille uusi toteutus luodussa luokassa.</p>
	<p>Luokan <code>Object</code>perimisen lis&auml;ksi my&ouml;s muiden luokkien periminen on mahdollista. Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" target="_blank">ArrayList</a></code>-luokan APIa tarkasteltaessa huomaamme ett&auml; <code>ArrayList</code>perii luokan <code>AbstractList</code>. Luokka <code>AbstractList</code>perii luokan <code>AbstractCollection</code>, joka perii luokan <code>Object</code>.</p>
	<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</a>
  </pre>
	<img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</a>&lt;E&gt; <img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</a>&lt;E&gt; <img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/perinta/perinta.gif" /><strong>java.util.ArrayList&lt;E&gt;</strong>
	<p>Kukin luokka voi peri&auml; suoranaisesti yhden luokan. V&auml;lillisesti luokka kuitenkin perii kaikki perim&auml;ns&auml; luokan ominaisuudet. Luokka <code>ArrayList</code>perii suoranaisesti luokan <code>AbstractList</code>, ja v&auml;lillisesti luokat <code>AbstractCollection</code>ja <code>Object</code>. Luokalla <code>ArrayList</code>on siis k&auml;yt&ouml;ss&auml;&auml;n luokkien <code>AbstractList</code>, <code>AbstractCollection</code>ja <code>Object</code>muuttujat, metodit <em>ja</em> rajapinnat.</p>
	<p>Luokan ominaisuudet perit&auml;&auml;n avainsanalla <code>extends</code>. Luokan periv&auml;&auml; luokkaa kutsutaan aliluokaksi (<em>subclass</em>), peritt&auml;v&auml;&auml; luokkaa yliluokaksi (<em>superclass</em>). Tutustutaan er&auml;&auml;n autonvalmistajan j&auml;rjestelm&auml;&auml;n, joka hallinnoi auton osia. Osien hallinan peruskomponentti on luokka <code>Osa</code>, joka m&auml;&auml;rittelee tunnuksen, valmistajan ja kuvauksen.</p>
	<pre class="sh_java">
public class Osa {

    private String tunnus;
    private String valmistaja;
    private String kuvaus;

    public Osa(String tunnus, String valmistaja, String kuvaus) {
        this.tunnus = tunnus;
        this.valmistaja = valmistaja;
        this.kuvaus = kuvaus;
    }

    public String getTunnus() {
        return tunnus;
    }

    public String getKuvaus() {
        return kuvaus;
    }

    public String getValmistaja() {
        return valmistaja;
    }
}
</pre>
	<p>Yksi osa autoa on moottori. Kuten kaikilla osilla, my&ouml;s moottorilla on valmistaja, tunnus ja kuvaus. N&auml;iden lis&auml;ksi moottoriin liittyy moottorityyppi: esimerkiksi polttomoottori, s&auml;hk&ouml;moottori tai hybridi. Luodaan luokan <code>Osa</code>periv&auml; luokka <code>Moottori</code>: moottori on osan erikoistapaus.</p>
	<pre class="sh_java">
public class Moottori extends Osa {

    private String moottorityyppi;

    public Moottori(String moottorityyppi, String tunnus, String valmistaja, String kuvaus) {
        super(tunnus, valmistaja, kuvaus);
        this.moottorityyppi = moottorityyppi;
    }

    public String getMoottorityyppi() {
        return moottorityyppi;
    }
}
</pre>
	<p>Luokkam&auml;&auml;rittely <code>public class Moottori extends Osa</code>kertoo ett&auml; luokka <code>Moottori</code>perii luokan <code>Osa</code>toiminnallisuuden. Luokassa <code>Moottori</code>m&auml;&auml;ritell&auml;&auml;n oliomuuttuja <code>moottorityyppi</code>.</p>
	<p>Moottori-luokan konstruktori on mielenkiintoinen. Konstruktorin ensimm&auml;isell&auml; rivill&auml; on avainsana <code>super</code>, jolla kutsutaan yliluokan konstruktoria. Kutsu <code>super(tunnus, valmistaja, kuaus)</code>kutsuu luokassa <code>Osa</code>m&auml;&auml;ritelty&auml; konstruktoria <code>public Osa(String tunnus, String valmistaja, String kuvaus</code>, jolloin yliluokassa m&auml;&auml;ritellyt oliomuuttujat saavat arvonsa. T&auml;m&auml;n j&auml;lkeen oliomuuttujalle <code>moottorityyppi</code>asetetaan siihen liittyv&auml; arvo.</p>
	<p>Kun luokka <code>Moottori</code>perii luokan <code>Osa</code>, saa se k&auml;ytt&ouml;&ouml;ns&auml; kaikki luokan <code>Osa</code>tarjoamat metodit. Luokasta <code>Moottori</code>voi tehd&auml; ilmentym&auml;n aivan kuten mist&auml; tahansa muustakin luokata.</p>
	<pre class="sh_java">
        Moottori moottori = new Moottori(&quot;polttomoottori&quot;, &quot;hz&quot;, &quot;volkswagen&quot;, &quot;VW GOLF 1L 86-91&quot;);
        System.out.println(moottori.getMoottorityyppi());
        System.out.println(moottori.getValmistaja());
</pre>
	<pre>
polttomoottori
volkswagen
</pre>
	<p>Kuten huomaat, luokalla <code>Moottori</code>on k&auml;yt&ouml;ss&auml; luokassa <code>Osa</code>m&auml;&auml;ritellyt metodit. Huom! Jos metodilla tai muuttujalla on n&auml;kyvyysm&auml;&auml;re <code>private</code>, ei se n&auml;y aliluokille.</p>
	<h3>
		Yliluokka super</h3>
	<p>Yliluokan konstruktoria kutsutaan avainsanalla <code>super</code>. Kutsu <code>super</code>on k&auml;yt&auml;nn&ouml;ss&auml; samanlainen kuin <code>this</code>-konstruktorikutsu. Kutsulle annetaan parametrina konstruktorin vaatimat oliot.</p>
	<p>Konstruktoria kutsuttaessa yliluokassa m&auml;&auml;ritellyt muuttujat alustetaan. Konstruktorikutsussa tapahtuu k&auml;yt&auml;nn&ouml;ss&auml; t&auml;ysin samat asiat kuin normaalissa konstruktorikutsussa. Jos yliluokassa ei ole m&auml;&auml;ritelty parametritonta konstruktoria, tulee aliluokan konstruktorikutsuissa olla aina mukana yliluokan konstruktorikutsu.</p>
	<p>Huom! Kutsun <code>super</code>tulee olla aina konstruktorin ensimm&auml;isell&auml; rivill&auml;!</p>
	<p>Yliluokassa m&auml;&auml;riteltyj&auml; metodeja voi kutsua <code>super</code>-etuliitteen avulla, aivan kuten t&auml;ss&auml; luokassa m&auml;&auml;riteltyj&auml; metodeja voi kutsua <code>this</code>-etuliitteell&auml;. Esimerkiksi yliluokassa m&auml;&auml;ritelty&auml; <code>toString</code>-metodia voi hy&ouml;dynt&auml;&auml; seuraavasti.</p>
	<pre class="sh_java">
    @Override
    public String toString() {
        return super.toString() + &quot;\n  Ja oma viestini viel&auml;!&quot;;
    }
</pre>
	<div class="tehtavat">
		<h3>
			Henkil&ouml; ja sen perilliset</h3>
		<h4 class="req">
			Henkilo</h4>
		<p>Tee pakkaus <code>henkilot</code>ja sinne luokka <code>Henkilo</code>, joka toimii seuraavan p&auml;&auml;ohjelman yhteydess&auml;</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo(&quot;Pekka Mikkola&quot;, &quot;Korsontie 1 03100 Vantaa&quot;);
        Henkilo esko = new Henkilo(&quot;Esko Ukkonen&quot;, &quot;Mannerheimintie 15 00100 Helsinki&quot;);
        System.out.println(pekka);
        System.out.println(esko);
    }
</pre>
		<p>siten ett&auml; tulostuu</p>
		<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
</pre>
		<h4 class="req">
			Opiskelija</h4>
		<p>Tee pakkaukseen luokka <code>Opiskelija</code>joka <i>perii</i> luokan <code>Henkilo</code>.</p>
		<p>Opiskelijalla on aluksi 0 opintopistett&auml;. Aina kun opiskelija opiskelee, kasvaa opintopistem&auml;&auml;r&auml;. Toteuta luokka siten, ett&auml; seuraava p&auml;&auml;ohjelma:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija(&quot;Olli&quot;, &quot;Ida Albergintie 1 00400 Helsinki&quot;);
        System.out.println(olli );
        System.out.println(&quot;opintopisteit&auml; &quot; + olli.opintopisteita());
        olli.opiskele();
        System.out.println(&quot;opintopisteit&auml; &quot;+ olli.opintopisteita());
    }
</pre>
		<p>tuottaa tulostuksen:</p>
		<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
opintopisteit&auml; 0
opintopisteit&auml; 1
</pre>
		<h4 class="req">
			Opiskelijalle toString</h4>
		<p>Edellisess&auml; teht&auml;v&auml;ss&auml; <code>Opiskelija</code>perii toString-metodin luokalta <code>Henkilo</code>. Perityn metodin voi my&ouml;s ylikirjoittaa, eli korvata omalla versiolla. Tee nyt <code>Opiskelija</code>:lle oma versio toString:ist&auml; joka toimii seuraavan esimerkin mukaan:</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija(&quot;Olli&quot;, &quot;Ida Albergintie 1 00400 Helsinki&quot;);
        System.out.println( olli );
        olli.opiskele();
        System.out.println( olli );
    }
</pre>
		<p>Tulostuu:</p>
		<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteit&auml; 0
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteit&auml; 1
</pre>
		<h4 class="req">
			Opettaja</h4>
		<p>Tee pakkaukseen luokka <code>Henkilo</code>:n periv&auml; luokka <code>Opettaja</code>. Opettajalla on palkka joka tulostuu opettajan merkkijonoesityksess&auml;.</p>
		<p>Testaa, ett&auml; seuraava p&auml;&auml;ohjelma</p>
		<pre class="sh_java">
    public static void main(String[] args) {
        Opettaja pekka = new Opettaja(&quot;Pekka Mikkola&quot;, &quot;Korsontie 1 03100 Vantaa&quot;, 1200);
        Opettaja esko = new Opettaja(&quot;Esko Ukkonen&quot;, &quot;Mannerheimintie 15 00100 Helsinki&quot;, 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Opiskelija olli = new Opiskelija(&quot;Olli&quot;, &quot;Ida Albergintie 1 00400 Helsinki&quot;);
        for ( int i=0; i &lt; 25; i++ )
            olli.opiskele();
        System.out.println( olli );
    }
</pre>
		<p>Aikaansaa tulostuksen</p>
		<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
  palkka 5400 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteit&auml; 25
</pre>
		<h4 class="req">
			Kaikki Henkilot listalle</h4>
		<p>Toteuta oletuspakkauksessa olevaan <code>Main</code>-luokkaan luokkametodi <code>public static void tulostaLaitoksenHenkilot(List&lt;Henkilo&gt; henkilot)</code>, joka tulostaa kaikki metodille parametrina annetussa listassa olevat henkil&ouml;t. Metodin tulee toimia seuraavasti <code>main</code>-metodista kutsuttaessa.</p>
		<pre class="sh_java">
    public static void tulostaLaitoksenHenkilot(List&lt;Henkilo&gt; henkilot) {
       // tulostetaan kaikki listan henkil&ouml;t
    }

    public static void main(String[] args) {
        List&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;();
        henkilot.add( new Opettaja(&quot;Pekka Mikkola&quot;, &quot;Korsontie 1 03100 Vantaa&quot;, 1200) );
        henkilot.add( new Opiskelija(&quot;Olli&quot;, &quot;Ida Albergintie 1 00400 Helsinki&quot;) );

        tulostaLaitoksenHenkilot(henkilot);
    }
</pre>
		<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteit&auml; 0
</pre>
	</div>
	<h3>
		Milloin perint&auml;&auml; tulee k&auml;ytt&auml;&auml;?</h3>
	<p>Perint&auml; on v&auml;line k&auml;sitehierarkioiden rakentamiseen ja erikoistamiseen; aliluokka on aina yliluokan erikoistapaus. Jos luotava luokka on olemassaolevan luokan erikoistapaus, voidaan uusi luokka luoda perim&auml;ll&auml; olemassaoleva luokka. Esimerkiksi auton osiin liittyv&auml;ss&auml; esimerkiss&auml; moottori <em>on</em> osa, mutta moottoriin liittyy lis&auml;toiminnallisuutta mit&auml; jokaisella osalla ei ole.</p>
	<p>Peritt&auml;ess&auml; aliluokka saa k&auml;ytt&ouml;&ouml;ns&auml; yliluokan toiminnallisuudet. Jos aliluokka ei tarvitse tai k&auml;yt&auml; peritty&auml; toiminnallisuutta, ei perint&auml; ole perusteltua. Perityt luokat periv&auml;t yliluokkiensa metodit ja rajapinnat, eli aliluokkia voidaan k&auml;ytt&auml;&auml; miss&auml; tahansa miss&auml; yliluokkaa on k&auml;ytetty. Perint&auml;hierarkia kannattaa mit&auml;&auml; matalana, sill&auml; hierarkian yll&auml;pito ja jatkokehitys vaikeutuu perint&ouml;hierarkian kasvaessa. Yleisesti ottaen, jos perint&auml;hierarkian korkeus on yli 5, ohjelman rakenteessa on todenn&auml;k&ouml;isesti parannettavaa.</p>
	<p>Perin&auml;n k&auml;ytt&ouml;&auml; tulee mietti&auml;. Esimerkiksi luokan <code>Auto</code>periminen luokasta <code>Osa</code>(tai <code>Moottori</code>) on v&auml;&auml;rin. Auto <em>sis&auml;lt&auml;&auml;</em> moottorin ja osia, mutta auto ei ole moottori tai osa. Voimme yleisemmin ajatella ett&auml; jos olio omistaa tai koostuu toisista olioista, ei perint&auml;&auml; tule k&auml;ytt&auml;&auml;.</p>
	<p>Perint&auml;&auml; k&auml;ytett&auml;ess&auml; tulee varmistaa ett&auml; Single Responsibility Principle p&auml;tee my&ouml;s peritt&auml;ess&auml;. Jokaisella luokalla tulee olla vain yksi syy muuttua. Jos huomaat ett&auml; perint&auml; lis&auml;&auml; luokan vastuita, tulee luokka pilkkoa useammaksi luokaksi.</p>
	<h4>
		Esimerkki: perinn&auml;n v&auml;&auml;rink&auml;ytt&ouml;</h4>
	<p>Pohditaan postituspalveluun liittyvi&auml; luokkia <code>Asiakas</code>, joka sis&auml;lt&auml;&auml; asiakkaan tiedot, ja <code>Tilaus</code>, joka perii asiakkaan tiedot ja sis&auml;lt&auml;&auml; tilattavan tavaran tiedot. Luokassa <code>Tilaus</code>on my&ouml;s metodi <code>postitusOsoite</code>, joka kertoo tilauksen postitusosoitteen.</p>
	<pre class="sh_java">
public class Asiakas {

    private String nimi;
    private String osoite;

    public Asiakas(String nimi, String osoite) {
        this.nimi = nimi;
        this.osoite = osoite;
    }

    public String getNimi() {
        return nimi;
    }

    public String getOsoite() {
        return osoite;
    }

    public void setOsoite(String osoite) {
        this.osoite = osoite;
    }
}
</pre>
	<pre class="sh_java">
public class Tilaus extends Asiakas {

    private String tuote;
    private String lukumaara;

    public Tilaus(String tuote, String lukumaara, String nimi, String osoite) {
        super(nimi, osoite);
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.getNimi() + &quot;\n&quot; + this.getOsoite();
    }
}
</pre>
	<p>Yll&auml; perint&auml;&auml; on k&auml;ytetty v&auml;&auml;rin. Luokkaa peritt&auml;ess&auml; aliluokan tulee olla yliluokan erikoistapaus; tilaus ei ole asiakkaan erikoistapaus. V&auml;&auml;rink&auml;ytt&ouml; ilmenee single responsibility principlen rikkomisena: luokalla <code>Tilaus</code>on vastuu sek&auml; asiakkaan tietojen yll&auml;pidosta, ett&auml; tilauksen tietojen yll&auml;pidosta.</p>
	<p>Ratkaisussa piilev&auml; ongelma tulee esiin kun mietimme mit&auml; k&auml;y asiakkaan osoitteen muuttuessa.</p>
	<p>Osoitteen muuttuessa joudumme muuttamaan <em>jokaista</em> kyseiseen asiakkaaseen liittyv&auml;&auml; tilausoliota, mik&auml; kertoo huonosta tilanteesta. Parempi ratkaisu olisi kapseloida <code>Asiakas</code><code>Tilaus</code>-luokan oliomuuttujaksi. Jos ajattelemme tarkemmin tilauksen semantiikkaa, t&auml;m&auml; on selv&auml;&auml;. <em>Tilauksella on asiakas</em>. Muutetaan luokkaa <code>Tilaus</code>siten, ett&auml; se sis&auml;lt&auml;&auml; <code>Asiakas</code>-viitteen.</p>
	<pre class="sh_java">
public class Tilaus {

    private Asiakas asiakas;
    private String tuote;
    private String lukumaara;

    public Tilaus(Asiakas asiakas, String tuote, String lukumaara) {
        this.asiakas = asiakas;
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.asiakas.getNimi() + &quot;\n&quot; + this.asiakas.getOsoite();
    }
}
</pre>
	<p>Yll&auml; oleva luokka <code>Tilaus</code>on nyt parempi. Metodi <code>postitusosoite</code>k&auml;ytt&auml;&auml; <em>asiakas</em>-viitett&auml; postitusosoitteen saamiseen sen sijaan ett&auml; luokka perisi luokan <code>Asiakas</code>. T&auml;m&auml; helpottaa sek&auml; ohjelman yll&auml;pitoa, ett&auml; sen konkreettista toiminnallisuutta.</p>
	<p>Nyt asiakkaan muuttaessa tarvitsee muuttaa vain asiakkaan tietoja, tilauksiin ei tarvitse tehd&auml; muutoksia.</p>
	<div class="tehtavat">
		<h3>
			Varastointia</h3>
		<p>Teht&auml;v&auml;pohjassa tulee mukana luokka <code>Varasto</code>, jonka tarjoamat konstruktorit ja metodit ovat seuraavat:</p>
		<ul>
			<li>
				<font size="-1"><b>public Varasto(double tilavuus)</b><br />
				Luo tyhj&auml;n varaston, jonka vetoisuus eli tilavuus annetaan parametrina; sopimaton tilavuus (&lt;=0) luo k&auml;ytt&ouml;kelvottoman varaston, jonka tilavuus on 0.</font></li>
			<li>
				<font size="-1"><b>public double getSaldo()</b><br />
				Palauttaa arvonaan varaston saldon.</font></li>
			<li>
				<font size="-1"><b>public double getTilavuus()</b><br />
				Palauttaa arvonaan varaston kapasiteetin.</font></li>
			<li>
				<font size="-1"><b>public double paljonkoMahtuu()</b><br />
				Palauttaa arvonaan tiedon, paljonko varastoon viel&auml; mahtuu.</font></li>
			<li>
				<font size="-1"><b>public void lisaaVarastoon(double maara)</b><br />
				Lis&auml;&auml; varastoon pyydetyn m&auml;&auml;r&auml;n; jos m&auml;&auml;r&auml; on negatiivinen, mik&auml;&auml;n ei muutu, jos kaikki pyydetty ei en&auml;&auml; mahdu, varasto laitetaan t&auml;ydeksi ja loput m&auml;&auml;r&auml;s&auml;t&auml; &quot;heitet&auml;&auml;n menem&auml;&auml;n&quot;, &quot;vuotaa yli&quot;.</font></li>
			<li>
				<font size="-1"><b>public double otaVarastosta(double maara)</b><br />
				Otetaan varastosta pyydetty m&auml;&auml;r&auml;; metodi palauttaa paljonko <b>saadaan</b> jos pyydetty m&auml;&auml;r&auml; on negatiivinen, mik&auml;&auml;n ei muutu ja palautetaan nolla; jos pyydet&auml;&auml;n enemm&auml;n kuin varastossa on, annetaan mit&auml; voidaan ja varasto tyhjenee.</font></li>
			<li>
				<font size="-1"><b>public String toString()</b><br />
				Palauttaa olion tilan merkkijonoesityksen&auml; tyyliin <tt>saldo = 64.5, tilaa 123.5</tt></font></li>
		</ul>
		<p>Teht&auml;v&auml;ss&auml; rakennetaan <code>Varasto</code>-luokasta useampia erilaisia varastoja. Huom! Toteuta kaikki luokat pakkaukseen <code>varastot</code>.</p>
		<h4 class="req">
			Tuotevarasto, vaihe 1</h4>
		<p>Luokka <i>Varasto</i> hallitsee tuotteen m&auml;&auml;r&auml;&auml;n liittyv&auml;t toiminnot. Nyt tuotteelle halutaan lis&auml;ksi tuotenimi ja nimen k&auml;sittelyv&auml;lineet. <i> <b>Ohjelmoidaan Tuotevarasto Varaston aliluokaksi!</b></i> Toteutetaan ensin pelkk&auml; yksityinen oliomuuttuja tuotenimelle, konstruktori ja getteri nimikent&auml;lle:</p>
		<ul>
			<li>
				<b>public Tuotevarasto(String tuotenimi, double tilavuus)</b><br />
				Luo tyhj&auml;n tuotevaraston. Tuotenimi ja vetoisuus annetaan parametrina.</li>
			<li>
				<b>public String getNimi()</b><br />
				Palauttaa arvonaan tuotteen nimen.</li>
		</ul>
		<p><i>Muista mill&auml; tavoin konstruktori voi ensi toimenaan suorittaa yliluokan konstruktorin!</i></p>
		<p>K&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto(&quot;Juice&quot;, 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getNimi()); // Juice
        System.out.println(mehu);           // saldo = 988.7, tilaa 11.3
</pre>
		<pre>
Juice
saldo = 988.7, viel&auml; tilaa 11.3
</pre>
		<h4 class="req">
			Tuotevarasto, vaihe 2</h4>
		<p>Kuten edellisest&auml; esimerkist&auml; n&auml;kee, Tuotevarasto-olion perim&auml; <i>toString()</i> ei tied&auml; (tietenk&auml;&auml;n!) mit&auml;&auml;n tuotteen nimest&auml;. <i>Asialle on teht&auml;v&auml; jotain!</i> Lis&auml;t&auml;&auml;n samalla my&ouml;s setteri tuotenimelle:</p>
		<ul>
			<li>
				<b>public void setNimi(String uusiNimi)</b> asettaa tuotteelle uuden nimen.</li>
			<li>
				<b>public String toString()</b> palauttaa olion tilan merkkijonoesityksen&auml; tyyliin <tt>Juice: saldo = 64.5, tilaa 123.5</tt></li>
		</ul>
		<p>Uuden <i>toString()</i>-metodin voisi toki ohjelmoida k&auml;ytt&auml;en yliluokalta perittyj&auml; gettereit&auml;, joilla perittyjen, mutta piilossa pidettyjen kenttien arvoja saa k&auml;ytt&ouml;&ouml;ns&auml;. Koska yliluokkaan on kuitenkin jo ohjelmoitu tarvittava taito varastotilanteen merkkiesityksen tuottamiseen, miksi n&auml;hd&auml; vaivaa sen uudelleen ohjelmointiin. K&auml;yt&auml; siis hyv&auml;ksesi peritty&auml; <i>toString</i>i&auml;.</p>
		<p><i>Muista miten korvattua metodia voi kutsua aliluokassa!</i></p>
		<p>K&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto(&quot;Juice&quot;, 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getNimi()); // Juice
        mehu.lisaaVarastoon(1.0);
        System.out.println(mehu);           // Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>
		<pre>
Juice
Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>
		<h4>
			Muutoshistoria</h4>
		<p>Toisinaan saattaa olla kiinostavaa tiet&auml;&auml;, mill&auml; tavoin jonkin tuotteen varastotilanne muuttuu: onko varasto usein hyvin vajaa, ollaanko usein yl&auml;rajalla, onko vaihelu suurta vai pient&auml;, jne. Varustetaan siksi <i>Tuotevarasto</i>-luokka taidolla muistaa tuotteen m&auml;&auml;r&auml;n muutoshistoriaa.</p>
		<p>Aloitetaan apuv&auml;lineen laadinnalla.</p>
		<p>Muutoshistorian muistamisen voisi toki toteuttaa suoraankin <i>ArrayList&lt;Double&gt;</i>-oliona luokassa <i>Tuotevarasto</i>, mutta nyt laaditaan kuitenkin oma <i>erikoistettu v&auml;line</i> t&auml;h&auml;n tarkoitukseen. V&auml;line toteutetaan kapseloimalla <i>ArrayList&lt;Double&gt;</i>-olio.</p>
		<p><i>Muutoshistoria</i>-luokan julkiset konstruktorit ja metodit:</p>
		<ul>
			<li>
				<b>public Muutoshistoria()</b> luo tyhj&auml;n <i>Muutoshistoria</i>-olion.</li>
			<li>
				<b>public void lisaa(double tilanne)</b> lis&auml;&auml; muutoshistorian viimeisimm&auml;ksi muistettavaksi m&auml;&auml;r&auml;ksi parametrina annetun tilanteen.</li>
			<li>
				<b>public void nollaa()</b> tyhj&auml;&auml; muistin.</li>
			<li>
				<b>public String toString()</b> palauttaa muutoshistorian merkkijonoesityksen. <i>ArrayList-luokan antama merkkijonoesitys kelpaa sellaisenaan.</i></li>
		</ul>
		<h4 class="req">
			Muutoshistoria.java, vaihe 2</h4>
		<p>T&auml;ydenn&auml; <i>Muutoshistoria</i>-luokkaa analyysimetodein:</p>
		<ul>
			<li>
				<b>public double maxArvo()</b> palauttaa muutoshistorian suurimman arvon. Jos historia on tyhj&auml;, metodi palauttaa nollan.</li>
			<li>
				<b>public double minArvo()</b> palauttaa muutoshistorian pienimm&auml;n arvon. Jos historia on tyhj&auml;, metodi palauttaa nollan.</li>
			<li>
				<b>public double keskiarvo()</b> palauttaa muutoshistorian arvojen keskiarvon. Jos historia on tyhj&auml;, metodi palauttaa nollan.</li>
		</ul>
		<p>Havainnollista uusien metodien k&auml;ytt&ouml;&auml; ja toimivuutta pienell&auml; ohjelmalla.</p>
		<h4>
			Muutoshistoria.java, vaihe 3</h4>
		<p>T&auml;ydenn&auml; <i>Muutoshistoria</i>-luokkaa analyysimetodein:</p>
		<ul>
			<li>
				<b>public double suurinMuutos()</b> palauttaa muutoshistorian isoimman (huom: -5:n kokoinen muutos on isompi kuin 4:n kokoinen muutos) yksitt&auml;isen muutoksen itseisarvon. Jos historia on tyhj&auml; tai yhden arvon mittainen, metodi palauttaa nollan. Itseisarvo on luvun et&auml;isyys nollasta. Esimerkiksi luvun -5.5 itseisarvo on 5.5, luvun 3.2 itseisarvo on 3.2.</li>
			<li>
				<b>public double varianssi()</b> palauttaa muutoshistorian arvojen varianssin (k&auml;ytet&auml;&auml;n otosvarianssin kaavaa). Jos historia on tyhj&auml; tai yhden arvon mittainen, metodi palauttaa nollan.</li>
		</ul>
		<p>Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi. Esimerkiksi lukujen {3, 2, 7, 2} keskiarvo on 3.5, joten otosvarianssi on ((3 - 3.5)&sup2; + (2 - 3.5)&sup2; + (7 - 3.5)&sup2; + (2 - 3.5)&sup2;)/(4 - 1) &asymp; 5,666667.)</p>
		<p>Havainnollista uusien metodien k&auml;ytt&ouml;&auml; ja toimivuutta pienell&auml; ohjelmalla.</p>
		<h4 class="req">
			MuistavaTuotevarasto, vaihe 1</h4>
		<p>Toteuta luokan <i>Tuotevarasto</i> aliluokkana <i>MuistavaTuotevarasto</i>. Uusi versio tarjoaa vanhojen lis&auml;ksi varastotilanteen muutoshistoriaan liittyvi&auml; palveluita. <i>Historiaa hallitaan <i>Muutoshistoria</i>-oliolla.</i></p>
		<p>Julkiset konstruktorit ja metodit:</p>
		<ul>
			<li>
				<b>public MuistavaTuotevarasto(String tuotenimi, double tilavuus, double alkuSaldo)</b> luo tuotevaraston. Tuotenimi, vetoisuus ja alkusaldo annetaan parametrina. <i>Aseta alkusaldo sek&auml; varaston alkusaldoksi ett&auml; muutoshistorian ensimm&auml;iseksi arvoksi.</i></li>
			<li>
				<b>public String historia()</b> palauttaa tuotehistorian tyyliin <tt>[0.0, 119.2, 21.2]</tt>. <i>K&auml;yt&auml; Muutoshistoria-olion merkkiesityst&auml; sellaisenaan.</i></li>
		</ul>
		<p><b>Huomaa</b> ett&auml; t&auml;ss&auml; esiversiossa historia ei viel&auml; toimi kunnolla; nyt vasta vain aloitussaldo muistetaan.</p>
		<p>K&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto(&quot;Juice&quot;, 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getNimi()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, viel&auml; tilaa 10.3
...
<b>// mutta viel&auml; historia() ei toimi kunnolla:</b>
System.out.println(mehu.historia()); // [1000.0]
   // saadaan siis vasta konstruktorin asettama historian alkupiste...
...
</pre>
		<p>Tulostus siis:</p>
		<pre>
Juice
Juice: saldo = 989.7, viel&auml; tilaa 10.299999999999955
[1000.0]
</pre>
		<h4 class="req">
			MuistavaTuotevarasto, vaihe 2</h4>
		<p><i>On aika aloittaa historia!</i> Ensimm&auml;inen versio ei historiasta tiennyt kuin alkupisteen. T&auml;ydenn&auml; luokkaa metodein</p>
		<ul>
			<li>
				<b>public void lisaaVarastoon(double maara)</b> toimii kuin <i>Varasto</i>-luokan aksessori, mutta muuttunut tilanne kirjataan historiaan. <b>Huom: </b> historiaan tulee kirjata lis&auml;yksen j&auml;lkeinen varastosaldo, ei lis&auml;tt&auml;v&auml;&auml; m&auml;&auml;r&auml;&auml;!</li>
			<li>
				<b>public double otaVarastosta(double maara)</b> toimii kuin <i>Varasto</i>-luokan aksessori, mutta muuttunut tilanne kirjataan historiaan. <b>Huom: </b> historiaan tulee kirjata poiston j&auml;lkeinen varastosaldo, ei poistettavaa m&auml;&auml;r&auml;&auml;!</li>
		</ul>
		<p>K&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto(&quot;Juice&quot;, 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getNimi()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, viel&auml; tilaa 10.3
...
// mutta nyt on historiaakin:
System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]
...
</pre>
		<p>Tulostus siis:</p>
		<pre>
Juice
Juice: saldo = 989.7, viel&auml; tilaa 10.299999999999955
[1000.0, 988.7, 989.7]
</pre>
		<p>&nbsp;</p>
		<p><i>Muista miten korvaava metodi voi k&auml;ytt&auml;&auml; hyv&auml;kseen korvattua metodia!</i></p>
		<h4 class="req">
			MuistavaTuotevarasto, vaihe 3</h4>
		<p>T&auml;ydenn&auml; luokkaa metodilla</p>
		<ul>
			<li>
				<b>public void tulostaAnalyysi()</b>, joka tulostaa tuotteeseen liittyvi&auml; historiatietoja esimerkin esitt&auml;m&auml;&auml;n tapaan.</li>
		</ul>
		<p>K&auml;ytt&ouml;esimerkki:</p>
		<pre class="sh_java">
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto(&quot;Juice&quot;, 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
mehu.lisaaVarastoon(1.0);
//System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]

mehu.tulostaAnalyysi();
</pre>
		<p>Metodi <i>tulostaAnalyysi</i> kirjoittaa ilmoituksen tyyliin:</p>
		<pre>
Tuote: Juice
Historia: [1000.0, 988.7, 989.7]
Suurin tuotem&auml;&auml;r&auml;: 1000.0
Pienin tuotem&auml;&auml;r&auml;: 988.7
Keskiarvo: 992.8
</pre>
		<p>&nbsp;</p>
		<h4>
			MuistavaTuotevarasto, vaihe 4</h4>
		<p>T&auml;ydenn&auml; analyysin tulostus sellaiseksi, ett&auml; mukana ovat my&ouml;s muutoshistorian suurin muutos ja historian varianssi.</p>
		<p>Havainnollista kehitelty&auml; analyysiraporttia pienell&auml; esimerkkiohjelmalla.</p>
	</div>
	<h3>
		Perint&auml;, rajapinnat, kumpikin, vai eik&ouml; kumpaakaan?</h3>
	<p>Perint&auml; ei sulje pois rajapintojen k&auml;ytt&ouml;&auml;, eik&auml; rajapintojen k&auml;ytt&ouml; sulje pois perinn&auml;n k&auml;ytt&ouml;&auml;. Rajapinnat toimivat sopimuksena luokan tarjoamasta toteutuksesta, ja mahdollistavat konkreettisen toteutuksen abstrahoinnin. Kuten DAO-esimerkiss&auml; huomasimme, rajapinnat mahdollistavat ns. <em>plug-and-play</em> toiminnallisuuden. Rajapinnan toteuttavan luokan vaihto on hyvin helppoa.</p>
	<p>Aivan kuten rajapintaa toteuttaessa, sitoudumme peritt&auml;ess&auml; siihen, ett&auml; aliluokkamme tarjoaa kaikki yliluokan metodit. Monimuotoisuuden ja polymorfismin takia perint&auml;kin toimii kuin rajapinnat. Voimme antaa yliluokkaa k&auml;ytt&auml;v&auml;lle metodille sen aliluokan ilmentym&auml;n.</p>
	<p>Tehd&auml;&auml;n seuraavaksi maatilasimulaattori, jossa simuloidaan maatilan el&auml;m&auml;&auml;. Huomaa ett&auml; ohjelmassa ei k&auml;ytet&auml; perint&auml;&auml;, ja rajapintojenkin k&auml;ytt&ouml; on melko v&auml;h&auml;ist&auml;. Usein ohjelmat tehd&auml;&auml;nkin niin ett&auml; ensin toteutetaan yksi versio, jota l&auml;hdet&auml;&auml;n parantamaan my&ouml;hemmin. Tyypillist&auml; on ett&auml; ensimm&auml;ist&auml; versiota toteutettaessa ongelma-aluetta ei viel&auml; ymm&auml;rret&auml; kunnolla, jolloin rajapintojen ja k&auml;sitehierarkioiden suunnittelu ennalta on hyvin vaikeaa ja saattaa jopa hidastaa ty&ouml;skentely&auml;.</p>
	<div class="tehtavat">
		<h3>
			Maatilasimulaattori</h3>
		<p>Maatiloilla on lyps&auml;vi&auml; el&auml;imi&auml;, jotka tuottavat maitoa. Maatilat eiv&auml;t itse k&auml;sittele maitoa, vaan se kuljetetaan Maitoautoilla meijereille. Meijerit ovat yleisi&auml; maitotuotteita tuottavia rakennuksia. Jokainen meijeri erikoistuu yhteen tuotetyyppiin, esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja Maitomeijeri tuottaa maitoa.</p>
		<p>&nbsp;</p>
		<p>Rakennetaan maidon el&auml;m&auml;&auml; kuvaava simulaattori. Toteuta kaikki luokat pakkaukseen <code>maatilasimulaattori</code>.</p>
		<p>&nbsp;</p>
		<h4>
			Maitos&auml;ili&ouml;</h4>
		<p>Jotta maito pysyisi tuoreena, t&auml;ytyy se s&auml;il&ouml;&auml; sille tarkoitettuun s&auml;ili&ouml;&ouml;n. S&auml;ili&ouml;it&auml; valmistetaan sek&auml; oletustilavuudella 2000 litraa, ett&auml; asiakkaalle r&auml;&auml;t&auml;l&ouml;idyll&auml; tilavuudella. Toteuta luokka Maitosailio jolla on seuraavat konstruktorit ja metodit.</p>
		<ul>
			<li>
				<font size="-1"><strong>public Maitosailio()</strong></font></li>
			<li>
				<font size="-1"><strong>public Maitosailio(double tilavuus)</strong></font></li>
			<li>
				<font size="-1"><strong>public double getTilavuus()</strong></font></li>
			<li>
				<font size="-1"><strong>public double getSaldo()</strong></font></li>
			<li>
				<font size="-1"><strong>public double paljonkoTilaaJaljella()</strong></font></li>
			<li>
				<font size="-1"><strong>public void lisaaSailioon(double maara)</strong> lis&auml;&auml; s&auml;ili&ouml;&ouml;n vain niin paljon maitoa kuin sinne mahtuu, ylim&auml;&auml;r&auml;iset j&auml;&auml;v&auml;t lis&auml;&auml;m&auml;tt&auml; -- maitos&auml;ili&ouml;n ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</font></li>
			<li>
				<font size="-1"><strong>public double otaSailiosta(double maara)</strong> ottaa s&auml;ili&ouml;st&auml; pyydetyn m&auml;&auml;r&auml;n, tai niin paljon kuin siell&auml; on j&auml;ljell&auml; </font></li>
		</ul>
		<p>Toteuta <code>Maitosailio</code>-luokalle my&ouml;s <code>toString()</code>-metodi, jolla kuvaat sen tilaa. Ilmaistessasi s&auml;ili&ouml;n tilaa <code>toString()</code>-metodissa, py&ouml;rist&auml; litram&auml;&auml;r&auml;t yl&ouml;sp&auml;in k&auml;ytt&auml;en <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.</p>
		<p>Testaa maitosaili&ouml;t&auml; seuraavalla ohjelmap&auml;tk&auml;ll&auml;:</p>
		<pre class="sh_java">
        Maitosailio sailio = new Maitosailio();
        sailio.otaSailiosta(100);
        sailio.lisaaSailioon(25);
        sailio.otaSailiosta(5);
        System.out.println(sailio);

        sailio = new Maitosailio(50);
        sailio.lisaaSailioon(100);
        System.out.println(sailio);
</pre>
		<p>Ohjelman tulostuksen tulee olla seuraavankaltainen:</p>
		<pre>
20.0/2000.0
50.0/50.0
</pre>
		<p>Huomaa ett&auml; kutsuttaessa <code>System</code>-luokan <code>out</code>-olioon liittyv&auml;&auml; <code>println()</code>-metodia, joka saa parametrikseen <code>Object</code>-tyyppisen muuttujan, tulostus k&auml;ytt&auml;&auml; <code>Maitosailio</code>-luokassa korvattua <code>toString()</code>-metodia! T&auml;ss&auml; on kyse polymorfismista, eli ajonaikaisesta k&auml;ytett&auml;vien metodien p&auml;&auml;ttelyst&auml;.</p>
		<h4>
			Lehm&auml;</h4>
		<p>Saadaksemme maitoa tarvitsemme my&ouml;s lehmi&auml;. Lehm&auml;ll&auml; on nimi ja utareet. Utareiden tilavuus on satunnainen luku v&auml;lilt&auml; 15 ja 40 -- luokkaa <code>Random</code>voi k&auml;ytt&auml;&auml;&auml; satunnaislukujen arpomiseen, esimerkiksi <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code>on seuraavat toiminnot:</p>
		<ul>
			<li>
				<font size="-1"><strong>public Lehma()</strong> luo uuden lehm&auml;n satunnaisesti valitulla nimell&auml;</font></li>
			<li>
				<font size="-1"><strong>public Lehma(String nimi)</strong> luo uuden lehm&auml;n annetulla nimell&auml;</font></li>
			<li>
				<font size="-1"><strong>String getNimi()</strong> palauttaa lehm&auml;n nimen</font></li>
			<li>
				<font size="-1"><strong>double getTilavuus()</strong> palauttaa utareiden tilavuuden</font></li>
			<li>
				<font size="-1"><strong>double getMaara()</strong> palauttaa utareissa olevan maidon m&auml;&auml;r&auml;n</font></li>
			<li>
				<font size="-1"><strong>String toString()</strong> palauttaa lehm&auml;&auml; kuvaavan merkkijonon (ks. esimerkki alla)</font></li>
		</ul>
		<p><code>Lehma</code>toteuttaa my&ouml;s rajapinnat: <code>Lypsava</code>, joka kuvaa lyps&auml;misk&auml;ytt&auml;ytymist&auml;, ja <code>Eleleva</code>, joka kuvaa elelemisk&auml;ytt&auml;ytymist&auml;.</p>
		<pre class="sh_java">
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
</pre>
		<p>Lehm&auml;&auml; lypsett&auml;ess&auml; sen koko maitovarasto tyhjennet&auml;&auml;n jatkok&auml;sittely&auml; varten. Lehm&auml;n elelless&auml; sen maitovarasto t&auml;yttyy hiljalleen. Suomessa maidontuotannossa k&auml;ytetyt lehm&auml;t tuottavat keskim&auml;&auml;rin noin 25-30 litraa maitoa p&auml;iv&auml;ss&auml;. Simuloidaan t&auml;t&auml; tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa.</p>
		<p>Jos lehm&auml;lle ei anneta nime&auml;, valitse sille nimi satunnaisesti seuraavasta listasta.</p>
		<pre class="sh_java">
    private static String[] NIMIA = new String[]{
        &quot;Anu&quot;, &quot;Arpa&quot;, &quot;Essi&quot;, &quot;Heluna&quot;, &quot;Hely&quot;,
        &quot;Hento&quot;, &quot;Hilke&quot;, &quot;Hilsu&quot;, &quot;Hymy&quot;, &quot;Ihq&quot;, &quot;Ilme&quot;, &quot;Ilo&quot;,
        &quot;Jaana&quot;, &quot;Jami&quot;, &quot;Jatta&quot;, &quot;Laku&quot;, &quot;Liekki&quot;,
        &quot;Mainikki&quot;, &quot;Mella&quot;, &quot;Mimmi&quot;, &quot;Naatti&quot;,
        &quot;Nina&quot;, &quot;Nyytti&quot;, &quot;Papu&quot;, &quot;Pullukka&quot;, &quot;Pulu&quot;,
        &quot;Rima&quot;, &quot;Soma&quot;, &quot;Sylkki&quot;, &quot;Valpu&quot;, &quot;Virpi&quot;};
</pre>
		<p>Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmap&auml;tk&auml;n avulla.</p>
		<pre class="sh_java">
        Lehma lehma = new Lehma();
        System.out.println(lehma);


        Eleleva elelevaLehma = lehma;
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();

        System.out.println(lehma);

        Lypsava lypsavaLehma = lehma;
        lypsavaLehma.lypsa();

        System.out.println(lehma);
        System.out.println(&quot;&quot;);

        lehma = new Lehma(&quot;Ammu&quot;);
        System.out.println(lehma);
        lehma.eleleTunti();
        lehma.eleleTunti();
        System.out.println(lehma);
        lehma.lypsa();
        System.out.println(lehma);

</pre>
		<p>Ohjelman tulostus on erimerkiksi seuraavanlainen.</p>
		<p>&nbsp;</p>
		<pre>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/53.0
Ammu 9.0/53.0
Ammu 0.0/53.0
</pre>
		<h4>
			Lypsyrobotti</h4>
		<p>Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lyps&auml;misen. Jotta lypsyrobotti voi lyps&auml;&auml; lyps&auml;v&auml;&auml; otusta, tulee lypsyrobotin olla kiinnitetty maitos&auml;ili&ouml;&ouml;n:</p>
		<ul>
			<li>
				<font size="-1"><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</font></li>
			<li>
				<font size="-1"><strong>Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitos&auml;ili&ouml; tai <code>null</code>-viitteen, jos s&auml;ili&ouml;t&auml; ei ole viel&auml; kiinnitetty</font></li>
			<li>
				<font size="-1"><strong>void setMaitosailio(Maitosailio maitosailio)</strong> kiinnitt&auml;&auml; annetun s&auml;ili&ouml;n lypsyrobottiin</font></li>
			<li>
				<font size="-1"><strong>void lypsa(Lypsava lypsava)</strong> lyps&auml;&auml; lehm&auml;n robottiin kiinnitettyyn maitos&auml;ili&ouml;&ouml;n -- metodi heitt&auml;&auml; poikkeuksen <code>IllegalStateException</code>, jos s&auml;ili&ouml;t&auml; ei ole kiinnitetty </font></li>
		</ul>
		<p>Toteuta luokka Lypsyrobotti ja testaa sit&auml; seuraavien ohjelmanp&auml;tkien avulla. Varmista ett&auml; lypsyrobotti voi lyps&auml;&auml; kaikkia Lypsava-rajapinnan toteuttavia olioita!</p>
		<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        lypsyrobotti.lypsa(lehma);
</pre>
		<pre>
Exception in thread &quot;main&quot; java.lang.IllegalStateException: Maitos&auml;ili&ouml;t&auml; ei ole asennettu
        at maatilasimulaattori.Lypsyrobotti.lypsa(Lypsyrobotti.java:17)
        at maatilasimulaattori.Main.main(Main.java:9)
Java Result: 1
</pre>
		<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        System.out.println(&quot;&quot;);

        Maitosailio sailio = new Maitosailio();
        lypsyrobotti.setMaitosailio(sailio);
        System.out.println(&quot;S&auml;ili&ouml;: &quot; + sailio);

        for(int i = 0; i &lt; 2; i++) {
            System.out.println(lehma);
            System.out.println(&quot;Elell&auml;&auml;n..&quot;);
            for(int j = 0; j &lt; 5; j++) {
                lehma.eleleTunti();
            }
            System.out.println(lehma);

            System.out.println(&quot;Lypset&auml;&auml;n...&quot;);
            lypsyrobotti.lypsa(lehma);
            System.out.println(&quot;S&auml;ili&ouml;: &quot; + sailio);
            System.out.println(&quot;&quot;);
        }
</pre>
		<p>Ohjelman tulostus on esimerkiksi seuraavanlainen.</p>
		<pre>
S&auml;ili&ouml;: 0.0/2000.0
Mella 0.0/23.0
Elell&auml;&auml;n..
Mella 6.2/23.0
Lypset&auml;&auml;n...
S&auml;ili&ouml;: 6.2/2000.0

Mella 0.0/23.0
Elell&auml;&auml;n..
Mella 7.8/23.0
Lypset&auml;&auml;n...
S&auml;ili&ouml;: 14.0/2000.0
</pre>
		<h4>
			Navetta</h4>
		<p>Lehm&auml;t hoidetaan (eli t&auml;ss&auml; tapauksessa lypset&auml;&auml;n) navetassa. Alkukantaisissa navetoissa on maitos&auml;ili&ouml; ja tilaa yhdelle lypsyrobotille. Huomaa ett&auml; lypsyrobottia asennettaessa se kytket&auml;&auml;n juuri kyseisen navetan maitos&auml;ili&ouml;&ouml;n. Jos navetassa ei ole lypsyrobottia, ei siell&auml; voida my&ouml;sk&auml;&auml;n hoitaa lehmi&auml;. Toteuta luokka <code>Navetta</code>jolla on seuraavat konstruktorit ja metodit:</p>
		<ul>
			<li>
				<font size="-1"><strong>public Navetta(Maitosailio maitosailio)</strong></font></li>
			<li>
				<font size="-1"><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</font></li>
			<li>
				<font size="-1"><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnitt&auml;&auml; sen navetan maitos&auml;ili&ouml;&ouml;n</font></li>
			<li>
				<font size="-1"><strong>public void hoida(Lehma lehma)</strong> lyps&auml;&auml; parametrina annetun lehm&auml;n lypsyrobotin avulla -- metodi heitt&auml;&auml; poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</font></li>
			<li>
				<font size="-1"><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lyps&auml;&auml; parametrina annetut lehm&auml;t lypsyrobotin avulla -- metodi heitt&auml;&auml; poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</font></li>
			<li>
				<font size="-1"><strong>public String toString()</strong> palauttaa navetan sis&auml;lt&auml;m&auml;n maitos&auml;ili&ouml;n tilan</font></li>
		</ul>
		<p><code>Collection</code>on Javan oma rajapinta joka kuvaa kokoelmien k&auml;ytt&auml;ytymist&auml;. Esimerkiksi luokat <code>ArrayList</code>ja <code>LinkedList</code>toteuttavat rajapinnan <code>Collection</code>. Jokaista <code>Collection</code>-rajapinnan toteuttavaa ilmentym&auml;&auml; voi my&ouml;s iteroida for-each-tyyppisesti.</p>
		<p>Testaa luokkaa <code>Navetta</code>seuraavan ohjelmap&auml;tk&auml;n avulla. &Auml;l&auml; hermoile luokasta <code>LinkedList</code>, se toimii ulkoap&auml;in katsottuna kuin <code>ArrayList</code>, mutta sen kapseloima toteutus on hieman erilainen. T&auml;st&auml; lis&auml;&auml; tietorakenteet-kurssilla!</p>
		<pre class="sh_java">
        Navetta navetta = new Navetta(new Maitosailio());
        System.out.println(&quot;Navetta: &quot; + navetta);

        Lypsyrobotti robo = new Lypsyrobotti();
        navetta.asennaLypsyrobotti(robo);

        Lehma ammu = new Lehma();
        ammu.eleleTunti();
        ammu.eleleTunti();

        navetta.hoida(ammu);
        System.out.println(&quot;Navetta: &quot; + navetta);

        LinkedList&lt;Lehma&gt; lehmaLista = new LinkedList();
        lehmaLista.add(ammu);
        lehmaLista.add(new Lehma());

        for(Lehma lehma: lehmaLista) {
            lehma.eleleTunti();
            lehma.eleleTunti();
        }

        navetta.hoida(lehmaLista);
        System.out.println(&quot;Navetta: &quot; + navetta);
</pre>
		<p>Tulostuksen tulee olla esimerkiksi seuraavanlainen:</p>
		<pre>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
</pre>
		<h4>
			Maatila</h4>
		<p>Maatilalla on omistaja ja siihen kuuluu navetta sek&auml; joukko lehmi&auml;. Maatila toteuttaa my&ouml;s aiemmin n&auml;hdyn rajapinnan <code>Eleleva</code>, jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan liittyv&auml;t lehm&auml;t elelev&auml;t tunnin. Toteuta luokka maatila siten, ett&auml; se toimii seuraavien esimerkkiohjelmien mukaisesti.</p>
		<pre class="sh_java">
        Maatila maatila = new Maatila(&quot;Esko&quot;, new Navetta(new Maitosailio()));
        System.out.println(maatila);

        System.out.println(maatila.getOmistaja() + &quot; on ahkera mies!&quot;);
</pre>
		<p>Odotettu tulostus:</p>
		<pre>
Maatilan omistaja: Esko
Navetan maitos&auml;ili&ouml;: 0.0/2000.0
Ei lehmi&auml;.
Esko on ahkera mies!
</pre>
		<pre class="sh_java">
        Maatila maatila = new Maatila(&quot;Esko&quot;, new Navetta(new Maitosailio()));
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        System.out.println(maatila);
</pre>
		<p>Odotettu tulostus:</p>
		<pre>
Maatilan omistaja: Esko
Navetan maitos&auml;ili&ouml;: 0.0/2000.0
Lehm&auml;t:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</pre>
		<pre class="sh_java">
        Maatila maatila = new Maatila(&quot;Esko&quot;, new Navetta(new Maitosailio()));

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();
</pre>
		<p>Odotettu tulostus:</p>
		<pre>
Maatilan omistaja: Esko
Navetan maitos&auml;ili&ouml;: 0.0/2000.0
Lehm&auml;t:
        Heluna 2.0/17.0
        Rima 3.0/42.0
        Ilo 3.0/25.0
</pre>
		<pre class="sh_java">
        Maatila maatila = new Maatila(&quot;Esko&quot;, new Navetta(new Maitosailio()));
        Lypsyrobotti robo = new Lypsyrobotti();
        maatila.asennaNavettaanLypsyrobotti(robo);

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();

        maatila.hoidaLehmat();

        System.out.println(maatila);
</pre>
		<p>Odotettu tulostus:</p>
		<pre>
Maatilan omistaja: Esko
Navetan maitos&auml;ili&ouml;: 18.0/2000.0
Lehm&auml;t:
        Hilke 0.0/30.0
        Sylkki 0.0/45.0
        Hento 0.0/54.0
</pre>
	</div>
	<h3>
		Abstrakti luokka</h3>
	<p>Abstrakti luokka yhdist&auml;&auml; rajapintoja ja perint&auml;&auml;. Niist&auml; ei voi tehd&auml; ilmentymi&auml;, vaan ilmentym&auml;t tehd&auml;&auml;n tehd&auml;&auml;n abstraktin luokan aliluokista. Abstrakti luokka voi sis&auml;lt&auml;&auml; sek&auml; normaaleja metodeja, joissa on metodirunko, ett&auml; abstrakteja metodeja, jotka sis&auml;lt&auml;v&auml;t ainoastaan metodim&auml;&auml;rittelyn. Abstraktien metodien toteutus j&auml;tet&auml;&auml;n periv&auml;n luokan vastuulle. Yleisesti ajatellen abstrakteja luokkia k&auml;ytet&auml;&auml;n esimerkiksi kun abstraktin luokan kuvaama k&auml;site ei ole selke&auml; itsen&auml;inen k&auml;site. T&auml;ll&ouml;in siit&auml; ei tule pysty&auml; tekem&auml;&auml;n ilmentymi&auml;.</p>
	<p>Sek&auml; abstraktin luokan ett&auml; abstraktien metodien m&auml;&auml;rittelyss&auml; k&auml;ytet&auml;&auml;n avainsanaa <code>abstract</code>. Abstrakti luokka m&auml;&auml;ritell&auml;&auml;n lauseella <code>public abstract class <em>LuokanNimi</em></code>, abstrakti metodi taas lauseella <code>public abstract <em>palautustyyppi</em> <em>metodinNimi</em></code>. Pohditaan seuraavaa abstraktia luokkaa <code>Toiminto</code>, joka tarjoaa rungon toiminnoille ja niiden suorittamiselle.</p>
	<pre class="sh_java">
public abstract class Toiminto {

    private String nimi;

    public Toiminto(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public abstract void suorita(Scanner lukija);
}
</pre>
	<p>Abstrakti luokka <code>Toiminto</code>toimii runkona erilaisten toimintojen toteuttamiseen. Esimerkiksi pluslaskun voi toteuttaa perim&auml;ll&auml; luokka <code>Toiminto</code>seuraavasti.</p>
	<pre class="sh_java">
public class Pluslasku extends Toiminto {

    public Pluslasku() {
        super(&quot;Pluslasku&quot;);
    }

    @Override
    public void suorita(Scanner lukija) {
        System.out.print(&quot;Anna ensimm&auml;inen luku: &quot;);
        int eka = Integer.parseInt(lukija.nextLine());
        System.out.print(&quot;Anna toinen luku: &quot;);
        int toka = Integer.parseInt(lukija.nextLine());

        System.out.println(&quot;Lukujen summa on &quot; + (eka + toka));
    }
}
</pre>
	<p>Koska kaikki <code>Toiminto</code>-luokan periv&auml;t luokat ovat my&ouml;s tyyppi&auml; toiminto, voimme rakentaa k&auml;ytt&ouml;liittym&auml;n <code>Toiminto</code>-tyyppisten muuttujien varaan. Seuraava luokka <code>Kayttoliittyma</code>sisaltaa listan toimintoja ja lukijan. Toimintoja voi lis&auml;t&auml; k&auml;ytt&ouml;liittym&auml;&auml;n dynaamisesti.</p>
	<pre class="sh_java">
public class Kayttoliittyma {

    private Scanner lukija;
    private List&lt;Toiminto&gt; toiminnot;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
        this.toiminnot = new ArrayList&lt;Toiminto&gt;();
    }

    public void lisaaToiminto(Toiminto toiminto) {
        this.toiminnot.add(toiminto);
    }

    public void kaynnista() {
        while (true) {
            tulostaToiminnot();
            System.out.println(&quot;Valinta: &quot;);

            String valinta = this.lukija.nextLine();
            if (valinta.equals(&quot;0&quot;)) {
                break;
            }

            suoritaToiminto(valinta);
            System.out.println();
        }
    }

    private void tulostaToiminnot() {
        System.out.println(&quot;\t0: Lopeta&quot;);
        for (int i = 0; i &lt; this.toiminnot.size(); i++) {
            String toiminnonNimi = this.toiminnot.get(i).getNimi();
            System.out.println(&quot;\t&quot; + (i + 1) + &quot;: &quot; + toiminnonNimi);
        }
    }

    private void suoritaToiminto(String valinta) {
        int toiminto = Integer.parseInt(valinta);

        Toiminto valittu = this.toiminnot.get(toiminto - 1);
        valittu.suorita(lukija);
    }
}
</pre>
	<p>K&auml;ytt&ouml;liittym&auml; toimii seuraavasti:</p>
	<pre class="sh_java">
        Kayttoliittyma kayttolittyma = new Kayttoliittyma(new Scanner(System.in));
        kayttolittyma.lisaaToiminto(new Pluslasku());

        kayttolittyma.kaynnista();
</pre>
	<pre>
Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: 1
Anna ensimm&auml;inen luku: 8
Anna toinen luku: 12
Lukujen summa on 20

Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: 0
</pre>
	<p>Rajapintojen ja abstraktien luokkien ero on siin&auml;, ett&auml; abstraktit luokat tarjoavat enemm&auml;n rakennetta ohjelmaan. Koska abstrakteihin luokkiin voidaan m&auml;&auml;ritell&auml; toiminnallisuutta, voidaan niit&auml; k&auml;ytt&auml;&auml; esimerkiksi oletustoiminnallisuuden m&auml;&auml;rittelyyn. Yll&auml; k&auml;ytt&ouml;liittym&auml; k&auml;ytti abstraktissa luokassa m&auml;&auml;ritelty&auml; toiminnan nimen tallentamista.</p>
	<div class="tehtavat">
		<h3>
			Erilaisia laatikoita</h3>
		<p>Teht&auml;v&auml;pohjan mukana tulee luokat <code>Tavara</code>ja <code>Laatikko</code>. Luokka <code>Laatikko</code>on abstrakti luokka, jossa useamman tavaran lis&auml;&auml;minen lis&auml;&auml;minen on toteutettu siten, ett&auml; kutsutaan aina <code>lisaa</code>-metodia. Yhden tavaran lis&auml;&auml;miseen tarkoitettu metodi <code>lisaa</code>on abstrakti, joten jokaisen <code>Laatikko</code>-luokan periv&auml;n laatikon tulee toteuttaa se. Teht&auml;v&auml;n&auml;si on muokata luokkaa <code>Tavara</code>ja toteuttaa muutamia erilaisia laatikoita luokan <code>Laatikko</code>pohjalta.</p>
		<p>Lis&auml;&auml; kaikki uudet luokat pakkaukseen <code>laatikot</code>.</p>
		<pre class="sh_java">
package laatikot;

import java.util.Collection;

public abstract class Laatikko {

    public abstract void lisaa(Tavara tavara);

    public void lisaa(Collection&lt;Tavara&gt; tavarat) {
        for (Tavara tavara : tavarat) {
            lisaa(tavara);
        }
    }

    public abstract boolean onkoLaatikossa(Tavara tavara);
}
</pre>
		<h4>
			Tavaran muokkaus ja maksimipainollinen laatikko</h4>
		<p>Lis&auml;&auml; <code>Tavara</code>-luokan konstruktoriin tarkistus, jossa tarkistetaan ett&auml; tavaran paino ei ole koskaan negatiivinen (paino 0 hyv&auml;ksyt&auml;&auml;n). Jos paino on negatiivinen, tulee konstruktorin heitt&auml;&auml; <code>IllegalArgumentException</code>-poikkeus. Toteuta <code>Tavara</code>-luokalle my&ouml;s metodit <code>equals</code>ja <code>hashCode</code>, joiden avulla erilaisten p&auml;&auml;set hy&ouml;dynt&auml;m&auml;&auml;n listojen ja kokoelmien <code>contains</code>-metodia. Toteuta metodit siten, ett&auml; Tavara-luokan oliomuuttujan <code>paino</code>arvolla ei ole v&auml;li&auml;. <em>Voit hyvin hy&ouml;dynt&auml;&auml; NetBeansin tarjoamaa toiminnallisuutta..</em></p>
		<p>Toteuta lis&auml;ksi pakkaukseen <code>laatikot</code>luokka <code>MaksimipainollinenLaatikko</code>, joka perii luokan <code>Laatikko</code>. Maksimipainollisella laatikolla on konstruktori <code>public MaksimipainollinenLaatikko(int maksimipaino)</code>, joka m&auml;&auml;rittelee laatikon maksimipainon. Maksimipainolliseen laatikkoon voi lis&auml;t&auml; tavaraa jos ja vain jos tavaran lis&auml;&auml;minen ei ylit&auml; laatikon maksimipainoa.</p>
		<pre class="sh_java">
        MaksimipainollinenLaatikko kahviLaatikko = new MaksimipainollinenLaatikko(10);
        kahviLaatikko.lisaa(new Tavara(&quot;Saludo&quot;, 5));
        kahviLaatikko.lisaa(new Tavara(&quot;Pirkka&quot;, 5));
        kahviLaatikko.lisaa(new Tavara(&quot;Kopi Luwak&quot;, 5));

        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara(&quot;Saludo&quot;)));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara(&quot;Pirkka&quot;)));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara(&quot;Kopi Luwak&quot;)));
</pre>
		<pre>
true
true
false
</pre>
		<h4>
			Yhden tavaran laatikko ja Hukkaava laatikko</h4>
		<p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code>luokka <code>YhdenTavaranLaatikko</code>, joka perii luokan <code>Laatikko</code>. Yhden tavaran laatikolla on konstruktori <code>public YhdenTavaranLaatikko()</code>, ja siihen mahtuu tasan yksi tavara. Jos tavara on jo laatikossa sit&auml; ei tule vaihtaa. Laatikkoon lis&auml;tt&auml;v&auml;n tavaran painolla ei ole v&auml;li&auml;.</p>
		<pre class="sh_java">
        YhdenTavaranLaatikko laatikko = new YhdenTavaranLaatikko();
        laatikko.lisaa(new Tavara(&quot;Saludo&quot;, 5));
        laatikko.lisaa(new Tavara(&quot;Pirkka&quot;, 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara(&quot;Saludo&quot;)));
        System.out.println(laatikko.onkoLaatikossa(new Tavara(&quot;Pirkka&quot;)));
</pre>
		<pre>
true
false
</pre>
		<p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code>luokka <code>HukkaavaLaatikko</code>, joka perii luokan <code>Laatikko</code>. Hukkaavalla laatikolla on konstruktori <code>public HukkaavaLaatikko()</code>. Hukkaavaan laatikkoon voi lis&auml;t&auml; kaikki tavarat, mutta tavaroita ei l&ouml;ydy niit&auml; etsitt&auml;ess&auml;. Laatikkoon lis&auml;&auml;misen tulee siis aina onnistua, mutta metodin <code>onkoLaatikossa</code>kutsumisen tulee aina palauttaa false.</p>
		<pre class="sh_java">
        HukkaavaLaatikko laatikko = new HukkaavaLaatikko();
        laatikko.lisaa(new Tavara(&quot;Saludo&quot;, 5));
        laatikko.lisaa(new Tavara(&quot;Pirkka&quot;, 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara(&quot;Saludo&quot;)));
        System.out.println(laatikko.onkoLaatikossa(new Tavara(&quot;Pirkka&quot;)));
</pre>
		<pre>
false
false
</pre>
		<h3>
			Kuviot</h3>
		<p>Teht&auml;v&auml;pohjan mukana tulee luokat <code>Ympyra</code>, <code>Suorakulmio</code>ja <code>TasasivuinenKolmio</code>. Luokat liittyv&auml;t samaan aihepiiriin, ja niill&auml; on hyvin paljon yhteist&auml; toiminnallisuutta. Tutustu luokkiin ennenkuin l&auml;hdet tekem&auml;&auml;n, jolloin hahmotat tarkemmin syyt muutoksille. Jos huomaat ett&auml; luokissa on alustavasti sisennys hieman pieless&auml;, kannattaa sisennys hoitaa kuntoon luettavuuden helpottamiseksi.</p>
		<h4>
			Kuvio</h4>
		<p>Toteuta pakkaukseen <code>kuviot</code>abstrakti luokka <code>Kuvio</code>, jossa on kuvioihin liittyv&auml;&auml; toiminnallisuutta. Luokan kuvio tulee sis&auml;lt&auml;&auml; konstruktori <code>public Kuvio(int x, int y)</code>, aksessorit <code>public int getX()</code>, <code>public int getY()</code>, sek&auml; abstraktit metodit <code>public abstract double pintaAla()</code>ja <code>public abstract double piiri()</code>.</p>
		<h4>
			Ympyra perii kuvion</h4>
		<p>Muuta luokan <code>Ympyra</code>toteutusta siten, ett&auml; se perii luokan <code>Kuvio</code>. Luokan <code>Ympyra</code>ulkoinen toiminnallisuus ei saa muuttua, eli sen tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code>avulla tai itse. Muistathan ett&auml; konstruktorikutsun <code>super</code>avulla voit k&auml;ytt&auml;&auml; yliluokan konstruktoria. Kun metodi <code>public int getX()</code>on toteutettu jo yliluokassa se ei tarvitse erillist&auml; toteutusta luokassa <code>Ympyra</code>.</p>
		<pre class="sh_java">
        Kuvio kuvio = new Ympyra(10, 10, 15);
        System.out.println(&quot;X &quot; + kuvio.getX());
        System.out.println(&quot;Y &quot; + kuvio.getY());
        System.out.println(&quot;Pinta-ala &quot; + kuvio.pintaAla());
        System.out.println(&quot;Piiri &quot; + kuvio.piiri());
</pre>
		<pre>
X 10
Y 10
Pinta-ala 706.85834...
Piiri 94.24777...
</pre>
		<h4>
			Suorakulmio ja Tasakylkinen kolmio perii kuvion</h4>
		<p>Muuta luokkien <code>Suorakulmio</code>ja <code>TasakylkinenKolmio</code>toteutusta siten, ett&auml; ne periv&auml;t luokan <code>Kuvio</code>. Luokkien ulkoinen toiminnallisuus ei saa muuttua, eli niiden tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code>avulla tai itse.</p>
		<pre class="sh_java">
        Kuvio kuvio = new Suorakulmio(10, 10, 15, 15);
        System.out.println(&quot;X &quot; + kuvio.getX());
        System.out.println(&quot;Y &quot; + kuvio.getY());
        System.out.println(&quot;Pinta-ala &quot; + kuvio.pintaAla());
        System.out.println(&quot;Piiri &quot; + kuvio.piiri());
        System.out.println(&quot;&quot;);

        kuvio = new TasakylkinenKolmio(10, 10, 15);
        System.out.println(&quot;X &quot; + kuvio.getX());
        System.out.println(&quot;Y &quot; + kuvio.getY());
        System.out.println(&quot;Pinta-ala &quot; + kuvio.pintaAla());
        System.out.println(&quot;Piiri &quot; + kuvio.piiri());
</pre>
		<pre>
X 10
Y 10
Pinta-ala 225.0
Piiri 60.0

X 10
Y 10
Pinta-ala 97.42785...
Piiri 45.0
</pre>
		<h3>
			Luola</h3>
		<p><em>T&auml;m&auml; teht&auml;v&auml; on nelj&auml;n teht&auml;v&auml;pisteen arvoinen.</em> Huom! Toteuta kaikki toiminnallisuus pakkaukseen <code>luola</code>.</p>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; p&auml;&auml;set toteuttamaan luolapelin. Peliss&auml; pelaaja on luolassa hirvi&ouml;itten kanssa. Pelaajan teht&auml;v&auml;n&auml; on ehti&auml; tallata kaikki hirvi&ouml;t ennen kuin h&auml;nen lampustaan loppuu virta ja hirvi&ouml;t p&auml;&auml;sev&auml;t pime&auml;n turvin sy&ouml;m&auml;&auml;n h&auml;net. Pelaaja voi n&auml;hd&auml; hirvi&ouml;iden sijainnit v&auml;lk&auml;ytt&auml;m&auml;ll&auml; lamppua, jonka j&auml;lkeen h&auml;nen on liikuttava sokkona ennen seuraavaa v&auml;lk&auml;ytyst&auml;. Pelaaja voi kulkea monta askelta yhden siirron aikana.</p>
		<p>Pelitilanne eli luola, pelaaja ja hirvi&ouml;t esitet&auml;&auml;n pelaajalle tekstimuotoisesti. Tulostuksen ensimm&auml;inen rivi kertoo j&auml;ljell&auml; olevien siirtojen (eli lampun j&auml;ljell&auml; olevan virran) m&auml;&auml;r&auml;n. Virran m&auml;&auml;r&auml;&auml; seuraa pelaajan ja hirvi&ouml;itten sijainnit, joiden j&auml;lkeen on pelitilanteesta piirretty kartta. Allaolevassa esimerkiss&auml; n&auml;et pelaajan (<code>@</code>) ja kolme hirvi&ouml;t&auml; (<code>h</code>). Alla olevassa esimerkiss&auml; pelaajalla on virtaa nelj&auml;&auml;ntoista siirtoon.</p>
		<pre>
14

@ 1 2
h 6 1
h 7 3
h 12 2

.................
......h..........
.@.........h.....
.......h.........
</pre>
		<p>Yll&auml; olevassa esimerkiss&auml; virtaa on 14 v&auml;lk&auml;ytykseen. Pelaaja <code>@</code>sijatsee koordinaatissa <code>1 2</code>. Huomaa ett&auml; koordinaatit lasketaan aina pelialueen vasemmasta yl&auml;laidasta l&auml;htien. Allaolevassa kartassa merkki <code>X</code>on koordinaatissa <code>0 0</code>, <code>Y</code>koordinaatissa <code>2 0</code>ja <code>Z</code>koordinaatissa <code>0 2</code>.</p>
		<pre>
X.Y..............
.................
Z................
.................
</pre>
		<p>K&auml;ytt&auml;j&auml; voi liikkua antamalla sarjan komentoja ja painamalla rivinvaihtoa. Komennot ovat:</p>
		<ul>
			<li>
				<code>w</code>liiku yl&ouml;sp&auml;in</li>
			<li>
				<code>s</code>liiku alasp&auml;in</li>
			<li>
				<code>a</code>liiku vasemmalle</li>
			<li>
				<code>d</code>liiku oikealle</li>
		</ul>
		<p>Kun k&auml;ytt&auml;j&auml;n antamat komennot on suoritettu (niit&auml; voi olla useampi), piirret&auml;&auml;n uusi pelitilanne. Lampun virta v&auml;henee yhdell&auml; aina kun uusi pelitilanne piirret&auml;&auml;n. Jos virta menee nollaan, peli loppuu ja ruudulle tulostetaan teksti <code>HÄVISIT</code></p>
		<p>Hirvi&ouml;t liikkuvat peliss&auml; satunnaisesti, yhden askeleen jokaista pelaajan askelta kohti. Jos pelaaja ja hirvi&ouml; osuvat samaan ruutuun (vaikka vain tilap&auml;isesti), hirvi&ouml; tuhoutuu. Jos hirvi&ouml; yritt&auml;&auml; siirty&auml; ruutuun jossa on jo hirvi&ouml;, arvotaan sille siirto uudestaan. Kun kaikki hirvi&ouml;t on tuhottu, peli loppuu ja tulostetaan <code>VOITIT</code>.</p>
		<p>Testaamisen helpottamiseksi tee peliisi luokka <code>Luola</code>, jolla on :</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				konstruktori <strong><code>public Luola(int leveys, int korkeus, int hirvioita, int siirtoja, boolean hirviotLiikkuvat)</strong></code></strong>
				<p><strong>Luvut <code>leveys</code>ja <code>korkeus</code>antavat luolan koon (se on aina neliskulmainen), <code>hirvioita</code>antaa hirvi&ouml;iden lukum&auml;&auml;r&auml;n alussa (hirvi&ouml;iden sijainnin voi arpoa), <code>siirtoja</code>antaa siirtojen lukum&auml;&auml;r&auml;n alussa ja jos <code>hirviotLiikkuvat</code>on <code>false</code>, hirvi&ouml;t eiv&auml;t liiku.</strong></p>
			</li>
			<li>
				<strong>metodi <strong><code>public void run()</code></strong> joka k&auml;ynnist&auml;&auml; pelin</strong></li>
		</ul>
		<p>&nbsp;</p>
		<p><em>Huom!</em> pelaajan tulee aloittaa sijainnista 0,0!</p>
		<p><em>Huom!</em> jos pelaaja tai hirvi&ouml; koittaa liikkua ulos luolasta, ei liikett&auml; tule tapahtua!</p>
		<p>Alla viel&auml; selkeyden vuoksi viel&auml; esimerkkipeli:</p>
		<pre>

14

@ 0 0
h 1 2
h 7 8
h 7 5
h 8 0
h 2 9

@.......h.
..........
.h........
..........
..........
.......h..
..........
..........
.......h..
..h.......

ssd
13

@ 1 2
h 8 8
h 7 4
h 8 3
h 1 8

..........
..........
.@........
........h.
.......h..
..........
..........
..........
.h......h.
..........

ssss
12

@ 1 6
h 6 9
h 6 5
h 8 3

..........
..........
..........
........h.
..........
......h...
.@........
..........
..........
......h...

dd
11

@ 3 6
h 5 9
h 6 7
h 8 1

..........
........h.
..........
..........
..........
..........
...@......
......h...
..........
.....h....

ddds
10

@ 6 7
h 6 6
h 5 0

.....h....
..........
..........
..........
..........
..........
......h...
......@...
..........
..........

w
9

@ 6 6
h 4 0

....h.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

www
8

@ 6 3
h 4 0

....h.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

aa
7

@ 4 3
h 4 2

..........
..........
....h.....
....@.....
..........
..........
..........
..........
..........
..........

w
VOITIT
</pre>
		<!--<p><em>Luolan tulostuksessa kaksiulotteinen merkkitaulukko saattaa olla hyödyllinen: lisää ensin taulukkoon hahmon merkki "@" oikeaan kohtaan, sitten hirviöt, ja tulosta lopulta sen sisältö kahdella toistolauseella. Toinen toistolause kontrolloi tulostettavaa riviä, toinen tulostettavaa merkkiä..</em></p>--></div>
	<!--

VK5:

- Testaus
- Käli
- Anonyymit luokat


--></div>
<p><!-- <hr />Viikko 4 loppuu<hr /> --></p>
<div class="week" data-week-number="11">
	<h3>
		Valmiit sovelluskehykset</h3>
	<p>Sovelluskehys on ohjelma, joka tarjoaa l&auml;ht&ouml;kohdan ja joukon palveluita jonkin erityisen sovelluksen toteuttamiseen. Yksi tapa laatia sovelluskehys on laatia valmiita palveluita tarjoava luokka, jonka p&auml;&auml;lle luokan periv&auml;t luokat rakentavat erityisen sovelluksen. Sovelluskehykset ovat yleens&auml; hyvin laajoja, ja tarkoitettu johonkin tiettyyn tarkoitukseen -- esimerkiksi pelien ohjelmointiin tai web-sovelluskehitykseen. Tutustutaan seuraavasti pikaisesti valmiin sovelluskirjaston k&auml;ytt&ouml;&ouml;n luomalla sovelluslogiikka Game of Life -pelille.</p>
	<div class="tehtavat">
		<h3>
			Game of Life</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;sarjassa toteutetaan sovelluslogiikka Game of Life-pelille perim&auml;ll&auml; valmis sovellusrunko. Sovellusrunko on projektiin erikseen lis&auml;tyss&auml; kirjastossa, joten sen l&auml;hdekoodit eiv&auml;t ole n&auml;ht&auml;viss&auml;.</p>
		<p>Game of Life on matemaatikko John Conway&#39;n kehittelem&auml; yksinkertainen &quot;populaatiosimulaattori&quot;, kts. <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a>.</p>
		<p>Game of Lifen s&auml;&auml;nn&ouml;t ovat seuraavat:</p>
		<ul>
			<li>
				Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
			<li>
				Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria el&auml;&auml; seuraavaan iteraatioon eli kierrokseen.</li>
			<li>
				Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
			<li>
				Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu el&auml;v&auml;ksi.</li>
		</ul>
		<p>Abstrakti luokka <code>GameOfLifeAlusta</code>tarjoaa seuraavat toiminnot</p>
		<ul>
			<li>
				<b>public GameOfLifeAlusta(int leveys, int korkeus)</b> luo m&auml;&auml;ritellyn kokoisen pelialustan</li>
			<li>
				<b>public boolean[][] getAlusta()</b> tarjoaa p&auml;&auml;syn pelialustaan, joka on totuusarvoista koostuva kaksiulotteinen taulukko &ndash; kuten metodin paluuarvosta voi havaita! Palaamme kaksiulotteiseen taulukkoon tarkemmin sit&auml; tarvitessamme.</li>
			<li>
				<b>public int getLeveys()</b> palauttaa alustan leveyden</li>
			<li>
				<b>public int getKorkeus()</b> palauttaa alustan korkeuden</li>
			<li>
				<b>public void pelaaKierros()</b> simuloi pelikierroksen</li>
		</ul>
		<p>Luokassa <code>GameOfLifeAlusta</code>&gt; on lis&auml;ksi m&auml;&auml;ritelty seuraavat abstraktit metodit, jotka sinun tulee toteuttaa.</p>
		<p>&nbsp;</p>
		<ul>
			<li>
				<b>public abstract void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) el&auml;v&auml;ksi eli asettaa sille arvon <i>true</i></li>
			<li>
				<b>public abstract void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i></li>
			<li>
				<b>public abstract boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
			<li>
				<b>public abstract void alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b> alustaa kaikki alustan alkiot siten, ett&auml; kukin alkio on el&auml;v&auml; todenn&auml;k&ouml;isyydell&auml; <i>todennakoisyysPisteelle.</i> Todenn&auml;k&ouml;isyys annetaan double-arvona suljetulla v&auml;lill&auml; [0, 1]. Jos metodia kutsutaan arvolla 1, tulee jokaisen alkion olla el&auml;v&auml;. Jos taas todenn&auml;k&ouml;isyys on 0, tulee jokaisen alkion olla kuollut.</li>
			<li>
				<b>public abstract int getElossaOlevienNaapurienLukumaara(int x, int y)</b> kertoo elossa olevien naapureiden lukum&auml;&auml;r&auml;n solulle pisteess&auml; (x, y).</li>
			<li>
				<b>public abstract void hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> hoitaa solun (x, y) Game of Life -s&auml;&auml;nt&ouml;jen mukaan.</li>
		</ul>
		<h4>
			GameOfLife-toteutus, vaihe 1</h4>
		<p>Luo pakkaukseen <code>game</code>luokka <code>OmaAlusta</code>, joka perii pakkauksessa <code>gameoflife</code>olevan luokan <code>GameOfLifeAlusta</code>. Huomaa ett&auml; pakkausta <code>gameoflife</code>ei ole n&auml;kyvill&auml; omassa projektissasi, vaan se tulee mukana luokkakirjastona. Toteuta luokalle <code>OmaAlusta</code>konstruktori <code>public OmaAlusta(int leveys, int korkeus)</code>, joka kutsuu yl&auml;luokan konstruktoria annetuilla parametreilla.</p>
		<pre class="sh_java">

import gameoflife.GameOfLifeAlusta;

public class OmaAlusta extends GameOfLifeAlusta {

    public OmaAlusta(int leveys, int korkeus) {
        super(leveys, korkeus);
    }

    // ..
</pre>
		<p>Voit ensin korvata kaikki abstraktit metodit ei-abstrakteilla metodeilla, jotka eiv&auml;t kuitenkaan viel&auml; tee mit&auml;&auml;n j&auml;rkev&auml;&auml;. Mutta koska ne eiv&auml;t ole abstrakteja, t&auml;st&auml; luokasta voi luoda ilmentymi&auml; &ndash; toisin kuin abstraktista luokasta GameOfLifeAlusta.</p>
		<p>Toteuta seuraavat metodit</p>
		<ul>
			<li>
				<b>public void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) el&auml;v&auml;ksi eli asettaa sille arvon <i>true</i></li>
			<li>
				<b>public void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i></li>
			<li>
				<b>public boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
		</ul>
		<p>P&auml;&auml;set yl&auml;luokassa olevaan kaksiulotteiseen taulukkoon k&auml;siksi yl&auml;luokan tarjoaman metodin <code>getAlusta()</code>avulla. Kaksiulotteisia taulukoita k&auml;ytet&auml;&auml;n kuten yksiulotteisia taulukoita, mutta taulukoille annetaan kaksi indeksi&auml;. Ensimm&auml;inen indeksi kertoo leveyskohdan, toinen indeksi korkeuskohdan. Esimerkiksi seuraava ohjelmap&auml;tk&auml; luo ensin 10 x 10 -kokoisen taulukon, ja tulostaa sitten taulukon indeksiss&auml; 3, 1 olevan arvon.</p>
		<pre class="sh_java">

boolean[][] arvot = new boolean[10][10];
System.out.println(arvot[3][1]);
</pre>
		<p>Vastaavasti OmaAlusta-luokassa voidaan tulostaa yl&auml;luokasta saadun taulukon arvo indeksiss&auml; x, y seuraavasti:</p>
		<pre class="sh_java">

boolean[][] alusta = getAlusta();
System.out.println(alusta[x][y]);
</pre>
		<p>Testaa toteutustasi seuraavalla testiohjelmalla.</p>
		<pre class="sh_java">

package game;

import gameoflife.komentorivi.KomentoriviGameOfLife;

public class Main {
    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(7, 5);

        alusta.muutaElavaksi(2, 0);
        alusta.muutaElavaksi(4, 0);

        alusta.muutaElavaksi(3, 3);
        alusta.muutaKuolleeksi(3, 3);

        alusta.muutaElavaksi(0, 2);
        alusta.muutaElavaksi(1, 3);
        alusta.muutaElavaksi(2, 3);
        alusta.muutaElavaksi(3, 3);
        alusta.muutaElavaksi(4, 3);
        alusta.muutaElavaksi(5, 3);
        alusta.muutaElavaksi(6, 2);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
    }
}
</pre>
		<p>Tulostuksen pit&auml;isi olla seuraavanlainen:</p>
		<pre>

Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

  X X

X     X
 XXXXX

Paina enter jatkaaksesi, muut lopettaa: stop
Kiitos!
</pre>
		<p>&nbsp;</p>
		<h4>
			GameOfLife-toteutus, vaihe 2</h4>
		<p>Toteuta metodi <b>alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b>, joka alustaa kaikki alkiot siten, ett&auml; kukin alkio on el&auml;v&auml; todenn&auml;k&ouml;isyydell&auml; <i>todennakoisyysPisteelle</i>. Todenn&auml;k&ouml;isyys annetaan metodille suljetulla v&auml;lill&auml; [0, 1] olevana double-tyyppisen&auml; parametrina.</p>
		<p>Testaa metodia. Arvolla 0.0 ei pit&auml;isi olla yht&auml;&auml;n elossa olevaa solua, arvolla 1.0 kaikkien solujen tulisi olla elossa (eli n&auml;ky&auml; X-merkkisin&auml;). Arvolla 0.5 noin puolet soluista on el&auml;vi&auml;.</p>
		<pre class="sh_java">

        OmaAlusta alusta = new OmaAlusta(3, 3);
        alusta.alustaSatunnaisetPisteet(1.0);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
</pre>
		<pre>

Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

XXX
XXX
XXX
Paina enter jatkaaksesi, muut lopettaa: stop
Kiitos!
</pre>
		<h4>
			GameOfLife-toteutus, vaihe 3</h4>
		<p>Toteuta metodi <b>getElossaOlevienNaapurienLukumaara(int x, int y),</b> joka laskee elossa olevien naapurien lukum&auml;&auml;r&auml;n. Keskell&auml; taulukkoa olevalla solulla on yhteens&auml; kahdeksan naapuria, reunassa olevalla solulla 5, kulmassa olevalla 3.</p>
		<p>Testaa metodia seuraavilla lauseilla (voit keksi&auml; my&ouml;s muita testitapauksia!):</p>
		<pre class="sh_java">

OmaAlusta alusta = new OmaAlusta(7, 5);

alusta.muutaElavaksi(0, 1);
alusta.muutaElavaksi(1, 0);
alusta.muutaElavaksi(1, 2);
alusta.muutaElavaksi(2, 2);
alusta.muutaElavaksi(2, 1);

System.out.println(&quot;Elossa naapureita (0,0): &quot; + alusta.getElossaOlevienNaapurienLukumaara(0, 0));
System.out.println(&quot;Elossa naapureita (1,1): &quot; + alusta.getElossaOlevienNaapurienLukumaara(1, 1));
</pre>
		<p>Tulostuksen pit&auml;isi olla seuraavanlainen:</p>
		<pre>

Elossa naapureita (0,0): 2
Elossa naapureita (1,1): 5
</pre>
		<h4>
			GameOfLife-toteutus, vaihe 4</h4>
		<p>J&auml;ljell&auml; on viel&auml; metodin <b>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> toteuttaminen. GameOfLife-pelin s&auml;&auml;nn&ouml;th&auml;n olivat seuraavat:</p>
		<ul>
			<li>
				Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
			<li>
				Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria el&auml;&auml; seuraavaan iteraatioon eli kierrokseen.</li>
			<li>
				Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
			<li>
				Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu el&auml;v&auml;ksi.</li>
		</ul>
		<p>Toteuta metodi <code>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</code>yll&auml;olevien s&auml;&auml;nt&ouml;jen mukaan. Kannattaa ohjelmoida ja testata yksi s&auml;&auml;nt&ouml; kerrallaan!</p>
		<p>Kun olet saanut kaikki valmiiksi, voit testata ohjelman toimintaa seuraavalla graafisella simulaattorilla.</p>
		<pre class="sh_java">

package game;

import gameoflife.Simulaattori;

public class Main {

    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(100, 100);
        alusta.alustaSatunnaisetPisteet(0.7);

        Simulaattori simulaattori = new Simulaattori(alusta);
        simulaattori.simuloi();
    }
}
</pre>
	</div>
	<h2>
		Ohjelmien automaattinen testaaminen</h2>
	<p><font size="-1"><em>Errare humanum est</em></font></p>
	<p>Ihminen on erehtyv&auml;inen ja paraskin ohjelmoija tekee virheit&auml;. Ohjelman kehitysvaiheessa tapahtuvien virheiden lis&auml;ksi huomattava osa virheist&auml; syntyy olemassa olevaa ohjelmaa muokattaessa. Ohjelman muokkauksen aikana tehdyt virheet eiv&auml;t v&auml;ltt&auml;m&auml;tt&auml; n&auml;y muokattavassa osassa, vaan voivat ilmaantua v&auml;lillisesti erillisess&auml; osassa ohjelmaa: osassa, joka k&auml;ytt&auml;&auml; muutettua osaa.</p>
	<p>Ohjelmien automaattinen testaaminen tarkoittaa toistettavien testien luomista. Testeill&auml; varmistetaan ett&auml; ohjelma toimii halutusti, ja ett&auml; ohjelma s&auml;ilytt&auml;&auml; toiminnallisuutensa my&ouml;s muutosten j&auml;lkeen. Sanalla <em>automaattinen</em> painotetaan sit&auml;, ett&auml; luodut testit ovat toistettavia ja ett&auml; ne voidaan suorittaa aina haluttaessa -- ohjelmoijan ei tarvitse olla l&auml;sn&auml; testej&auml; suoritettaessa.</p>
	<p>Otimme aiemmin askeleita kohti testauksen automatisointia antamalla Scanner-oliolle parametrina merkkijonon, jonka se tulkitsee k&auml;ytt&auml;j&auml;n n&auml;pp&auml;imist&ouml;lt&auml; antamaksi sy&ouml;tteeksi. Automaattisessa testaamisessa testaaminen vied&auml;&auml;n vied&auml; pidemm&auml;lle: koneen teht&auml;v&auml;n&auml; on my&ouml;s tarkistaa ett&auml; ohjelman tuottama vastaus on odotettu.</p>
	<p>Automaattisen testauksen t&auml;ll&auml; kurssilla painotettu osa-alue on <em>yksikk&ouml;testaus</em>, jossa testataan ohjelman pienten osakokonaisuuksien -- metodien ja luokkien -- toimintaa. Yksikk&ouml;testaamiseen k&auml;ytet&auml;&auml;n Javalla yleens&auml; <a href="http://www.junit.org" target="_blank">JUnit</a>-testauskirjastoa.</p>
	<h3>
		Pino ja automaattiset testit</h3>
	<p>Pino on kaikille ihmisille tuttu asia. Esimerkiksi ravintola Unicafessa lautaset ovat yleens&auml; pinossa. Pinon p&auml;&auml;lt&auml; voi ottaa lautasen ja pinon p&auml;&auml;lle voi lis&auml;t&auml; lautasia. On my&ouml;s helppo selvitt&auml;&auml; onko pinossa viel&auml; lautasia j&auml;ljell&auml;.</p>
	<p>Pino on my&ouml;s ohjelmoinnissa usein k&auml;ytetty aputietorakenne. Rajapintana lukuja sis&auml;lt&auml;v&auml; pino n&auml;ytt&auml;&auml; seuraavalta.</p>
	<pre class="sh_java">

public interface Pino {
    boolean tyhja();
    boolean taynna();
    void pinoon(int luku);
    int pinosta();
    int huipulla();
    int lukuja();
}
</pre>
	<p>Rajapinnan m&auml;&auml;rittelemien metodien on tarkoitus toimia seuraavasti:</p>
	<ul>
		<li>
			<code>public boolean tyhja()</code>palauttaa true jos pino on tyhj&auml;</li>
		<li>
			<code>public boolean taynna()</code>palauttaa true jos pino on t&auml;ynn&auml;</li>
		<li>
			<code>public void pinoon(int luku)</code>laittaa parametrina olevan luvun pinon p&auml;&auml;lle</li>
		<li>
			<code>public int huipulla()</code>kertoo pinon huipulla olevan alkion</li>
		<li>
			<code>public int pinosta()</code>poistaa ja palauttaa pinon p&auml;&auml;ll&auml; olevan alkion</li>
		<li>
			<code>public int lukuja()</code>kertoo pinossa olevien lukujen m&auml;&auml;r&auml;n</li>
		<li>
			<code>public int tilaa()</code>kertoo pinon vapaan tilan m&auml;&auml;r&auml;n</li>
	</ul>
	<p>Toteutetaan rajapinnan <code>Pino</code>toteuttava luokka <code>OmaPino</code>, johon talletetaan lukuja. Pinoon mahtuvien lukujen m&auml;&auml;r&auml; annetaan pinon konstruktorissa. Toteutamme pinon hieman aiemmasta poikkeavasti -- emme testaa ohjelmaa p&auml;&auml;ohjelman avulla, vaan k&auml;yt&auml;mme p&auml;&auml;ohjelman sijasta automatisoituja JUnit-testej&auml; ohjelman testaamiseen.</p>
	<h4 class="req">
		Tutustuminen JUnitiin</h4>
	<p>NetBeansissa olevat ohjelmamme ovat t&auml;h&auml;n asti sijainneet aina <em>Source Packages</em>issa tai sen sis&auml;ll&auml; olevissa pakkauksissa. Ohjelman l&auml;hdekoodit tulevat aina kansioon <em>Source Packages</em>. Automaattisia testej&auml; luodessa testit luodaan valikon <em>Test Packages</em> alle. Uusia JUnit-testej&auml; voi luoda valitsemalla projektin oikealla hiirennapilla ja valitsemalla avautuvasta valikosta <code>New -> JUnit Test...</code>. Jos vaihtoehto JUnit test ei n&auml;y listassa, l&ouml;yd&auml;t sen valitsemalla <em>Other</em>.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/testaus/new-junit-test.png" /></p>
	<p>JUnit-testit sijaitsevat luokassa. Uutta testitiedostoa luodessa ohjelma pyyt&auml;&auml; testitiedoston nimen. Tyypillisesti nimeksi annetaan testattavan luokan tai toiminnallisuuden nimi. Luokan nimen tulee aina p&auml;&auml;tty&auml; sanaan <code>Test</code>. Esimerkiksi alla luodaan testiluokka <code>PinoTest</code>, joka sijaitsee pakkauksessa <code>pino</code>. NetBeans haluaa luoda k&auml;ytt&ouml;&ouml;mme my&ouml;s valmista runkoa testiluokalle -- joka k&auml;y hyvin.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/testaus/pinotest.png" /></p>
	<p>Jos NetBeans kysyy mink&auml; JUnit-version haluat k&auml;ytt&ouml;&ouml;si, valitse <code>JUnit 4.x</code>.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/testaus/junit4.png" /></p>
	<p>Kun testiluokka <code>PinoTest</code>on luotu, n&auml;kyy se projektin valikon <em>Test Packages</em> alla.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/testaus/pinotest-luotu.png" /></p>
	<p>Luokka <code>PinoTest</code>n&auml;ytt&auml;&auml; aluksi seuraavalta</p>
	<pre class="sh_java">

package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    public PinoTest() {
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }
    // TODO add test methods here.
    // The methods must be annotated with annotation @Test. For example:
    //
    // @Test
    // public void hello() {}
}
</pre>
	<p>Meille oleellisia osia luokassa <code>PinoTest</code>ovat metodit <code>public void setUp</code>, jonka yl&auml;puolella on merkint&auml; <code>@Before</code>, ja kommentoitu metodipohja <code>public void hello()</code>, jonka yl&auml;puolella on merkint&auml; <code>@Test</code>. Metodit, joiden yl&auml;puolella on merkint&auml; <code>@Test</code>ovat ohjelman toiminnallisuutta testaavia testimetodeja. Metodi <code>setUp</code>taas suoritetaan ennen jokaista testi&auml;.</p>
	<p>Muokataan luokkaa <code>PinoTest</code>siten, ett&auml; sill&auml; testataan rajapinnan <code>Pino</code>toteuttamaa luokkaa <code>OmaPino</code>. &Auml;l&auml; v&auml;lit&auml; vaikkei luokkaa <code>OmaPino</code>ole viel&auml; luotu. Pino on testiluokan oliomuuttuja, joka alustetaan ennen jokaista testi&auml; metodissa <code>setUp</code>.</p>
	<pre class="sh_java">

package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    Pino pino;

    @Before
    public void setUp() {
        pino = new OmaPino(3);
    }

    @Test
    public void alussaTyhja() {
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisayksenJalkeenEiTyhja() {
        pino.pinoon(5);
        assertFalse(pino.tyhja());
    }

    @Test
    public void lisattyAlkioTuleePinosta() {
        pino.pinoon(3);
        assertEquals(3, pino.pinosta());
    }

    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisatytAlkiotTulevatPinostaOikeassaJarjestyksessa() {
        pino.pinoon(1);
        pino.pinoon(2);
        pino.pinoon(3);

        assertEquals(3, pino.pinosta());
        assertEquals(2, pino.pinosta());
        assertEquals(1, pino.pinosta());
    }

    @Test
    public void tyhjennyksenJalkeenPinoonLaitettuAlkioTuleeUlosPinosta() {
        pino.pinoon(1);
        pino.pinosta();

        pino.pinoon(5);

        assertEquals(5, pino.pinosta());
    }

    // ...
}
</pre>
	<p>Jokainen testi, eli merkinn&auml;ll&auml; <code>@Test</code>varustettu metodi, alkaa tilanteesta, jossa on luotu uusi tyhj&auml; pino. Jokainen yksitt&auml;inen @Test-merkitty metodi on oma testins&auml;. Yksitt&auml;isell&auml; testimetodilla testataan aina yht&auml; pient&auml; osaa pinon toiminnallisuudesta. Testit suoritetaan toisistaan t&auml;ysin riippumattomina, eli jokainen testi alkaa &quot;puhtaalt&auml; p&ouml;yd&auml;lt&auml;&quot;, <code>setUp</code>-metodin alustamasta tilanteesta.</p>
	<p>Yksitt&auml;iset testit noudattavat aina samaa kaavaa. Ensin luodaan tilanne jossa tapahtuvaa toimintoa halutaan testata, sitten tehd&auml;&auml;n testattava toimenpide, ja lopuksi tarkastetaan onko tilanne odotetun kaltainen. Esimerkiksi seuraava testi testaa ett&auml; lis&auml;yksen ja poiston j&auml;lkeen pino on taas tyhj&auml; -- huomaa my&ouml;s kuvaava testimetodin niment&auml;:</p>
	<pre class="sh_java">

    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }
</pre>
	<p>Yll&auml;oleva testi testaa toimiiko metodi <code>tyhja()</code>jos pino on tyhjennetty. Ensin laitetaan pinoon luku metodilla <code>pinoon</code>, jonka j&auml;lkeen pino tyhjennet&auml;&auml;n kutsumalla metodia <code>pinosta()</code>. T&auml;ll&ouml;in on saatu aikaan tilanne jossa pinon <em>pit&auml;isi</em> olla tyhjennetty. Viimeisell&auml; rivill&auml; testataan, ett&auml; pinon metodi <code>tyhja()</code>palauttaa arvon <code>true</code>testausmetodilla <code>assertTrue()</code>. Jos metodi <code>tyhja()</code>ei palauta arvoa <code>true</code>n&auml;emme testej&auml; suorittaessa virheen.</p>
	<p>Jokainen testi p&auml;&auml;ttyy jonkun <code>assert</code>-metodin kutsuun. Esimerkiksi metodilla <code>assertEquals()</code>voidaan varmistaa onko metodin palauttama luku tai merkkijono haluttu, ja metodilla <code>assertTrue()</code>varmistetaan ett&auml; metodin palauttama arvo on <code>true</code>. Erilaiset <code>assert</code>-metodit saadaan k&auml;ytt&ouml;&ouml;n luokan alussa olevalla m&auml;&auml;rittelyll&auml; <code>import static org.junit.Assert.*;</code>.</p>
	<p>Testit suoritetaan joko painamalla <em>alt</em> ja <em>F6</em> tai valitsemalla <em>Run -&gt; Test project</em>. (Macintosh-koneissa tulee painaa <em>ctrl</em> ja <em>F6</em>). Punainen v&auml;ri ilmaisee ett&auml; testin suoritus ep&auml;onnistui -- testattava toiminnallisuus ei toiminut kuten toivottiin. Vihre&auml; v&auml;ri kertoo ett&auml; testin testaama toiminnallisuus toimi kuten haluttiin.</p>
	<h4 class="req">
		Luokan OmaPino toteutus</h4>
	<p>Pinon toteuttaminen testien avulla tapahtuisi askel kerrallaan siten, ett&auml; lopulta kaikki testit toimivat. Ohjelman rakentaminen aloitetaan yleens&auml; hyvin varovasti. Rakennetaan ensin luokka <code>OmaPino</code>siten, ett&auml; ensimm&auml;inen testi <em>alussaTyhja</em> alkaa toimimaan. &Auml;l&auml; tee mit&auml;&auml;n kovin monimutkaista, &quot;quick and dirty&quot;-ratkaisu kelpaa n&auml;in alkuun. Kun testi menee l&auml;pi (eli n&auml;ytt&auml;&auml; vihre&auml;&auml;), siirry ratkaisemaan seuraavaa kohtaa.</p>
	<p>Testi <em>alussaTyhja</em> menee l&auml;pi aina kun palautamme arvon <code>true</code>metodista <code>tyhja</code>.</p>
	<pre class="sh_java">

package pino;

import java.util.ArrayList;
import java.util.List;

public class OmaPino implements Pino {

    public OmaPino(int maksimikoko) {
    }

    @Override
    public boolean tyhja() {
        return true;
    }

    // tyhj&auml;t metodirungot
</pre>
	<p>Siirryt&auml;&auml;n ratkaisemaan kohtaa <em>lisayksenJalkeenEiTyhja</em>. Tarvitsemme toteutuksen metodille <code>pinoon</code>. Yksi l&auml;hestymistapa on muokata luokkaa <code>OmaPino</code>siten, ett&auml; se sis&auml;lt&auml;&auml; taulukon. Taulukkoa k&auml;ytet&auml;&auml;n, ett&auml; pinottavat luvut talletetaan pinon taulukkoon yksi kerrallaan. Seuraava kuvasarja selkeytt&auml;&auml; taulukossa olevien alkioiden pinoon laittamista ja pinosta ottamista.</p>
	<pre>

pino = new OmaPino(4);

  0   1   2   3
-----------------
|   |   |   |   |
-----------------
alkioita: 0

pino.pinoon(5);

  0   1   2   3
-----------------
| 5 |   |   |   |
-----------------
alkiota: 1

pino.pinoon(3);

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2

pino.pinoon(7);

  0   1   2   3
-----------------
| 5 | 3 | 7 |   |
-----------------
alkiota: 3

pino.pinosta();

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2
</pre>
	<p>Ohjelman tulee siis muistaa kuinka monta alkiota pinossa on. Uusi alkio laitetaan jo pinossa olevien per&auml;&auml;n. Alkion poisto aiheuttaa sen, ett&auml; taulukon viimeinen k&auml;yt&ouml;ss&auml; ollut paikka vapautuu ja alkiom&auml;&auml;r&auml;n muistavan muuttujan arvo pienenee.</p>
	<p>Luokan <code>OmaPino</code>toteutusta jatketaan askel kerrallaan kunnes kaikki testit menev&auml;t l&auml;pi. Jossain vaiheessa ohjelmoija todenn&auml;k&ouml;isesti huomaisi, ett&auml; taulukko kannattaa vaihtaa <code>ArrayList</code>-rakenteeksi.</p>
	<p>Huomaat todenn&auml;k&ouml;isesti yll&auml;olevan esimerkin luettuasi ett&auml; olet jo tehnyt hyvin monta testej&auml; k&auml;ytt&auml;v&auml;&auml; ohjelmaa. Osa TMC:n toiminnallisuudesta rakentuu JUnit-testien varaan, ongelmat ovat varsinkin kurssin alkupuolella pilkottu pieniin testeihin, joiden avulla ohjelmoijaa on ohjattu eteenp&auml;in. TMC:n mukana tulevat testit ovat kuitenkin usein monimutkaisempia kuin ohjelmien normaalissa automaattisessa testauksessa niiden tarvitsee olla. TMC:ss&auml; ja kurssilla k&auml;ytett&auml;vien testien kirjoittajien tulee muunmuassa varmistaa luokkien olemassaolo, jota normaalissa automaattisessa testauksessa harvemmin tarvitsee tehd&auml;.</p>
	<p>Harjoitellaan seuraavaksi ensin testien lukemista, jonka j&auml;lkeen kirjoitetaan muutama testi.</p>
	<div class="tehtavat">
		<h3>
			Teht&auml;v&auml;lista</h3>
		<p>Teht&auml;v&auml;pohjassa on rajapinnan <code>Tehtavalista</code>toteuttava luokka <code>MuistiTehtavalist</code>. Ohjelmaa varten on koodattu valmiiksi testit, joita ohjelma ei kuitenkaan l&auml;p&auml;ise. Teht&auml;v&auml;n&auml;si on tutustua testiluokkaan <code>TehtavalistaTest</code>, ja korjata luokka <code>MuistiTehtavalista</code>siten, ett&auml; ohjelman testit menev&auml;t l&auml;pi.</p>
		<p>Huom! T&auml;ss&auml; teht&auml;v&auml;ss&auml; sinun ei tarvitse koskea testiluokkaan <code>TehtavalistaTest</code>.</p>
		<h3>
			Lukutilasto</h3>
		<p><em>Huom!</em> T&auml;ss&auml; teht&auml;v&auml;ss&auml; on jo mukana testiluokka, johon sinun tulee kirjoittaa lis&auml;&auml; testej&auml;. Vastauksen oikeellisuus testataan vasta TMC-palvelimella: teht&auml;v&auml;st&auml; saa pisteet vasta kun <em>molemmat</em> teht&auml;v&auml;t on suoritettu palvelimella hyv&auml;ksytysti. Ole tarkka metodien nimenn&auml;n <em>ja</em> lis&auml;ttyjen lukujen kanssa.</p>
		<p>Teht&auml;v&auml;ss&auml; tulee pakkauksessa <code>tilasto</code>sijaitseva luokka <code>Lukutilasto</code>.</p>
		<ul>
			<li>
				<code>public void lisaaLuku(int luku)</code><br />
				Lis&auml;&auml; annetun luvun lukutilastoon.</li>
			<li>
				<code>public int summa()</code><br />
				Palauttaa tilastossa olevien lukujen summan.</li>
			<li>
				<code>public int lukujenMaara()</code><br />
				Palauttaa tilastossa olevien lukujen maaran.</li>
			<li>
				<code>public boolean sisaltaa(int luku)</code><br />
				Palauttaa totuusarvon, joka kertoo onko parametrina annettu luku tilastossa.</li>
		</ul>
		<p>Testikansiossa olevassa pakkauksessa <code>tilasto</code>on luokka <code>LukutilastoTest</code>, johon sinun tulee lis&auml;t&auml; uusia testimetodeja.</p>
		<h4>
			Lukujen m&auml;&auml;r&auml;n kasvamisen tarkistus</h4>
		<p>Lis&auml;&auml; testiluokkaan testimetodi <code>public void lukujenMaaraKasvaaKahdellaKunLisataanKaksiLukua()</code>, jossa lukutilastoon lis&auml;t&auml;&auml;n luvut 3 ja 5. T&auml;m&auml;n j&auml;lkeen metodissa tarkistetaan ett&auml; lukutilastossa on kaksi lukua k&auml;ytt&auml;en lukutilaston metodia lukujenMaara. K&auml;yt&auml; <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>
		<h4>
			Summan tarkistus yhdell&auml; luvulla</h4>
		<p>Lis&auml;&auml; testiluokkaan testimetodi <code>public void summaOikeinYhdellaLuvulla()</code>, jossa lukutilastoon lis&auml;t&auml;&auml;n luku 3. T&auml;m&auml;n j&auml;lkeen metodissa tarkistetaan lukutilaston summa-metodin avulla ett&auml; tilastossa olevien lukujen summa on 3. K&auml;yt&auml; <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>
	</div>
	<h2 id="kalit">
		K&auml;ytt&ouml;liittym&auml;t</h2>
	<p>&nbsp;</p>
	<hr />
	<p>&nbsp;</p>
	<p><big>Huom! Osa k&auml;ytt&ouml;liittym&auml;teht&auml;vien testeist&auml; avaa k&auml;ytt&ouml;liittym&auml;n ja k&auml;ytt&auml;&auml; hiirt&auml;si k&auml;ytt&ouml;liittym&auml;komponenttien klikkailuun. Kun suoritat k&auml;ytt&ouml;liittym&auml;teht&auml;vien testej&auml;, &auml;l&auml; k&auml;yt&auml; hiirt&auml;si!</big></p>
	<p>&nbsp;</p>
	<hr />
	<p>&nbsp;</p>
	<p>Ohjelmamme ovat t&auml;h&auml;n menness&auml; koostuneet l&auml;hinn&auml; sovelluslogiikasta ja sovelluslogiikkaa k&auml;ytt&auml;v&auml;st&auml; tekstik&auml;ytt&ouml;liittym&auml;st&auml;. Muutamissa teht&auml;viss&auml; on ollut my&ouml;s graafinen k&auml;ytt&ouml;liittym&auml;, mutta ne on yleens&auml; luotu puolestamme. Tutustutaan seuraavaksi graafisten k&auml;ytt&ouml;liittymien luomiseen Javalla.</p>
	<p>K&auml;ytt&ouml;liittym&auml;t ovat ikkunoita, jotka sis&auml;lt&auml;v&auml;t erilaisia osia kuten nappeja, tekstikentti&auml; ja valikkoja. K&auml;ytt&ouml;liittymien ohjelmoinnissa k&auml;ytet&auml;&auml;n Javan <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">Swing</a>-komponenttikirjastoa, joka tarjoaa luokkia k&auml;ytt&ouml;liittym&auml;komponenttien luomiseen ja k&auml;sittelyyn.</p>
	<p>K&auml;ytt&ouml;liittymien peruselementti on luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFrame.html" target="_blank">JFrame</a></code>, jonka sis&auml;lt&auml;m&auml;&auml;n komponenttiosioon k&auml;ytt&ouml;liittym&auml;komponentit luodaan. K&auml;ytt&ouml;liittym&auml;t ovat <em>suoritettavia</em>, ja ne tulee k&auml;ynnist&auml;&auml; erikseen. K&auml;yt&auml;mme kurssilla seuraavanlaista k&auml;ytt&ouml;liittym&auml;runkoa, jonka p&auml;&auml;lle rakennamme toiminnallisuutta.</p>
	<pre class="sh_java">

import java.awt.Container;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class Kayttoliittyma implements Runnable {

    private JFrame frame;

    public Kayttoliittyma() {
    }

    @Override
    public void run() {
        frame = new JFrame(&quot;Otsikko&quot;);
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }

    private void luoKomponentit(Container container) {
    }

    public JFrame getFrame() {
        return frame;
    }
}
</pre>
	<p>Tarkastellaan yll&auml;olevan k&auml;ytt&ouml;liittym&auml;luokan koodia hieman tarkemmin.</p>
	<pre class="sh_java">

public class Kayttoliittyma implements Runnable {
</pre>
	<p>Luokka <code>Kayttoliittyma</code>toteuttaa Javan rajapinnan <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Runnable.html" target="_blank">Runnable</a>, joka tarjoaa mahdollisuuden s&auml;ikeistettyyn ohjelman suorittamiseen. S&auml;ikeistetyll&auml; suorittamisella voidaan suorittaa useita ohjelman osia rinnakkain. Emme tutustu s&auml;ikeisiin tarkemmin -- lis&auml;&auml; tietoa s&auml;ikeist&auml; tulee muunmuassa kurssilla <em>Rinnakkaisohjelmointi</em>.</p>
	<pre class="sh_java">

    private JFrame frame;
</pre>
	<p>K&auml;ytt&ouml;liittym&auml; sis&auml;lt&auml;&auml; oliomuuttujana <code>JFrame</code>-olion -- ikkunan --, joka on n&auml;kyv&auml;n k&auml;ytt&ouml;liittym&auml;n pohjaelementti. Kaikki k&auml;ytt&ouml;liittym&auml;komponentit lis&auml;t&auml;&auml;n <code>JFrame</code>-olion sis&auml;lt&auml;m&auml;&auml;n komponenttialueeseen. Huomaa ett&auml; oliomuuttujia ei saa alustaa metodien ulkopuolella. Esimerkiksi oliomuuttujan <code>JFrame</code>alustus luokkam&auml;&auml;rittelyss&auml; <code>"private JFrame frame = new JFrame()"</code>kiert&auml;&auml; k&auml;ytt&ouml;liittym&auml;s&auml;ikeiden suoritusj&auml;rjestyksen, ja voi johtaa ydintuhoon. Tai ohjelmasi kaatumiseen.</p>
	<pre class="sh_java">

    @Override
    public void run() {
        frame = new JFrame(&quot;Otsikko&quot;);
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }
</pre>
	<p>Rajapinta <code>Runnable</code>m&auml;&auml;rittelee metodin <code>public void run()</code>, joka jokaisen <code>Runnable</code>-rajapinnan toteuttajan tulee toteuttaa. Metodissa <code>public void run()</code>luodaan ensin uusi JFrame-ikkuna, jonka otsikoksi asetetaan <code>"Otsikko"</code>. T&auml;m&auml;n j&auml;lkeen asetetaan ikkunan toivotuksi kooksi 200, 100 -- leveydeksi tulee 200 pikseli&auml;, korkeudeksi 100 pikseli&auml;. Komento <code>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code>kertoo JFrame-oliolle, ett&auml; k&auml;ytt&ouml;liittym&auml; tulee sulkea kun k&auml;ytt&auml;j&auml; painaa k&auml;ytt&ouml;liittym&auml;ss&auml; olevaa ruksia.</p>
	<p>T&auml;m&auml;n j&auml;lkeen kutsutaan luokassa my&ouml;hemmin m&auml;&auml;ritelty&auml; metodia <code>luoKomponentit</code>. Metodille annetaan parametrina <code>JFrame</code>-olion <em><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Container.html" target="_blank">Container</a></em>-olio, johon voi lis&auml;t&auml; k&auml;ytt&ouml;liittym&auml;komponentteja.</p>
	<p>Lopuksi kutsutaan metodia <code>frame.pack()</code>, joka asettaa JFrame-olion aiemmin m&auml;&auml;ritellyn kokoiseksi ja j&auml;rjest&auml;&auml; JFrame-olion sis&auml;lt&auml;m&auml;n Container-olion sis&auml;ll&auml; olevat k&auml;ytt&ouml;liittym&auml;komponentit. Lopuksi kutsutaan metodia <code>frame.setVisible(true)</code>, joka n&auml;ytt&auml;&auml; k&auml;ytt&ouml;liittym&auml;n k&auml;ytt&auml;j&auml;lle.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
    }
</pre>
	<p>Metodissa <code>luoKomponentit</code>lis&auml;t&auml;&auml;n <code>JFrame</code>-olion sis&auml;lt&auml;m&auml;&auml;n komponenttialueeseen k&auml;ytt&ouml;liittym&auml;komponentteja. Esimerkiss&auml;mme ei ole yht&auml;k&auml;&auml;n k&auml;ytt&ouml;liittym&auml;komponenttia JFrame-ikkunan lis&auml;ksi. Luokalla <code>Kayttoliittyma</code>on my&ouml;s sen k&auml;ytt&ouml;&auml; helpottava metodi <code>getFrame</code>, jolla p&auml;&auml;st&auml;&auml;n k&auml;siksi luokan kapseloimaan JFrame-olioon.</p>
	<p>Swing-k&auml;ytt&ouml;liittym&auml;t k&auml;ynnistet&auml;&auml;n <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingUtilities.html" target="_blank">SwingUtilities</a></code>-luokan tarjoaman <code>invokeLater</code>-metodin avulla. Metodi <code>invokeLater</code>saa parametrinaan <code>Runnable</code>-rajapinnan toteuttavan olion. Metodi asettaa <code>Runnable</code>-olion suoritusjonoon, ja kutsuu sit&auml; kun ehtii. Luokan <code>SwingUtilities</code>avulla voimme k&auml;ynnist&auml;&auml; uusia s&auml;ikeit&auml; tarvittaessa.</p>
	<pre class="sh_java">

import javax.swing.SwingUtilities;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma();
        SwingUtilities.invokeLater(kayttoliittyma);
    }
}
</pre>
	<p>Kun yll&auml;oleva p&auml;&auml;ohjelmametodi suoritetaan, n&auml;emme luokassa <code>Kayttoliittyma</code>m&auml;&auml;rittellyn k&auml;ytt&ouml;liittym&auml;n.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/eka-kali.png" /></p>
	<h3>
		K&auml;ytt&ouml;liittym&auml;komponentit</h3>
	<p>K&auml;ytt&ouml;liittym&auml; koostuu taustaikkunan (JFrame) sis&auml;lt&auml;m&auml;st&auml; komponenttipohjasta (Container), ja siihen asetetuista k&auml;ytt&ouml;liittym&auml;komponenteista. K&auml;ytt&ouml;liittym&auml;komponentteja ovat erilaiset painikkeet, tekstit ym. Jokaiselle komponentille on oma luokka. Kannattaa tutustua Oraclen visuaalinen kuvasarjaan erilaisista komponenteista osoitteessa <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">http://docs.oracle.com/javase/tutorial/ui/features/components.html</a>.</p>
	<h4>
		Teksti</h4>
	<p>Tekstin n&auml;ytt&auml;minen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JLabel.html" target="_blank">JLabel</a></code>-luokan avulla. Luokka <code>JLabel</code>tarjoaa k&auml;ytt&ouml;liittym&auml;komponentin, jolle voi asettaa teksti&auml; ja jonka sis&auml;lt&auml;m&auml;&auml; teksti&auml; voi muokata. Teksti asetetaan joko konstruktorissa tai erillisell&auml; <code>setText</code>-metodilla.</p>
	<p>Muokataan k&auml;ytt&ouml;liittym&auml;pohjaamme siten, ett&auml; siin&auml; n&auml;kyy teksti&auml;. Luodaan uusi JLabel-tekstikomponentti metodissa <code>luoKomponentit</code>. T&auml;m&auml;n j&auml;lkeen lis&auml;t&auml;&auml;n se <code>JFrame</code>-oliolta saatuun <code>Container</code>-olioon <code>Container</code>-olion <code>add</code>-metodia k&auml;ytt&auml;en.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        JLabel teksti = new JLabel(&quot;Tekstikentt&auml;!&quot;);
        container.add(teksti);
    }
</pre>
	<p>Kuten yll&auml; olevasta l&auml;hdekoodista n&auml;emme, JLabel-k&auml;ytt&ouml;liittym&auml;komponentti tulee n&auml;ytt&auml;m&auml;&auml;n tekstin <code>"Tekstikenttä!"</code>. Kun suoritamme k&auml;ytt&ouml;liittym&auml;n, n&auml;emme seuraavanlaisen ikkunan.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kali-tekstikentta.png" /></p>
	<div class="tehtavat">
		<h3>
			Tervehtij&auml;</h3>
		<p>Toteuta k&auml;ytt&ouml;liittym&auml;, joka n&auml;ytt&auml;&auml; tekstin &quot;Moi!&quot;. Teht&auml;v&auml; tulee toteuttaa teht&auml;v&auml;pohjassa tulevaan k&auml;ytt&ouml;liittym&auml;runkoon. JFrame-olion luominen ja n&auml;kyv&auml;ksi asettamisen tulee tapahtua metodissa <code>run()</code>, tekstikomponentti lis&auml;t&auml;&auml;n k&auml;ytt&ouml;liittym&auml;lle metodissa <code>luoKomponentit(Container container)</code>.</p>
	</div>
	<h4>
		Painikkeet</h4>
	<p>K&auml;ytt&ouml;liittym&auml;&auml;n saa painikkeita <code>JButton</code>-luokan avulla. JButton-olion lis&auml;&auml;minen k&auml;ytt&ouml;liittym&auml;&auml;n tapahtuu aivan kuin JLabel-olion lis&auml;&auml;minen.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        JButton nappi = new JButton(&quot;Click!&quot;);
        container.add(nappi);
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kali-nappi.png" /></p>
	<p>Yritet&auml;&auml;n seuraavaksi lis&auml;t&auml; k&auml;ytt&ouml;liittym&auml;&auml;n sek&auml; teksti&auml;, ett&auml; nappi.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        JButton nappi = new JButton(&quot;Click!&quot;);
        container.add(nappi);
        JLabel teksti = new JLabel(&quot;Teksti&auml;.&quot;);
        container.add(teksti);
    }
</pre>
	<p>Ohjelmaa suorittaessa n&auml;emme seuraavanlaisen k&auml;ytt&ouml;liittym&auml;n.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kali-tarve-asettelulle.png" /></p>
	<p>Vain viimeiseksi lis&auml;tty k&auml;ytt&ouml;liittym&auml;komponentti on n&auml;kyvill&auml;, eik&auml; ohjelma toimi toivotusti. Mist&auml; t&auml;ss&auml; oikein on kyse?</p>
	<h3>
		K&auml;ytt&ouml;liittym&auml;komponenttien asettelu</h3>
	<p>Jokaisella k&auml;ytt&ouml;liittym&auml;komponentilla on oma sijainti k&auml;ytt&ouml;liittym&auml;ss&auml;. Komponentin sijainnin m&auml;&auml;r&auml;&auml; k&auml;yt&ouml;ss&auml; oleva k&auml;ytt&ouml;liittym&auml;n asettelija (<em>Layout Manager</em>). Yritt&auml;ess&auml;mme aiemmin lis&auml;t&auml; useampia k&auml;ytt&ouml;liittym&auml;komponentteja <code>Container</code>-olioon k&auml;ytt&ouml;liittym&auml;ss&auml; oli vain yksi komponentti n&auml;kyvill&auml;. Jokaisessa <code>Container</code>-oliossa on oletuksena k&auml;ytt&ouml;liittym&auml;asettelija <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a></code>.</p>
	<p>BorderLayout asettelee k&auml;ytt&ouml;liittym&auml;komponentit viiteen alueeseen: k&auml;ytt&ouml;liittym&auml;n keskikohdan lis&auml;ksi k&auml;yt&ouml;ss&auml; on ilmansuunnat. Voimme antaa Container-olion <code>add</code>-metodille ylim&auml;&auml;r&auml;isen&auml; parametrina lis&auml;toiveen kohdasta, johon haluamme asettaa k&auml;ytt&ouml;liittym&auml;komponentin. BorderLayout-luokassa on k&auml;yt&ouml;ss&auml; luokkamuuttujat <code>BorderLayout.NORTH</code>, <code>BorderLayout.EAST</code>, <code>BorderLayout.SOUTH</code>, <code>BorderLayout.WEST</code>, ja <code>BorderLayout.CENTER</code>.</p>
	<p>K&auml;ytett&auml;v&auml; k&auml;ytt&ouml;liittym&auml;asettelija asetetaan <code>Container</code>-oliolle metodin <code>setLayout</code>-parametrina. Metodille <code>add</code>voidaan antaa k&auml;ytt&ouml;liittym&auml;komponentin lis&auml;ksi paikka, johon komponentti lis&auml;t&auml;&auml;n. Alla on esimerkki, jossa jokaiseen BorderLayoutin tarjoamaan paikkaan asetetaan k&auml;ytt&ouml;liittym&auml;komponentti.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        container.setLayout(new BorderLayout());

        container.add(new JButton(&quot;Pohjoinen (North)&quot;), BorderLayout.NORTH);
        container.add(new JButton(&quot;It&auml; (East)&quot;), BorderLayout.EAST);
        container.add(new JButton(&quot;Etel&auml; (South)&quot;), BorderLayout.SOUTH);
        container.add(new JButton(&quot;L&auml;nsi (West)&quot;), BorderLayout.WEST);
        container.add(new JButton(&quot;Keski (Center)&quot;), BorderLayout.CENTER);

        container.add(new JButton(&quot;Oletuspaikka (Center)&quot;));
    }
</pre>
	<p>Huomaa, ett&auml; nappi <code>"Keski (Center)"</code>ei tule n&auml;kym&auml;&auml;n k&auml;ytt&ouml;liittym&auml;ss&auml; sill&auml; nappi <code>"Oletuspaikka (Center)"</code>asetetaan oletuksena sen paikalle. K&auml;ytt&ouml;liittym&auml;ss&auml;pohjassa yll&auml; oleva koodi n&auml;ytt&auml;&auml; seuraavalta.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/layout-borderlayout.png" /></p>
	<p>Kuten k&auml;ytt&ouml;liittym&auml;komponentteja, my&ouml;s k&auml;ytt&ouml;liittym&auml;n asettelijoita on useita. Oraclella on k&auml;ytt&ouml;liittym&auml;asettelijoihin visuaalinen opas osoitteessa <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html</a>. Tutustutaan seuraavaksi k&auml;ytt&ouml;liittym&auml;asettelijaan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/BoxLayout.html" target="_blank">BoxLayout</a></code>.</p>
	<h4>
		BoxLayout</h4>
	<p>BoxLayoutia k&auml;ytett&auml;ess&auml; k&auml;ytt&ouml;liittym&auml;komponentit asetetaan k&auml;ytt&ouml;liittym&auml;&auml;n joko vaakasuunnassa tai pystysuunnassa. BoxLayoutin konstruktorille annetaan parametrina Container-olio, johon k&auml;ytt&ouml;liittym&auml;komponentteja ollaan asettamassa, ja k&auml;ytt&ouml;liittym&auml;komponenttien asettelusuunta. Asettelusuunta on joko <code>BoxLayout.X_AXIS</code>, eli komponentit vaakasuunnassa, tai <code>BoxLayout.Y_AXIS</code>, eli komponentit pystysuunnassa. Toisin kuin BorderLayout-asettelijaa k&auml;ytett&auml;ess&auml;, BoxLayoutilla ei ole rajattua m&auml;&auml;r&auml;&auml; paikkoja. Container-olioon voi siis lis&auml;t&auml; niin monta k&auml;ytt&ouml;liittym&auml;komponenttia kuin haluaa.</p>
	<p>K&auml;ytt&ouml;liittym&auml;n asettelu <code>BoxLayout</code>-asettelijaa k&auml;ytt&auml;en toimii kuten <code>BorderLayout</code>-asettelijan k&auml;ytt&ouml;. Luomme ensin asettelijan, jonka asetamme <code>Container</code>-oliolle sen metodilla <code>setLayout</code>. T&auml;m&auml;n j&auml;lkeen voimme lis&auml;t&auml; k&auml;ytt&ouml;liittym&auml;komponentteja <code>Container</code>-olion <code>add</code>-metodilla. Emme tarvitse erillist&auml; sijaintia ilmaisevaa parametria. Alla esimerkki vaakasuunnassa asetetuista k&auml;ytt&ouml;liittym&auml;komponenteista.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.X_AXIS);
        container.setLayout(layout);

        container.add(new JLabel(&quot;Eka!&quot;));
        container.add(new JLabel(&quot;Toka!&quot;));
        container.add(new JLabel(&quot;Kolmas!&quot;));
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/boxlayout-x_axis.png" /></p>
	<p>K&auml;ytt&ouml;liittym&auml;komponenttien asettelu pystysuunnassa ei vaadi suurta muutosta. Vaihdamme <code>BoxLayout</code>-olion konstruktorille annettavaksi suuntaparametriksi <code>BoxLayout.Y_AXIS</code>.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel(&quot;Eka!&quot;));
        container.add(new JLabel(&quot;Toka!&quot;));
        container.add(new JLabel(&quot;Kolmas!&quot;));
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/boxlayout-y_axis.png" /></p>
	<p>K&auml;ytt&ouml;liittym&auml;asettelijoita k&auml;ytt&auml;m&auml;ll&auml; voimme luoda k&auml;ytt&ouml;liittymi&auml;, joissa k&auml;ytt&ouml;liittym&auml;komponentit ovat aseteltu sopivasti. Alla on esimerkkik&auml;ytt&ouml;liittym&auml;, jossa komponentit asetetaan pystysuuntaan. Ensin teksti, ja sitten vaihtoehtoinen valinta. Vaihtoehtoisen valinnan, eli valinnan jossa vain yksi vaihtoehto on aina voimassa, voi tehd&auml; k&auml;ytt&auml;m&auml;ll&auml; <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/ButtonGroup.html" target="_blank">ButtonGroup</a></code>-ryhmittelij&auml;&auml; ja <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JRadioButton.html" target="_blank">JRadioButton</a></code>-painikkeita.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel(&quot;Valitse ruokavalio:&quot;));

        JRadioButton liha = new JRadioButton(&quot;Liha&quot;);
        JRadioButton kala = new JRadioButton(&quot;Kala&quot;);

        ButtonGroup buttonGroup = new ButtonGroup();
        buttonGroup.add(liha);
        buttonGroup.add(kala);

        container.add(liha);
        container.add(kala);
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/buttongroup-ruokavalio.png" /></p>
	<div class="tehtavat">
		<h3>
			Kysely</h3>
		<p>Toteuta teht&auml;v&auml;pohjaan k&auml;ytt&ouml;liittym&auml;, joka n&auml;ytt&auml;&auml; seuraavalta:</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/157-kysely.png" /></p>
		<p>K&auml;yt&auml; k&auml;ytt&ouml;liittym&auml;n asettelijana luokkaa <code>BoxLayout</code>, komponentteina luokkia <code>JLabel</code>, <code>JRadioButton</code>, <code>JCheckBox</code>ja <code>JButton</code>.</p>
		<p>K&auml;yt&auml; <code>ButtonGroup</code>-luokkaa varmistamaan ett&auml; vaihtoehdot &quot;Siksi&quot; ja &quot;Se on kivaa&quot; eiv&auml;t voi olla valittuina samaan aikaan.</p>
		<p>Varmista ett&auml; k&auml;ytt&ouml;liittym&auml; on niin iso, ett&auml; k&auml;ytt&auml;j&auml; voi klikata nappeja muuttamatta sen kokoa. Voit k&auml;ytt&auml;&auml; esimerkiksi leveyten&auml; 200 pikseli&auml;, korkeutena 300 pikseli&auml;.</p>
	</div>
	<h3>
		Tapahtumien k&auml;sittely</h3>
	<p>T&auml;h&auml;nastiset graafiset k&auml;ytt&ouml;liittym&auml;mme ovat -- vaikkakin hienoja -- hieman tylsi&auml;: ne eiv&auml;t reagoi mill&auml;&auml;n tavalla k&auml;ytt&ouml;liittym&auml;ss&auml; tehtyihin tapahtumiin. Reagoimattomuus ei johdu k&auml;ytt&ouml;liittym&auml;komponenteista, vaan siit&auml; ett&auml; emme ole lis&auml;nneet k&auml;ytt&ouml;liittym&auml;komponentteihin tapahtumia k&auml;sittelevi&auml; kuuntelijoita.</p>
	<p>Tapahtumankuuntelijat <em>kuuntelevat</em> k&auml;ytt&ouml;liittym&auml;komponentteja joihin ne on liitetty. Aina kun k&auml;ytt&ouml;liittym&auml;komponentille tehd&auml;&auml;n joku toiminto, -- esimerkiksi napille napin painaminen --, k&auml;ytt&ouml;liittym&auml;komponentti kutsuu jokaisen siihen liitetyn tapahtumakuuntelijan tietty&auml; metodia. K&auml;yt&auml;nn&ouml;ss&auml; tapahtumankuuntelijat ovat tietyn rajapinnan toteuttavia luokkia, joiden ilmentymi&auml; k&auml;ytt&ouml;liittym&auml;komponentille voi lis&auml;t&auml;. Tapahtuman tapahtuessa k&auml;ytt&ouml;liittym&auml;komponentti k&auml;y jokaisen siihen liitetyn tapahtumankuuntelijan l&auml;pi, ja kutsuu rajapinnassa m&auml;&auml;ritelty&auml; metodia.</p>
	<p>Swing-k&auml;ytt&ouml;liittymiss&auml; eniten k&auml;ytetty tapahtumankuuntelurajapinta on <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionListener.html">ActionListener</a></code>. Rajapinta <code>ActionListener</code>m&auml;&auml;rittelee metodin <code>void actionPerformed(ActionEvent e)</code>, joka saa parametrinaan tapahtumasta kertovan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionEvent.html" target="_blank">ActionEvent</a></code>-olion.</p>
	<p>Toteutetaan ensimm&auml;inen oma tapahtumankuuntelija, jonka tarkoituksena on vain tulostaa viesti standarditulostusvirtaan nappia painettaessa. Luokka <code>ViestiKuuntelija</code>toteuttaa rajapinnan <code>ActionListener</code>ja tulostaa viestin <code>"Viesti vastaanotettu!"</code>kun metodia <code>actionPerformed</code>kutsutaan.</p>
	<pre class="sh_java">

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ViestiKuuntelija implements ActionListener {

    @Override
    public void actionPerformed(ActionEvent ae) {
        System.out.println(&quot;Viesti vastaanotettu!&quot;);
    }
}
</pre>
	<p>Luodaan seuraavaksi k&auml;ytt&ouml;liittym&auml;&auml;n <code>JButton</code>-tyyppinen nappi, ja lis&auml;t&auml;&auml;n siihen <code>ViestiKuuntelija</code>-luokan ilmentym&auml;. Luokalle <code>JButton</code>voi lis&auml;t&auml; tapahtumankuuntelijan k&auml;ytt&auml;m&auml;ll&auml; sen yl&auml;luokassa <code>AbstractButton</code>m&auml;&auml;ritelty&auml; metodia <code>public void addActionListener(ActionListener actionListener)</code>.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        JButton nappi = new JButton(&quot;Viestit&auml;!&quot;);
        nappi.addActionListener(new ViestiKuuntelija());

        container.add(nappi);
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kali-actionlistener-viestita.png" /></p>
	<p>K&auml;ytt&ouml;liittym&auml;ss&auml; olevaa nappia painettaessa n&auml;emme standarditulostusvirrassa seuraavan viestin.</p>
	<pre>

Viesti vastaanotettu!
</pre>
	<h4>
		Olioiden k&auml;sittely tapahtumankuuntelijoissa</h4>
	<p>Haluamme usein ett&auml; tapahtumankuuntelija muokkaa jonkun olion tilaa. P&auml;&auml;st&auml;ksemme olioon k&auml;siksi tapahtumankuuntelijassa, tulee meid&auml;n antaa viite k&auml;sitelt&auml;v&auml;&auml;n olioon tapahtumankuuntelijalle sen konstruktorissa. Tapahtumankuuntelijat ovat t&auml;ysin samanlaisia luokkia kuin muutkin Javan luokat, eli p&auml;&auml;semme ohjelmoimaan kaiken haluamamme toiminnallisuuden.</p>
	<p>Pohditaan seuraavaa k&auml;ytt&ouml;liittym&auml;&auml; jossa on kaksi <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextArea.html" target="_blank">JTextArea</a></code>-tyyppist&auml; tekstikentt&auml;&auml;, eli tekstikentt&auml;&auml; johon k&auml;ytt&auml;j&auml; voi sy&ouml;tt&auml;&auml; teksti&auml;, ja <code>JButton</code>-tyyppinen nappi. K&auml;ytt&ouml;liittym&auml; k&auml;ytt&auml;&auml; <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/GridLayout.html" target="_blank">GridLayout</a></code>-asettelijaa, jonka avulla k&auml;ytt&ouml;liittym&auml;n voi rakentaa taulukkomaiseksi. GridLayout-luokan konstruktorille m&auml;&auml;riteltiin yksi rivi ja kolme saraketta.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea(&quot;Le Kopioija&quot;);
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton(&quot;Kopioi!&quot;);

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kopioija-alku.png" /></p>
	<p>Haluamme lis&auml;t&auml; k&auml;ytt&ouml;liittym&auml;&auml;n toiminnallisuuden, jossa <code>JButton</code>-nappia painettaessa vasemman tekstikent&auml;n sis&auml;lt&ouml; kopioituu oikeaan tekstikentt&auml;&auml;n. T&auml;m&auml; onnistuu toteuttamalla tapahtumankuuntelija. Luodaan rajapinnan <code>ActionListener</code>toteuttava luokka <code>KenttienKopioija</code>, joka kopioi JTextArea kent&auml;st&auml; toiseen.</p>
	<pre class="sh_java">

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JTextArea;

public class KenttienKopioija implements ActionListener {

    private JTextArea lahde;
    private JTextArea kohde;

    public KenttienKopioija(JTextArea lahde, JTextArea kohde) {
        this.lahde = lahde;
        this.kohde = kohde;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        this.kohde.setText(this.lahde.getText());
    }
}
</pre>
	<p>Tapahtumankuuntelijan rekister&ouml;inti <code>JButton</code>-oliolle onnistuu metodilla <code>addActionListener</code>.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea(&quot;Le Kopioija&quot;);
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton(&quot;Kopioi!&quot;);

        KenttienKopioija kopioija = new KenttienKopioija(textAreaVasen, textAreaOikea);
        kopioiNappi.addActionListener(kopioija);

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>
	<p>Nappia painettaessa vasemman tekstikent&auml;n sis&auml;lt&ouml; kopioituu oikealla olevaan tekstikentt&auml;&auml;n.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kopioija-valmis.png" /></p>
	<div class="tehtavat">
		<h3>
			Ilmoitin</h3>
		<p>Toteuta teht&auml;v&auml;pohjaan k&auml;ytt&ouml;liittym&auml;, joka n&auml;ytt&auml;&auml; seuraavalta.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/158-ilmoitin.png" /></p>
		<p>Ohjelman tulee koostua seuraavista pakkauksessa <code>ilmoitin</code>olevista luokista. Luokka <code>Ilmoitin</code>on k&auml;ytt&ouml;liittym&auml;luokka, joka k&auml;ynnistet&auml;&auml;n <code>Main</code>-luokasta. Ilmoittimessa on k&auml;ytt&ouml;liittym&auml;komponentteina <code>JTextField</code>, <code>JButton</code>, ja <code>JLabel</code>. Voit asetella k&auml;ytt&ouml;liittym&auml;komponentit <code>GridLayout</code>-asettelijan avulla: kutsu <code>new GridLayout(3, 1)</code>luo uuden asettelijan, joka asettelee kolme k&auml;ytt&ouml;liittym&auml;elementti&auml; pystysuunnassa.</p>
		<p>Sovelluksessa tulee olla lis&auml;ksi luokka <code>TapahtumanKuuntelija</code>, joka toteuttaa rajapinnan <code>ActionListener</code>. Tapahtumankuuntelijan tulee kopioida k&auml;ytt&ouml;liittym&auml;ss&auml; olevan JTextField-kent&auml;n sis&auml;lt&ouml; JLabel-kentt&auml;&auml;n. Ohjelman oleellinen toiminnallisuus on siis JTextField-kent&auml;n sis&auml;ll&ouml;n kopioiminen JLabel-kentt&auml;&auml;n napin painalluksella.</p>
		<p>Huom! Varmista ett&auml; k&auml;ytt&ouml;liittym&auml; k&auml;ynnistyy niin isona ett&auml; jokaista nappulaa voi klikata.</p>
	</div>
	<h3>
		Sovelluslogiikan ja k&auml;ytt&ouml;liittym&auml;logiikan eriytt&auml;minen</h3>
	<p>Sovelluslogiikan (esimerkiksi tallennus- tai lukutoiminnallisuuden) ja k&auml;ytt&ouml;liittym&auml;n sekoittaminen samoihin luokkiin on yleisesti ottaen huono asia. Se vaikeuttaa ohjelman testaamista ja muokkaamista huomattavasti, ja tekee koodista my&ouml;s paljon vaikeammin luettavaa. Single responsibility principlen sanoin &quot;Jokaisella luokalla pit&auml;isi olla vain yksi selke&auml; vastuu&quot;. Sovelluslogiikan erottaminen k&auml;ytt&ouml;liittym&auml;logiikasta onnistuu sopivan rajapintasuunnittelun kautta. Oletetaan ett&auml; k&auml;yt&ouml;ss&auml;mme on kappaleessa <a href="#56">56. Tallennustoiminnallisuuden eriytt&auml;minen</a> m&auml;&auml;ritelty rajapinta <code>HenkiloDAO</code>, ja haluamme toteuttaa k&auml;ytt&ouml;liittym&auml;n henkil&ouml;iden tallentamiseen.</p>
	<pre class="sh_java">

public interface HenkiloDAO {
    void talleta(Henkilo henkilo);
    Henkilo hae(String henkilotunnus);

    void poista(Henkilo henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Henkilo&gt; haeKaikki();
}
</pre>
	<h4>
		K&auml;ytt&ouml;liittym&auml;n toteutus</h4>
	<p>K&auml;ytt&ouml;liittym&auml;&auml; toteutettaessa hyv&auml; aloitustapa on sopivien k&auml;ytt&ouml;liittym&auml;komponenttien lis&auml;&auml;minen k&auml;ytt&ouml;liittym&auml;&auml;n. Henkil&ouml;iden tallennuksessa tarvitsemme kent&auml;t nimelle ja henkil&ouml;tunnukselle, sek&auml; napin jolla henkil&ouml; voidaan lis&auml;t&auml;. K&auml;ytet&auml;&auml;n Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextField.html" target="_blank">JTextField</a></code>-luokkaa tekstin sy&ouml;tt&auml;miseen, ja <code>JButton</code>-luokkaa napin toteuttamiseen. Luodaan k&auml;ytt&ouml;liittym&auml;&auml;n lis&auml;ksi selvent&auml;v&auml;t <code>JLabel</code>-tyyppiset selitystekstit.</p>
	<p>K&auml;ytet&auml;&auml;n k&auml;ytt&ouml;liittym&auml;n asetteluun <code>GridLayout</code>-asettelijaa. Rivej&auml; k&auml;ytt&ouml;liittym&auml;ss&auml; on 3, sarakkeita 2. Lis&auml;t&auml;&auml;n tapahtumankuuntelija my&ouml;hemmin. K&auml;yttoliittym&auml;luokan metodi <code>luoKomponentit</code>n&auml;ytt&auml;&auml; nyt seuraavalta.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel(&quot;Nimi: &quot;);
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel(&quot;Hetu: &quot;);
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton(&quot;Lis&auml;&auml; henkil&ouml;!&quot;);
        // tapahtumankuuntelija

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(&quot;&quot;));
        container.add(lisaaNappi);
    }
</pre>
	<p>K&auml;ytt&ouml;liittym&auml; n&auml;ytt&auml;&auml; seuraavalta kun siihen on lis&auml;tty tietoa.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/kali-henkilon-lisays.png" /></p>
	<p>Tapahtumankuuntelijan tulee tiet&auml;&auml; tallennustoiminnallisuudesta -- eli HenkiloDAO-rajapinnasta sek&auml; kentist&auml;, joita se k&auml;ytt&auml;&auml;. Luodaan <code>ActionListener</code>-rajapinnan toteuttava luokka <code>HenkilonLisaysKuuntelija</code>, joka saa konstruktorissaan parametrina <code>HenkiloDAO</code>-rajapinnan toteuttavan olion sek&auml; kaksi <code>JTextField</code>-oliota -- kent&auml;t nimelle ja hetulle. Metodissa <code>actionPerformed</code>luodaan uusi <code>Henkilo</code>-olio ja tallennetaan se <code>HenkiloDAO</code>-olion tarjoamalla <code>talleta</code>-metodilla.</p>
	<pre class="sh_java">

public class HenkilonLisaysKuuntelija implements ActionListener {

    private HenkiloDAO henkiloDao;
    private JTextField nimiKentta;
    private JTextField hetuKentta;

    public HenkilonLisaysKuuntelija(HenkiloDAO henkiloDao, JTextField nimiKentta, JTextField hetuKentta) {
        this.henkiloDao = henkiloDao;
        this.nimiKentta = nimiKentta;
        this.hetuKentta = hetuKentta;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Henkilo henkilo = new Henkilo(nimiKentta.getText(), hetuKentta.getText());
        this.henkiloDao.talleta(henkilo);
    }
}
</pre>
	<p>Jotta saamme <code>HenkiloDAO</code>-viitteen <code>HenkilonLisaysKuuntelija</code>-oliolle, tulee sen olla k&auml;ytt&ouml;liittym&auml;n tiedossa. Lis&auml;t&auml;&auml;n k&auml;ytt&ouml;liittym&auml;lle oliomuuttuja <code>private HenkiloDAO henkiloDao</code>, joka asetetaan konstruktorissa. Luokan <code>Kayttoliittyma</code>konstruktoria muokataan siten, ett&auml; sille annetaan <code>HenkiloDAO</code>-rajapinnan toteuttama luokka.</p>
	<pre class="sh_java">

public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private HenkiloDAO henkiloDao;

    public Kayttoliittyma(HenkiloDAO henkiloDao) {
        this.henkiloDao = henkiloDao;
    }
    // ...


</pre>
	<p>Voimme nyt luoda tapahtumankuuntelijan <code>HenkilonLisaysKuuntelija</code>, jolle annetaan sek&auml; <code>HenkiloDAO</code>-viite, ett&auml; kent&auml;t.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel(&quot;Nimi: &quot;);
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel(&quot;Hetu: &quot;);
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton(&quot;Lis&auml;&auml; henkil&ouml;!&quot;);
        HenkilonLisaysKuuntelija kuuntelija = new HenkilonLisaysKuuntelija(henkiloDao, nimiKentta, hetuKentta);
        lisaaNappi.addActionListener(kuuntelija);

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(&quot;&quot;));
        container.add(lisaaNappi);
    }
</pre>
	<p>Muutetaan viel&auml; p&auml;&auml;ohjelmaluokan <code>Main</code>sis&auml;lt&ouml;&auml; siten, ett&auml; k&auml;ytt&ouml;liittym&auml;lle annetaan <code>HenkiloDAO</code>-rajapinnan toteuttava luokka. Voimme k&auml;ytt&auml;&auml; suoraan kappaleessa <a href="#56">56. Tallennustoiminnallisuuden eriytt&auml;minen</a> m&auml;&auml;ritelty&auml; luokkaa <code>MuistiHenkiloDAO</code>sill&auml; se toteuttaa rajapinnan <code>HenkiloDAO</code>.</p>
	<pre class="sh_java">

public class Main {
    public static void main(String[] args) {
        HenkiloDAO henkiloDao = new MuistiHenkiloDAO();
        SwingUtilities.invokeLater(new Kayttoliittyma(henkiloDao));
    }
}
</pre>
	<p>Nyt k&auml;ytt&ouml;liittym&auml;ss&auml; lis&auml;tyt henkil&ouml;t tallennetaan <code>MuistiHenkiloDAO</code>-luokan m&auml;&auml;rittelem&auml;ll&auml; tavalla ja sovellus toimii. Huomaa ett&auml; emme joutuneet toteuttamaan tallennuslogiikkaa erikseen, koska se oli toteutettu jo kertaalleen. K&auml;yt&auml;nn&ouml;ss&auml; aloitimme tekstik&auml;ytt&ouml;liittym&auml;st&auml; graafiseen k&auml;ytt&ouml;liittym&auml;&auml;n siirtymisen.</p>
	<div class="tehtavat">
		<h3>
			Axe Click Effect</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; toteutetaan laskuri klikkausten laskemiseen. Teht&auml;v&auml;ss&auml; sovelluslogiikka -- eli laskeminen -- ja k&auml;ytt&ouml;liittym&auml;logiikka on erotettu toisistaan. Lopullisen sovelluksen tulee n&auml;ytt&auml;&auml; kutakuinkin seuraavalta.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/159-clickeffect.png" /></p>
		<h4>
			OmaLaskuri</h4>
		<p>Toteuta pakkaukseen <code>clicker.sovelluslogiikka</code>rajapinnan <code>Laskuri</code>toteuttava luokka <code>OmaLaskuri</code>. Luokan <code>OmaLaskuri</code>metodin <code>annaArvo</code>palauttama luku on aluksi 0. Kun metodia <code>kasvata</code>kutsutaan, kasvaa arvo aina yhdell&auml;.</p>
		<p>Voit halutessasi testata luokan toimintaa seuraavan ohjelman avulla.</p>
		<pre class="sh_java">

        Laskuri laskuri = new OmaLaskuri();
        System.out.println(&quot;Arvo: &quot; + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println(&quot;Arvo: &quot; + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println(&quot;Arvo: &quot; + laskuri.annaArvo());
</pre>
		<pre>

Arvo: 0
Arvo: 1
Arvo: 2
</pre>
		<h4>
			KlikkaustenKuuntelija</h4>
		<p>Toteuta pakkaukseen <code>clicker.kayttoliittyma</code>rajapinnan <code>ActionListener</code>toteuttava luokka <code>KlikkaustenKuuntelija</code>. Luokka <code>KlikkaustenKuuntelija</code>saa konstruktorin parametrina <code>Laskuri</code>-rajapinnan toteuttavan olion ja <code>JLabel</code>-olion.</p>
		<p>Toteuta <code>actionPerformed</code>-metodi siten, ett&auml; <code>Laskuri</code>-oliota kasvatetaan aluksi yhdell&auml;, jonka j&auml;lkeen laskurin arvo asetetaan <code>JLabel</code>-olion tekstiksi. <code>JLabel</code>-olion teksti&auml; voidaan muuttaa metodilla <code>setText</code>.</p>
		<h4>
			K&auml;ytt&ouml;liittym&auml;</h4>
		<p>Muokkaa luokkaa <code>Kayttoliittyma</code>siten, ett&auml; k&auml;ytt&ouml;liittym&auml; saa konstruktorin parametrina <code>Laskuri</code>-olion -- tarvitset uuden konstruktorin. Lis&auml;&auml; k&auml;ytt&ouml;liittym&auml;&auml;n tarvittavat k&auml;ytt&ouml;liittym&auml;komponentit. Rekister&ouml;i napille my&ouml;s edellisess&auml; osassa toteutettu tapahtumankuuntelija.</p>
		<p>K&auml;yt&auml; k&auml;ytt&ouml;liittym&auml;komponenttien asetteluun <code>BorderLayout</code>-luokan tarjoamia toiminnallisuuksia. Muuta my&ouml;s <code>Main</code>-luokkaa siten, ett&auml; k&auml;ytt&ouml;liittym&auml;lle annetaan <code>OmaLaskuri</code>-olio. Kun k&auml;ytt&ouml;liittym&auml;ss&auml; olevaa <code>"Click!"</code>nappia on painettu kahdesti, sovellus n&auml;ytt&auml;&auml; kutakuinkin seuraavalta.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/159-clickeffect-klikattu.png" /></p>
		<h3>
			J&auml;tk&auml;nshakin sovelluslogiikka</h3>
		<p><em>T&auml;m&auml; teht&auml;v&auml; on kolmen yksitt&auml;isen teht&auml;v&auml;pisteen arvoinen.</em> Teht&auml;v&auml;ss&auml; toteutetaan sovelluslogiikka j&auml;tk&auml;nshakille ja harjoitellaan ohjelmarakenteen osittaista omatoimista suunnittelua.</p>
		<p>Teht&auml;v&auml;pohjassa tulee mukana k&auml;ytt&ouml;liittym&auml; <a href="http://fi.wikipedia.org/wiki/Ristinolla">j&auml;tk&auml;nshakille</a>, jossa pelilaudan koko on aina 3x3 ruutua. K&auml;ytt&ouml;liittym&auml; huolehtii ainoastaan pelilaudalla tehtyihin tapahtumiin reagoimisesta, sek&auml; pelilaudan ja pelitilanteen tietojen p&auml;ivitt&auml;misest&auml;. Pelin logiikka on erotettu <code>JatkanshakinSovelluslogiikka</code>-rajapinnan avulla omaksi luokakseen.</p>
		<pre class="sh_java">

package jatkanshakki.sovelluslogiikka;

public interface JatkanshakinSovelluslogiikka {
    char getNykyinenVuoro();
    int getMerkkienMaara();

    void asetaMerkki(int sarake, int rivi);
    char getMerkki(int sarake, int rivi);

    boolean isPeliLoppu();
    char getVoittaja();
}
</pre>
		<p>Rajapinnan <code>JatkanshakinSovelluslogiikka</code>lis&auml;ksi teht&auml;v&auml;pohjassa on apuluokka, joka m&auml;&auml;rittelee pelilaudan ruutujen mahdolliset tilat <code>char</code>-tyyppisin&auml; kirjaimina. Ruutu voi olla joko tyhj&auml;, tai siin&auml; voi olla risti tai nolla. Apuluokassa <code>Jatkanshakki</code>on n&auml;ille m&auml;&auml;rittelyt:</p>
		<pre class="sh_java">

package jatkanshakki.sovelluslogiikka;

public class Jatkanshakki {
    public static final char RISTI = &#39;X&#39;;
    public static final char NOLLA = &#39;O&#39;;
    public static final char TYHJA = &#39; &#39;;
}
</pre>
		<p>Teht&auml;v&auml;n&auml;si on t&auml;ydent&auml;&auml; pakkauksessa <code>jatkanshakki.sovelluslogiikka</code>olevaa rajapinnan <code>JatkanshakinSovelluslogiikka</code>toteuttavaa luokkaa <code>OmaJatkanshakinSovelluslogiikka</code>. Luokka <code>OmaJatkanshakinSovelluslogiikka</code>mahdollistaa j&auml;tk&auml;nshakin pelaamisen.</p>
		<p>Rajapinta <code>JatkanshakinSovelluslogiikka</code>m&auml;&auml;rittelee seuraavat toiminnot, jotka luokan <code>OmaJatkanshakinSovelluslogiikka</code>tulee toteuttaa:</p>
		<ul>
			<li>
				<font size="-1">char getNykyinenVuoro() palauttaa pelaajan merkki&auml; vastaavan arvon: <code>RISTI</code>, <code>NOLLA</code>tai pelin p&auml;&auml;tytty&auml; <code>TYHJA</code></font></li>
			<li>
				<font size="-1">int getMerkkienMaara() palauttaa pelilaudalle t&auml;h&auml;n menness&auml; asetettujen merkkien m&auml;&auml;r&auml;n (v&auml;lill&auml; 0-9)</font></li>
			<li>
				<font size="-1">void asetaMerkki(int sarake, int rivi) asettaa pelaajan vuoron mukaisen merkin annettuun ruutuun sarakkeen (0-2) ja rivin (0-2) perusteella ja antaa vuoron toiselle pelaajalle. Metodi heitt&auml;&auml; poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella tai ruudussa on jo merkki, ja poikkeuksen <code>IllegalStateException</code>, jos peli on jo loppu.</font></li>
			<li>
				<font size="-1">char getMerkki(int sarake, int rivi) palauttaa sarakkeen ja rivin m&auml;&auml;rittelem&auml;n ruudun tilan, joka voi olla <code>TYHJA</code>, <code>RISTI</code>tai <code>NOLLA</code>. Metodi heitt&auml;&auml; poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella.</font></li>
			<li>
				<font size="-1">boolean isPeliLoppu() palauttaa arvon <code>true</code>, jos toinen pelaajista voitti pelin tai peli p&auml;&auml;ttyi tasapeliin, muutoin metodi palauttaa <code>false</code></font></li>
			<li>
				<font size="-1">char getVoittaja() palauttaa arvon <code>TYHJA</code>, jos peli on kesken tai peli p&auml;&auml;ttyi tasapeliin, muutoin metodi palauttaa voittajan merkin: <code>RISTI</code>tai <code>NOLLA</code></font></li>
		</ul>
		<p>Ensimm&auml;inen pelivuoro on aina merkill&auml; <code>RISTI</code>. Pelin voittaa se pelaaja, joka saa ensimm&auml;isen&auml; kolme merkki&auml; vaakasuoraan, pystysuoraan tai vinottain. Tasapeli todetaan vasta, kun pelilauta on t&auml;ynn&auml; merkkej&auml; eli tyhji&auml; ruutuja ei en&auml;&auml; ole.</p>
		<p><b>Vinkki:</b> Pelilaudan tilanteen voi esitt&auml;&auml; esimerkiksi yhdeks&auml;n alkion <code>char</code>-taulukolla, jonne talletetaan peliruutujen tilat. Sarakkeen ja rivin perusteella voidaan laskea taulukon indeksi: <code>rivi * 3 + sarake</code>.</p>
	</div>
	<h3>
		Tiedostojen valitseminen k&auml;ytt&ouml;liittym&auml;st&auml;</h3>
	<p>Silloin t&auml;ll&ouml;in eteen tulee tilanne, jossa k&auml;ytt&auml;j&auml;n pit&auml;&auml; pysty&auml; valitsemaan tiedosto tiedostoj&auml;rjestelm&auml;st&auml;. Java tarjoaa tiedostojen valintaan valmiin k&auml;ytt&ouml;liittym&auml;komponentin <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFileChooser.html" target="_blank">JFileChooser</a></code>.</p>
	<p>JFileChooser poikkeaa t&auml;h&auml;n menness&auml; k&auml;ytt&auml;mist&auml;mme k&auml;ytt&ouml;liittym&auml;komponenteista siin&auml;, ett&auml; se avaa uuden ikkunan. Avautuvan ikkunan ulkon&auml;k&ouml; riippuu hieman k&auml;ytt&ouml;j&auml;rjestelm&auml;st&auml;, esimerkiksi hieman vanhemmassa <a href="http://fedoraproject.org/" target="_blank">Fedora</a>-k&auml;ytt&ouml;j&auml;rjestelm&auml;ss&auml; ikkuna on seuraavann&auml;k&ouml;inen.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/jfilechooser-kuva.png" /></p>
	<p>JFileChooser-olio voidaan luoda miss&auml; tahansa. Olion metodille <code>showOpenDialog</code>annetaan parametrina k&auml;ytt&ouml;liittym&auml;komponentti, johon se liittyy -- esimerkiksi <code>JFrame</code>-luokan ilmentym&auml;. Metodi <code>showOpenDialog</code>avaa tiedostonvalintaikkunan, ja palauttaa <code>int</code>-tyyppisen statuskoodin riippuen k&auml;ytt&auml;j&auml;n valinnasta. Luokassa <code>JFileChooser</code>on m&auml;&auml;ritelty <code>int</code>-tyyppiset luokkamuuttujat, jotka kuvaavat statuskoodeja. Esimerkiksi onnistuneella valinnalla on arvo <code>JFileChooser.APPROVE_OPTION</code>.</p>
	<p>Valittuun tiedostoon p&auml;&auml;see <code>JFileChooser</code>-oliosta k&auml;siksi metodilla <code>getSelectedFile</code>.</p>
	<pre class="sh_java">

    JFileChooser chooser = new JFileChooser();

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println(&quot;Valitsit tiedoston: &quot; + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println(&quot;Et valinnut tiedostoa!&quot;);
    }
</pre>
	<p>Yll&auml; oleva esimerkki avaa valintaikkunan, ja tulostaa valitun tiedoston nimen jos valinta onnistuu. Jos valinta ep&auml;onnistuu, ohjelma tulostaa <code>"Et valinnut tiedostoa!"</code>.</p>
	<h4>
		Tiedostojen filtter&ouml;inti</h4>
	<p>Tiedostojen filtter&ouml;innill&auml; tarkoitetaan vain tietynlaisten tiedostojen n&auml;ytt&auml;mist&auml; tiedostoikkunassa. JFileChooser-oliolle voi asettaa filtterin metodilla <code>setFileFilter</code>. Metodi <code>setFileFilter</code>saa parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileFilter.html" target="_blank">FileFilter</a></code>-ilmentym&auml;n -- esimerkiksi luokasta <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileNameExtensionFilter.html" target="_blank">FileNameExtensionFilter</a></code>tehdyn olion.</p>
	<p>Luokka <code>FileNameExtensionFilter</code>mahdollistaa tiedostojen filtter&ouml;innin niiden p&auml;&auml;tteiden perusteella. Esimerkiksi pelk&auml;t <code>txt</code>-p&auml;&auml;tteiset tekstitiedostot saa n&auml;kyviin seuraavasti.</p>
	<pre class="sh_java">

    JFileChooser chooser = new JFileChooser();
    chooser.setFileFilter(new FileNameExtensionFilter(&quot;Tekstitiedostot&quot;, &quot;txt&quot;));

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println(&quot;Valitsit tiedoston: &quot; + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println(&quot;Et valinnut tiedostoa!&quot;);
    }
</pre>
	<div class="tehtavat">
		<h3>
			Tiedostonn&auml;ytin</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; toteutetaan ohjelma, joka lukee k&auml;ytt&auml;j&auml;n valitseman tiedoston ja n&auml;ytt&auml;&auml; sen sis&auml;ll&ouml;n k&auml;ytt&ouml;liittym&auml;ss&auml;.</p>
		<p>Ohjelmassa on eroteltu k&auml;ytt&ouml;liittym&auml;&auml;n ja sovelluslogiikka. Teht&auml;v&auml;pohjassa on valmiina sovelluslogiikan rajapinta <code>TiedostonLukija</code>sek&auml; k&auml;ytt&ouml;liittym&auml;luokan runko <code>Kayttoliittyma</code>.</p>
		<h4>
			K&auml;ytt&ouml;liittym&auml;n rakentaminen</h4>
		<p>T&auml;ydenn&auml; k&auml;ytt&ouml;liittym&auml;luokan metodi <code>luoKomponentit</code>. Ohjelma tarvitsee toimiakseen kolme k&auml;ytt&ouml;liittym&auml;komponenttia:</p>
		<ul>
			<li>
				JButton-nappi, jossa on teksti &quot;Valitse tiedosto...&quot;</li>
			<li>
				JTextArea-tekstieditorin avulla n&auml;ytet&auml;&auml;n tiedoston sis&auml;lt&ouml; -- komponentin editointimahdollisuus tulee kytke&auml; pois p&auml;&auml;lt&auml; metodilla <code>setEditable</code>. <code>JTextArea</code>eroaa <code>JTextField</code>-komponentista siten, ett&auml; <code>JTextArea</code>-komponentissa voi olla teksti&auml; useammalla rivill&auml;.</li>
			<li>
				JLabel-tietokentt&auml;, joka sis&auml;lt&auml;&auml; n&auml;ytett&auml;v&auml;n tiedoston nimen (ilman polkua!)</li>
		</ul>
		<p>Koska t&auml;ss&auml; teht&auml;v&auml;ss&auml; on vain kolme aseteltavaa komponenttia, riitt&auml;v&auml;t asetteluun <code>BorderLayout</code>-asettelijan vaihtoehdot: <code>BorderLayout.NORTH</code>, <code>BorderLayout.CENTER</code>ja <code>BorderLayout.SOUTH</code>. K&auml;ytt&ouml;liittym&auml;komponentti <code>JTextArea</code>kannattaa sijoittaa keskelle, jotta se saa mahdollisimman paljon tilaa tekstin n&auml;ytt&auml;miselle.</p>
		<p>K&auml;ytt&ouml;liittym&auml;n pit&auml;isi n&auml;ytt&auml;&auml; suunnilleen seuraavalta. Alla olevassa esimerkiss&auml; <code>JLabel</code>-oliossa ei ole mit&auml;&auml;n teksti&auml;.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/161-tiedostonnaytin-alku.png" /></p>
		<h4>
			Tiedoston lukeminen</h4>
		<p>Luo pakkaukseen <code>tiedostonnaytin.sovelluslogiikka</code>luokka <code>OmaTiedostonLukija</code>, joka toteuttaa rajapinnan <code>TiedostonLukija</code>. Rajapinnassa on yksi metodi, <code>lueTiedosto</code>, joka lukee sille annetun tiedoston kokonaisuudessaan merkkijonoon ja palauttaa t&auml;m&auml;n merkkijonon.</p>
		<p>Rajapinnan koodi:</p>
		<pre class="sh_java">

package tiedostonnaytin.sovelluslogiikka;

import java.io.File;

public interface TiedostonLukija {
    String lueTiedosto(File tiedosto);
}
</pre>
		<p><b>Huom:</b> Palautettavassa merkkijonossa tulee s&auml;ilytt&auml;&auml; my&ouml;s rivinvaihdot <code>"\n"</code>. Esimerkiksi <code>Scanner</code>-lukijan metodi <code>nextLine()</code>poistaa palauttamistaan merkkijonoista rivinvaihdot, joten joudut joko lis&auml;&auml;m&auml;&auml;n ne takaisin tai lukemaan tiedostoa eri tavalla.</p>
		<h4>
			K&auml;ytt&ouml;liittym&auml;n kytkeminen sovelluslogiikkaan</h4>
		<p>Viimeisess&auml; teht&auml;v&auml;n osassa toteutetaan k&auml;ytt&ouml;liittym&auml;n <code>JButton</code>-napille tapahtumankuuntelija. Saat itse p&auml;&auml;tt&auml;&auml; luokalle sopivan nimen.</p>
		<p>Tapahtumankuuntelijan teht&auml;v&auml;n&auml; on n&auml;ytt&auml;&auml; <code>JFileChooser</code>-tiedostonvalintaikkuna kun <code>JButton</code>-nappia painetaan. Kun k&auml;ytt&auml;j&auml; valitsee tiedoston, tulee tapahtumankuuntelijan lukea tiedoston sis&auml;lt&ouml; ja n&auml;ytt&auml;&auml; se <code>JTextArea</code>-kent&auml;ss&auml;. T&auml;m&auml;n j&auml;lkeen tapahtumankuuntelijan tulee viel&auml; p&auml;ivitt&auml;&auml; <code>JLabel</code>-kentt&auml;&auml;n n&auml;ytetyn tiedoston nimi (ilman tiedostopolkua).</p>
		<p>JFileChooser-olion metodille <code>showOpenDialog</code>tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos k&auml;ytt&auml;j&auml; valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa m&auml;&auml;ritelty&auml; <code>TiedostonLukija</code>-oliota apuna k&auml;ytt&auml;en. Kannattaa luoda tapahtumankuuntelija siten, ett&auml; sille annetaan konstruktorissa kaikki tarvitut oliot.</p>
		<p>Huomaa, ett&auml; valintaikkunan voi my&ouml;s sulkea valitsematta tiedostoa!</p>
		<!--
<p><code>JButton</code>-nappiin tulee siis liittää <code>ActionListener</code>-rajapinnan toteuttava tapahtumankuuntelija, joten tehtävässä täytyy luoda tätä varten uusi luokka. <code>JFileChooser</code> palauttaa käyttäjän valitsemaa operaatiota vastaavan paluuarvon sekä viitteen valittuun tiedostoon, jos käyttäjä valitsi tiedoston (eikä peruuttanut valintaa).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos käyttäjä valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa määriteltyä <code>TiedostonLukija</code>-oliota apuna käyttäen. Kannattaa luoda tapahtumankuuntelija siten, että sille annetaan konstruktorissa tarvitut oliot.</p>

<p>Kun käyttäjä valitsee tiedoston, tulee <code>JTextArea</code>-kentän tekstisisällöksi asettaa tiedoston sisältö.</p>-->
		<p>Kun tiedosto on avattu, tulee k&auml;ytt&ouml;liittym&auml;n n&auml;ytt&auml;&auml; esimerkiksi seuraavalta.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/161-tiedostonnaytin-avattu.png" /></p>
	</div>
	<h3>
		Sis&auml;kk&auml;iset Container-oliot</h3>
	<p>T&ouml;rm&auml;&auml;mme silloin t&auml;ll&ouml;in tilanteeseen, jossa <code>JFrame</code>-luokan tarjoama <code>Container</code>-olio ei riit&auml; k&auml;ytt&ouml;liittym&auml;n asetteluun. Saatamme tarvita erilaisia k&auml;ytt&ouml;liittym&auml;n&auml;kymi&auml; tai mahdollisuutta k&auml;ytt&ouml;liittym&auml;komponenttien ryhmittelyyn niiden k&auml;ytt&ouml;tarkoituksen mukaan. Esimerkiksi alla olevan k&auml;ytt&ouml;liittym&auml;n rakentaminen ei olisi kovin helppoa vain <code>JFrame</code>-luokan tarjoamalla <code>Container</code>-oliolla.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/jpanel-container.png" /></p>
	<p>Voimme asettaa Container-tyyppisi&auml; olioita toistensa sis&auml;&auml;n. Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html" target="_blank">JPanel</a></code>(katso my&ouml;s <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html" target="_blank">How to Use Panels</a>) mahdollistaa sis&auml;kk&auml;iset <code>Container</code>-oliot. JPanel-luokan ilmentym&auml;&auml;n voi lis&auml;t&auml; k&auml;ytt&ouml;liittym&auml;komponentteja samalla tavalla kuin <code>JFrame</code>-luokasta saatuun <code>Container</code>-ilmentym&auml;&auml;n. T&auml;m&auml;n lis&auml;ksi <code>JPanel</code>-luokan ilmentym&auml;n voi lis&auml;t&auml; <code>Container</code>-olioon. T&auml;m&auml; mahdollistaa useamman <code>Container</code>-olion k&auml;ytt&auml;misen k&auml;ytt&ouml;liittym&auml;n suunnittelussa.</p>
	<p>Yll&auml; olevan k&auml;ytt&ouml;liittym&auml;n luominen on helpompaa <code>JPanel</code>-luokan avulla.. Luodaan k&auml;ytt&ouml;liittym&auml;, jossa on kolme nappia &quot;Suorita&quot;, &quot;Testaa&quot;, ja &quot;L&auml;het&auml;&quot;, sek&auml; tekstialue joka sis&auml;lt&auml;&auml; teksti&auml;. Napit ovat oma joukkonsa, joten tehd&auml;&auml;n niille erillinen <code>JPanel</code>-olio joka asetetaan <code>JFrame</code>-luokasta saadun <code>Container</code>-olion etel&auml;osaan. Tekstialue tulee keskelle.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(luoValikko(), BorderLayout.SOUTH);
    }

    private JPanel luoValikko() {
        JPanel panel = new JPanel(new GridLayout(1, 3));
        panel.add(new JButton(&quot;Suorita&quot;));
        panel.add(new JButton(&quot;Testaa&quot;));
        panel.add(new JButton(&quot;L&auml;het&auml;&quot;));
        return panel;
    }
</pre>
	<p>JPanel-luokalle annetaan konstruktorin parametrina k&auml;ytett&auml;v&auml; asettelutyyli. Jos asettelutyyli tarvitsee konstruktorissaan viitteen k&auml;ytettyyn <code>Container</code>-olioon, on <code>JPanel</code>-luokalla my&ouml;s metodi <code>setLayout</code>.</p>
	<p>Jos k&auml;ytt&ouml;liittym&auml;ss&auml;mme on selke&auml;t erilliset kokonaisuudet, voimme my&ouml;s peri&auml; <code>JPanel</code>luokan. Esimerkiksi yll&auml;olevan valikon voisi toteuttaa my&ouml;s seuraavasti.</p>
	<pre class="sh_java">

import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class ValikkoPanel extends JPanel {

    public ValikkoPanel() {
        super(new GridLayout(1, 3));
        luoKomponentit();
    }

    private void luoKomponentit() {
        add(new JButton(&quot;Suorita&quot;));
        add(new JButton(&quot;Testaa&quot;));
        add(new JButton(&quot;L&auml;het&auml;&quot;));
    }
}
</pre>
	<p>Nyt k&auml;ytt&ouml;liittym&auml;luokassa voidaan luoda <code>ValikkoPanel</code>-luokan ilmentym&auml;.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(new ValikkoPanel(), BorderLayout.SOUTH);
    }
</pre>
	<p>Huomaa ett&auml; tapahtumank&auml;sittely&auml; tarvittaessa luokalle <code>ValikkoPanel</code>tulee antaa parametrina kaikki tarvittavat oliot.</p>
	<div class="tehtavat">
		<h3>
			Tilastoiva kysely</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; tehd&auml;&auml;n tilastoja ker&auml;&auml;v&auml; versio teht&auml;v&auml;st&auml; 157. Teht&auml;v&auml;n&auml;si on toteuttaa k&auml;ytt&ouml;liittym&auml;luokan <code>Kysely</code>komponenttien luominen ja vastausten lis&auml;&auml;minen <code>Tilasto</code>-olioon. K&auml;ytt&ouml;liittym&auml;luokka <code>Kysely</code>sis&auml;lt&auml;&auml; kokoelman <code>Kysymys</code>-olioita, jotka sen tulee n&auml;ytt&auml;&auml; k&auml;ytt&auml;j&auml;lle. K&auml;ytt&auml;j&auml; voi vastata kysymyksiin, ja l&auml;hett&auml;&auml; lopuksi vastaukset nappia painamalla. Kun vastaukset l&auml;hetet&auml;&auml;n, ne tulee tilastoida <code>Tilasto</code>-olioon.</p>
		<p>Kysymykset ja tilasto annetaan k&auml;ytt&ouml;liittym&auml;luokalle konstruktorin parametreina.</p>
		<pre class="sh_java">

    List&lt;Kysymys&gt; kysymykset = new ArrayList&lt;Kysymys&gt;();

    Kysymys kysymys = new Kysymys(&quot;Kumpi vai kampi?&quot;);
    kysymys.lisaaVaihtoehto(&quot;Kumpi&quot;);
    kysymys.lisaaVaihtoehto(&quot;Kampi&quot;);
    kysymykset.add(kysymys);

    kysymys = new Kysymys(&quot;?&quot;);
    kysymys.lisaaVaihtoehto(&quot;A&quot;);
    kysymys.lisaaVaihtoehto(&quot;B&quot;);
    kysymys.lisaaVaihtoehto(&quot;C&quot;);
    kysymys.lisaaVaihtoehto(&quot;D&quot;);
    kysymykset.add(kysymys);

    kysymys = new Kysymys(&quot;Onko MOOC kiva?&quot;);
    kysymys.lisaaVaihtoehto(&quot;On!&quot;);
    kysymykset.add(kysymys);


    SwingUtilities.invokeLater(new Kysely(kysymykset, new Tilasto()));
</pre>
		<p>K&auml;ytt&ouml;liittym&auml;n tulee olla seuraavanlainen yll&auml; annetuilla kysymyksill&auml;.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/162-tallentava-kysely.png" /></p>
		<h4>
			K&auml;ytt&ouml;liittym&auml;n ulkomuoto</h4>
		<p>Muokkaa k&auml;ytt&ouml;liittym&auml;luokan <code>Kysely</code>toiminnallisuutta siten, ett&auml; sen ulkon&auml;k&ouml; on kuten yll&auml;olevassa kuvassa. Huomaa ett&auml; jokaisen kysymyksen vastausvaihtoehdot tulee olla omassa <code>ButtonGroup</code>-ryhm&auml;ss&auml;, eli jokaiseen kysymykseen saa antaa vain yhden vastauksen.</p>
		<p>Kannattanee my&ouml;s mahdollisesti k&auml;ytt&auml;&auml; useampaa kuin yht&auml; <code>Container</code>-oliota. Luokista <code>JPanel</code>ja <code>BoxLayout</code>lienee t&auml;ss&auml; hy&ouml;ty&auml;.</p>
		<p>Huom! Kysymykset ja vaihtoehdot tulee piirt&auml;&auml; k&auml;ytt&ouml;liittym&auml;&auml;n siin&auml; j&auml;rjestyksess&auml; kun ne annetaan. Vaihtoehdot tulee <code>JRadioButton</code>-nappuloilla, joista vain yksi (per kysymys) voi olla valittuna.</p>
		<h4>
			Vastauksen tilastointi</h4>
		<p>Luo k&auml;ytt&ouml;liittym&auml;n lopussa olevalle napille &quot;Valmis&quot; tapahtumankuuntelija, joka rekister&ouml;i kaikki valitut vastaukset kutsumalla <code>tilasto</code>-olion <code>tilastoiVastaus</code>-metodia.</p>
	</div>
	<h2>
		Piirt&auml;minen</h2>
	<p>Luokkaa <code>JPanel</code>k&auml;ytet&auml;&auml;n <code>Container</code>-toiminnallisuuden lis&auml;ksi usein piirtoalustana siten, ett&auml; k&auml;ytt&auml;j&auml; perii luokan <code>JPanel</code>ja korvaa metodin <code>protected void paintComponent(Graphics graphics)</code>. K&auml;ytt&ouml;liittym&auml; kutsuu metodia <code>paintComponent</code>aina kun k&auml;ytt&ouml;liittym&auml;komponentin sis&auml;lt&ouml; halutaan piirt&auml;&auml; ruudulle. Metodi <code>paintComponent</code>saa k&auml;ytt&ouml;liittym&auml;lt&auml; parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>toteuttavan olion. Luodaan luokan <code>JPanel</code>periv&auml; luokka <code>Piirtoalusta</code>, joka korvaa <code>paintComponent</code>-metodin.</p>
	<pre class="sh_java">

public class Piirtoalusta extends JPanel {

    public Piirtoalusta() {
        super.setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
    }
}
</pre>
	<p>Yll&auml; oleva piirtoalusta ei sis&auml;ll&auml; konkreettista piirt&auml;mistoiminnallisuutta. Asetamme konstruktorissa piirtoalustan taustan valkoiseksi kutsumalla yl&auml;luokan metodia <code>setBackground</code>. Metodin <code>setBackGround</code>saa parametrina <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html" target="_blank">Color</a></code>-luokan ilmentym&auml;n. Luokka <code>Color</code>sis&auml;lt&auml;&auml; yleisimm&auml;t v&auml;rit luokkamuuttujina -- esimerkiksi v&auml;ri valkoinen l&ouml;ytyy luokkamuuttujasta <code>Color.WHITE</code>.</p>
	<p>Korvattu <code>paintComponent</code>metodi kutsuu yl&auml;luokan <code>paintComponent</code>-metodia eik&auml; tee muuta. Lis&auml;t&auml;&auml;n piirtoalusta seuraavaksi k&auml;ytt&ouml;liittym&auml;luokan <code>luoKomponentit</code>-metodiin. K&auml;yt&auml;mme kappaleen <a href="#59">59. K&auml;ytt&ouml;liittym&auml;t</a> alussa m&auml;&auml;ritelty&auml; k&auml;ytt&ouml;liittym&auml;pohjaa.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        container.add(new Piirtoalusta());
    }
</pre>
	<p>K&auml;ynnist&auml;ess&auml;mme k&auml;ytt&ouml;liittym&auml;n n&auml;emme tyhj&auml;n ruudun, jonka taustav&auml;ri on valkoinen. Alla olevan k&auml;ytt&ouml;liittym&auml;n toivotuksi kooksi on asetettu <code>setPreferredSize</code>-metodilla 300, 300, ja sen otsikko on <code>"Piirtoalusta"</code>.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/piirtoalusta.png" /></p>
	<p>Piirtoalustalle piirt&auml;minen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>-olion tarjoamien metodien avulla. Muokataan <code>Piirtoalusta</code>-luokan metodia <code>paintComponent</code>siten, ett&auml; siin&auml; piirret&auml;&auml;n kaksi suorakulmiota <code>Graphics</code>-olion tarjoaman metodin <code>fillRect</code>avulla.</p>
	<pre class="sh_java">

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.fillRect(50, 80, 100, 50);
        graphics.fillRect(200, 20, 50, 200);
    }
</pre>
	<p>Metodi <code>fillRect</code>saa parametrina suorakulmion <code>x</code>, ja <code>y</code>-koordinaatit, sek&auml; suorakulmion leveyden ja korkeuden t&auml;ss&auml; j&auml;rjestyksess&auml;. Yll&auml; siis piirret&auml;&auml;n ensin koordinaatista <code>(50, 80)</code>alkava 100 pikseli&auml; leve&auml; ja 50 pikseli&auml; korkea suorakulmio. T&auml;m&auml;n j&auml;lkeen piirret&auml;&auml;n koordinaatista <code>(200, 20)</code>alkava 50 pikseli&auml; leve&auml; ja 100 pikseli&auml; korkea suorakulmio.</p>
	<p>Kuten piirtotuloksesta huomaat, koordinaatisto ei toimi aivan kuten olemme tottuneet.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/piirtoalusta-suorakulmiot.png" /></p>
	<p>Javan <code>Graphics</code>-olio (ja useiden muiden ohjelmointikielten k&auml;ytt&ouml;liittym&auml;kirjastot) olettaa ett&auml; y-akselin arvo kasvaa alasp&auml;in menness&auml;. Koordinaatiston origo, eli piste <code>(0, 0)</code>on piirrett&auml;v&auml;n alueen vasemmassa yl&auml;kulmassa: Graphics-olio tiet&auml;&auml; aina k&auml;ytt&ouml;liittym&auml;komponentin, johon piirret&auml;&auml;n, ja osaa sen perusteella p&auml;&auml;tell&auml; piirtotapahtuman sijainnin. K&auml;ytt&ouml;liittym&auml;n origon sijainti selkeytyy seuraavalla ohjelmalla. Piirret&auml;&auml;n ensin pisteest&auml; (0, 0) l&auml;htev&auml; 10 pikseli&auml; leve&auml; ja 200 pikseli&auml; korkea vihre&auml; suorakulmio. T&auml;m&auml;n j&auml;lkeen piirret&auml;&auml;n pisteest&auml; (0, 0) l&auml;htev&auml; 200 pikseli&auml; leve&auml; ja 10 pikseli&auml; korkea musta. Seuraavana piirrett&auml;v&auml;n kuvion v&auml;ri m&auml;&auml;ritell&auml;&auml;n <code>Graphics</code>-oliolle metodilla <code>setColor</code>.</p>
	<pre class="sh_java">

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.setColor(Color.GREEN);
        graphics.fillRect(0, 0, 10, 200);
        graphics.setColor(Color.BLACK);
        graphics.fillRect(0, 0, 200, 10);
    }
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/piirtoalusta-koordinaatisto.png" /></p>
	<p>T&auml;m&auml; koordinaatiston k&auml;&auml;nteisyys johtuu siit&auml;, miten k&auml;ytt&ouml;liittymien kokoa muokataan. K&auml;ytt&ouml;liittym&auml;n kokoa muutettaessa sit&auml; pienennet&auml;&auml;n tai suurennetaan &quot;oikeasta alakulmasta vet&auml;en&quot;, jolloin ruudulla n&auml;kyv&auml; piirros siirtyy kokoa muuttaessa. Kun koordinaatisto alkaa vasemmasta yl&auml;kulmasta, on piirroksen sijainti aina sama, mutta n&auml;kyv&auml; osa muuttuu.</p>
	<div class="tehtavat">
		<h3>
			Piirtoalusta ja Piirt&auml;minen</h3>
		<p>Teht&auml;v&auml;pohjassa on valmiina k&auml;ytt&ouml;liittym&auml;, johon on kytketty <code>JPanel</code>-luokan periv&auml; luokka <code>Piirtoalusta</code>. Muuta luokan <code>Piirtoalusta</code>metodin <code>paintComponent</code>toteutusta siten, ett&auml; se piirt&auml;&auml; seuraavanlaisen kuvion. Saat k&auml;ytt&auml;&auml; teht&auml;v&auml;ss&auml; vain <code>graphics</code>-olion <code>fillRect</code>-metodia.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/163-piirtaminen.png" /></p>
		<p>Huom! &Auml;l&auml; k&auml;yt&auml; enemp&auml;&auml; kuin viitt&auml; <code>fillRect</code>-kutsua. Kuvion ei tarvitse olla t&auml;sm&auml;lleen samanlainen kuin yll&auml;oleva -- testit kertovat kun piirt&auml;m&auml;si kuva on tarpeeksi l&auml;hell&auml; haluttua kuvaa.</p>
	</div>
	<p>Laajennetaan edellist&auml; esimerkki&auml; siten, ett&auml; piirr&auml;mme k&auml;ytt&ouml;liittym&auml;ss&auml; erillinen hahmo-olio. Luodaan hahmon edustamiseen luokka <code>Hahmo</code>. Hahmolla on koordinaatteina ilmaistu sijainti, ja se piirret&auml;&auml;n ympyr&auml;n&auml; jonka halkaisija on 10 pikseli&auml;. Hahmon sijaintia voi muuttaa kutsumalla sen <code>siirry</code>-metodia.</p>
	<pre class="sh_java">

import java.awt.Graphics;

public class Hahmo {

    private int x;
    private int y;

    public Hahmo(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void siirry(int xmuutos, int ymuutos) {
        this.x += xmuutos;
        this.y += ymuutos;
    }

    public void piirra(Graphics graphics) {
        graphics.fillOval(x, y, 10, 10);
    }
}
</pre>
	<p>Muutetaan piirtoalustaa siten, ett&auml; sille annetaan <code>Hahmo</code>-luokan ilmentym&auml; konstruktorin parametrina. Luokan <code>Piirtoalusta</code>metodi <code>paintComponent</code>ei itse piirr&auml; hahmoa, vaan delegoi piirtovastuun <code>Hahmo</code>-luokan ilmentym&auml;lle.</p>
	<pre class="sh_java">

import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class Piirtoalusta extends JPanel {

    private Hahmo hahmo;

    public Piirtoalusta(Hahmo hahmo) {
        super.setBackground(Color.WHITE);
        this.hahmo = hahmo;
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        hahmo.piirra(graphics);
    }
}
</pre>
	<p>Annetaan hahmo my&ouml;s k&auml;ytt&ouml;liittym&auml;lle parametrina. Hahmo on siis k&auml;ytt&ouml;liittym&auml;st&auml; erillinen olio, joka vain halutaan piirt&auml;&auml; k&auml;ytt&ouml;liittym&auml;ss&auml;. Oleelliset muutokset k&auml;ytt&ouml;liittym&auml;luokassa ovat siis konstruktorin muuttaminen siten, ett&auml; se saa parametrina <code>Hahmo</code>-olion. T&auml;m&auml;n lis&auml;ksi metodissa <code>luoKomponentit</code>annetaan <code>Hahmo</code>-luokan ilmentym&auml; parametrina luotavalle <code>Piirtoalusta</code>-oliolle.</p>
	<pre class="sh_java">

public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private Hahmo hahmo;

    public Kayttoliittyma(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

// ...

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);
    }
// ...
</pre>
	<p>K&auml;ytt&ouml;liittym&auml;n voi nyt k&auml;ynnist&auml;&auml; antamalla sen konstruktorille <code>Hahmo</code>-olion parametrina.</p>
	<pre class="sh_java">

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Hahmo(30, 30));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/piirtoalusta-hahmon-piirtaminen.png" /></p>
	<p>Yll&auml; olevassa k&auml;ytt&ouml;liittym&auml;ss&auml; n&auml;kyy huikea, pallonmuotoinen hahmo.</p>
	<p>Lis&auml;t&auml;&auml;n seuraavaksi ohjelmaan hahmon siirt&auml;mistoiminnallisuus. Haluamme liikuttaa hahmoa n&auml;pp&auml;imist&ouml;ll&auml;. Kun k&auml;ytt&auml;j&auml; painaa nuolta vasemmalle, hahmon pit&auml;isi siirty&auml; vasemmalle. Oikealle osoittavaa nuolta painettaessa hahmon pit&auml;isi siirty&auml; oikealle. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee n&auml;pp&auml;imist&ouml;&auml;. Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code>m&auml;&auml;rittelee n&auml;pp&auml;imist&ouml;nkuuntelijalta vaaditut toiminnallisuudet.</p>
	<p>Rajapinta <code>KeyListener</code>vaatii metodien <code>keyPressed</code>, <code>keyReleased</code>, ja <code>keyTyped</code>toteuttamista. Olemme kiinnostuneita vain tapahtumasta, jossa n&auml;pp&auml;int&auml; painetaan, joten j&auml;t&auml;mme metodit <code>keyReleased</code>ja <code>keyTyped</code>tyhjiksi. Luodaan luokka <code>NappaimistonKuuntelija</code>, joka toteuttaa rajapinnan <code>KeyListener</code>. Luokka saa parametrina <code>Hahmo</code>-olion, jota tapahtumank&auml;sittelij&auml;n tulee liikuttaa.</p>
	<pre class="sh_java">

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>
	<p>Metodi <code>keyPressed</code>saa k&auml;ytt&ouml;liittym&auml;lt&auml; parametrina <code>KeyEvent</code>-luokan ilmentym&auml;n. KeyEvent-oliolta saa tietoon painettuun nappiin liittyv&auml;n numeron sen <code>getKeyCode()</code>-metodilla. Eri n&auml;pp&auml;imille on luokkamuuttujat <code>KeyEvent</code>-luokassa -- esimerkiksi nuoli vasemmalle on <code>KeyEvent.VK_LEFT</code>.</p>
	<p>Haluamme kuunnella k&auml;ytt&ouml;liittym&auml;&auml;n kohdistuvia n&auml;pp&auml;imen painalluksia (emme esimerkiksi ole kirjoittamassa tekstikentt&auml;&auml;n), joten lis&auml;t&auml;&auml;n n&auml;pp&auml;imist&ouml;nkuuntelija <code>JFrame</code>-luokan ilmentym&auml;lle. Muokataan k&auml;ytt&ouml;liittym&auml;&auml;mme siten, ett&auml; n&auml;pp&auml;imist&ouml;nkuuntelija lis&auml;t&auml;&auml;n JFrame-oliolle.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo));
    }
</pre>
	<p>Nyt sovelluksemme kuuntelee n&auml;pp&auml;imist&ouml;lt&auml; tulleita painalluksia, ja ohjaa ne luokan <code>NappaimistonKuuntelija</code>ilmentym&auml;lle.</p>
	<p>Kokeillessamme k&auml;ytt&ouml;liittym&auml;&auml; se ei kuitenkaan toimi: hahmo ei siirry ruudulla. Mist&auml; t&auml;ss&auml; oikein on kyse? Voimme tarkastaa ett&auml; n&auml;pp&auml;imist&ouml;n painallukset ohjautuvat <code>NappaimistonKuuntelija</code>-oliolle lis&auml;&auml;m&auml;ll&auml; <code>keyPressed</code>-metodin alkuun testitulostuksen.</p>
	<pre class="sh_java">

    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println(&quot;Nappia &quot; + e.getKeyCode() +  &quot; painettu.&quot;);

        // ...
</pre>
	<p>K&auml;ynnist&auml;ess&auml;mme ohjelman ja painaessamme n&auml;pp&auml;imi&auml; n&auml;emme konsolissa tulostuksen.</p>
	<pre>

Nappia 39 painettu.
Nappia 37 painettu.
Nappia 40 painettu.
Nappia 38 painettu.
</pre>
	<p>Huomaamme ett&auml; n&auml;pp&auml;imist&ouml;n kuuntelija toimii, mutta piirtoalusta ei p&auml;ivity.</p>
	<h3>
		Piirtoalustan uudelleenpiirt&auml;minen</h3>
	<p>K&auml;ytt&ouml;liittym&auml;komponentit sis&auml;lt&auml;v&auml;t yleens&auml; toiminnallisuuden komponentin ulkoasun uudelleenpiirt&auml;miseen tarvittaessa. Esimerkiksi nappia painettaessa <code>JButton</code>-luokan ilmentym&auml; osaa piirt&auml;&auml; napin &quot;painettuna&quot;, jonka j&auml;lkeen nappi piirret&auml;&auml;n taas normaalina. Toteuttamassamme piirtoalustassa ei ole valmista p&auml;ivitystoiminnallisuutta, vaan meid&auml;n tulee pyyt&auml;&auml; sit&auml; piirt&auml;m&auml;&auml;n itsens&auml; uudelleen tarvittaessa.</p>
	<p>Jokaisella <code>Component</code>-luokan aliluokalla on metodi <code>public void repaint()</code>, jonka kutsuminen pakottaa komponentin uudelleenpiirt&auml;misen. Haluamme ett&auml; <code>Piirtoalusta</code>-olio piirret&auml;&auml;n uudestaan aina kun hahmoa siirret&auml;&auml;n. Hahmon siirt&auml;minen tapahtuu luokassa <code>NappaimistonKuuntelija</code>, joten on loogista ett&auml; uudelleenpiirtokutsu tapahtuu my&ouml;s n&auml;pp&auml;imist&ouml;nkuuntelijassa.</p>
	<p>Uudelleenpiirtokutsua varten n&auml;pp&auml;imist&ouml;nkuuntelija tarvitsee viitteen piirtoalustaan. Muutetaan luokkaa <code>NappaimistonKuuntelija</code>siten, ett&auml; se saa parametrinaan <code>Hahmo</code>-olion lis&auml;ksi uudelleenpiirrett&auml;v&auml;n <code>Component</code>-olion. Kutsutaan <code>Component</code>-olion <code>repaint</code>-metodia jokaisen <code>keyPressed</code>tapahtuman lopussa.</p>
	<pre class="sh_java">

import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Component component;
    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo, Component component) {
        this.hahmo = hahmo;
        this.component = component;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }

        component.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>
	<p>Muutetaan my&ouml;s <code>Kayttoliittyma</code>-luokan <code>luoKomponentit</code>-metodia siten, ett&auml; <code>Piirtoalusta</code>-luokan ilmentym&auml; annetaan parametrina n&auml;pp&auml;imist&ouml;nkuuntelijalle.</p>
	<pre class="sh_java">

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo, piirtoalusta));
    }
</pre>
	<p>Nyt hahmon liikuttaminen my&ouml;s n&auml;kyy k&auml;ytt&ouml;liittym&auml;ss&auml;. Aina kun k&auml;ytt&auml;j&auml; painaa n&auml;pp&auml;imist&ouml;&auml;, k&auml;ytt&ouml;liittym&auml;&auml;n liitetty n&auml;pp&auml;imist&ouml;nkuuntelija k&auml;sittelee kutsun. Jokaisen kutsun lopuksi kutsutaan piirtoalustan <code>repaint</code>-metodia, joka aiheuttaa piirtoalustan uudelleenpiirt&auml;misen.</p>
	<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/piirtoalusta-hahmo-liikkuu.png" /></p>
	<div class="tehtavat">
		<h3>
			Liikkuva kuvio</h3>
		<p>Teemme ohjelman, jossa k&auml;ytt&auml;j&auml; voi liikutella n&auml;pp&auml;imist&ouml;n avulla ruudulle piirrettyj&auml; kuvioita. Ohjelmassa tulee mukana k&auml;ytt&ouml;liittym&auml;runko, jota p&auml;&auml;set muokkaamaan ohjelman edetess&auml;.</p>
		<p>Aluksi tehd&auml;&auml;n muutama luokka jolla kuvioita hallitaan. P&auml;&auml;semme my&ouml;hemmin piirt&auml;m&auml;&auml;n kuvioita ruudulle. Tee kaikki ohjelman luokat pakkaukseen <code>liikkuvakuvio</code>.</p>
		<h4 class="req">
			Abstrakti luokka Kuvio</h4>
		<p>Tee abstrakti luokka <code>Kuvio</code>. Kuviolla on attribuutit <code>x</code>ja <code>y</code>, jotka kertovat kuvion sijainnin ruudulla sek&auml; metodi <code>public void siirra(int dx, int dy)</code>, jonka avulla kuvion sijainti siirtyy parametrina olevien koordinaattisiirtymien verran. Esim. jos sijainti aluksi on (100,100), niin kutsun <code>siirra(10,-50)</code>j&auml;lkeen sijainti on (110, 50). Luokan konstruktorin <code>public Kuvio(int x, int y)</code>tulee asettaa kuviolle alkusijainti. Lis&auml;&auml; luokalle my&ouml;s metodit <code>public int getX()</code>ja <code>public int getY()</code>.</p>
		<p>Luokalla tulee olla my&ouml;s abstrakti metodi <code>public abstract void piirra(Graphics graphics)</code>, jolla kuvio piirret&auml;&auml;n piirtoalustalle. Kuvion piirt&auml;mismetodi toteutetaan luokan <code>Kuvio</code>periviss&auml; metodeissa.</p>
		<h4 class="req">
			Ympyra</h4>
		<p>Tee luokka <code>Ympyra</code>joka perii Kuvion. Ympyr&auml;ll&auml; on <code>halkaisija</code>jonka arvo asetetaan konstruktorissa. Konstruktorissa asetetaan my&ouml;s alkuper&auml;inen sijainti. Ympyra m&auml;&auml;rittelee metodin <code>piirra</code>asiaan kuuluvalla tavalla -- k&auml;yt&auml; parametrina saadun <code>Graphics</code>-olion <code>fillOval</code>-metodia.</p>
		<h4 class="req">
			Piirtoalusta</h4>
		<p>Luo luokka <code>Piirtoalusta</code>joka perii luokan <code>JPanel</code>, mallia voit ottaa esimerkiksi edellisen teht&auml;v&auml;n mukana tulleesta piirtoalustasta. Piirtoalusta saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Korvaa luokan <code>JPanel</code>metodi <code>protected void paintComponent(Graphics g)</code>siten, ett&auml; siin&auml; kutsutaan ensin yl&auml;luokan <code>paintComponent</code>-metodia ja sitten piirtoalustalle asetetun kuvion <code>piirra</code>-metodia.</p>
		<p>Muokkaa luokkaa <code>Kayttoliittyma</code>siten, ett&auml; se saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Lis&auml;&auml; k&auml;ytt&ouml;liittym&auml;&auml;n Piirtoalusta <code>luoKomponentit(Container container)</code>-metodissa -- anna piirtoalustalle konstruktorin parametrina k&auml;ytt&ouml;liittym&auml;lle annettu kuvio.</p>
		<p>Testaa lopuksi ett&auml; seuraavalla esimerkkikoodilla ruudulle piirtyy ympyr&auml;.</p>
		<pre class="sh_java">

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Ympyra(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/liikkuvakuvio-ympyra.png" /></p>
		<h4 class="req">
			N&auml;pp&auml;imist&ouml;ohjaus</h4>
		<p>Laajennetaan piirtoalustaa siten, ett&auml; kuviota voi liikutella nuolin&auml;pp&auml;inten avulla. Luo rajapinnan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code>toteuttava luokka <code>NappaimistonKuuntelija</code>. Luokan <code>NappaimistonKuuntelija</code>konstruktorin parametrit ovat luokan <code>Component</code>ilmentym&auml; ja luokan <code>Kuvio</code>ilmentym&auml;.</p>
		<p>Luokan Component ilmentym&auml; annetaan n&auml;pp&auml;imist&ouml;nkuuntelijalle, jotta voimme p&auml;ivitt&auml;&auml; halutun komponentin jokaisen n&auml;pp&auml;imenpainalluksen j&auml;lkeen uudestaan. Komponentin p&auml;ivitt&auml;minen tapahtuu kutsumalla <code>Component</code>luokasta perityv&auml;&auml; metodia <code>repaint</code>. Luokka Piirtoalusta on tyyppi&auml; <code>Component</code>koska <code>Component</code>on luokan <code>JPanel</code>periv&auml;n luokan yl&auml;luokka.</p>
		<p>Toteuta rajapinnan <code>KeyListener</code>m&auml;&auml;rittelem&auml; metodi <code>keyPressed(KeyEvent e)</code>siten, ett&auml; k&auml;ytt&auml;j&auml;n painaessa nuolta vasemmalle kuvio siirtyy yhden pyk&auml;l&auml;n vasemmalle. Oikealle painettaessa yksi oikealle. Yl&ouml;s painettaessa yksi yl&ouml;s, ja alas painettaessa yksi alas. Huomaa ett&auml; y-akseli kasvaa ikkunan yl&auml;osasta alasp&auml;in. N&auml;pp&auml;inkoodit nuolin&auml;pp&auml;imille ovat <code>KeyEvent.VK_LEFT</code>, <code>KeyEvent.VK_RIGHT</code>, <code>KeyEvent.VK_UP</code>, ja <code>KeyEvent.VK_DOWN</code>. J&auml;t&auml; muut rajapinnan <code>KeyListener</code>vaatimat metodit tyhjiksi.</p>
		<p>Kutsu aina Component-luokan <code>repaint</code>-metodia n&auml;pp&auml;imist&ouml;nkuuntelutapahtuman lopussa.</p>
		<p>Lis&auml;&auml; n&auml;pp&auml;imist&ouml;nkuuntelija Kayttoliittyma-luokan <code>lisaaKuuntelijat</code>-metodissa. N&auml;pp&auml;imist&ouml;nkuuntelija tulee liitt&auml;&auml; <code>JFrame</code>-olioon.</p>
		<h4 class="req">
			Nelio ja Laatikko</h4>
		<p>Peri luokasta <code>Kuvio</code>luokat <code>Nelio</code>ja <code>Laatikko</code>. Neli&ouml;ll&auml; on konstruktori <code>public Nelio(int x, int y, int sivunPituus)</code>, laatikon konstruktori on muotoa <code>public Laatikko(int x, int y, int leveys, int korkeus)</code>. K&auml;yt&auml; piirt&auml;misess&auml; graphics-olion <code>fillRect</code>-metodia.</p>
		<p>Varmista, ett&auml; neli&ouml;t ja laatikot piirtyv&auml;t ja liikkuvat oikein Piirtoalustalla.</p>
		<pre class="sh_java">

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Nelio(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/liikkuvakuvio-nelio.png" /></p>
		<pre class="sh_java">

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Laatikko(50, 50, 100, 300));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/liikkuvakuvio-laatikko.png" /></p>
		<h4 class="req">
			Koostekuvio</h4>
		<p>Peri luokasta <code>Kuvio</code>luokka <code>Koostekuvio</code>. Koostekuvio sis&auml;lt&auml;&auml; joukon muita kuvioita jotka se tallettaa ArrayList:iin. Koostekuviolla on metodi <code>public void liita(Kuvio k)</code>jonka avulla koostekuvioon voi liitt&auml;&auml; kuvio-olion. Koostekuviolla ei ole omaa sijaintia. Koostekuvio piirt&auml;&auml; itsens&auml; pyyt&auml;m&auml;ll&auml; osiaan piirt&auml;m&auml;&auml;n itsens&auml;, koostekuvion siirtyminen tapahtuu samoin.</p>
		<p>Testaa ett&auml; koostekuviosi piirtyy ja siirtyy oikein, esim. seuraavan koostekuvion avulla:</p>
		<pre class="sh_java">

        Koostekuvio rekka = new Koostekuvio();

        rekka.liita(new Laatikko(220, 110, 75, 100));
        rekka.liita(new Laatikko(80, 120, 200, 100));
        rekka.liita(new Ympyra(100, 200, 50));
        rekka.liita(new Ympyra(220, 200, 50));

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(rekka);
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/liikkuvakuvio-rekka.png" /></p>
		<p>Huomaa miten <b>olioiden vastuut</b> jakautuvat teht&auml;v&auml;ss&auml;. Jokainen Kuvio on vastuussa itsens&auml; piirt&auml;misest&auml; ja siirt&auml;misest&auml;. Yksinkertaiset kuviot siirtyv&auml;t kaikki samalla tavalla. Jokaisen yksinkertaisen kuvion on itse hoidettava piirtymisest&auml;&auml;n. Koostekuvio siirt&auml;&auml; itsens&auml; pyyt&auml;m&auml;ll&auml; osiaan siirtym&auml;&auml;n, samoin hoituu koostekuvion piirtyminen. Piirtoalusta tuntee Kuvio-olion joka siis voi olla mik&auml; tahansa yksinkertainen kuvio tai koostekuvio, kaikki piirret&auml;&auml;n ja siirret&auml;&auml;n samalla tavalla. Piirtoalusta siis toimii samalla tavalla kuvan oikeasta tyypist&auml; huolimatta, piirtoalustan ei tarvitse tiet&auml;&auml; kuvion yksityiskohdista mit&auml;&auml;n. Kun piirtoalusta kutsuu kuvion metodia <code>piirra</code>tai <code>siirra</code><b>polymorfismin</b> ansiosta kutsutuksi tulee kuvion todellista tyyppi&auml; vastaava metodi.</p>
		<p>Huomionarvoista teht&auml;v&auml;ss&auml; on se, ett&auml; Koostekuvio voi sis&auml;lt&auml;&auml; mit&auml; tahansa Kuvio-olioita, siis my&ouml;s koostekuvioita! Luokkarakenne mahdollistaakin mielivaltaisen monimutkaisen kuvion muodostamisen ja kuvion siirtely ja piirt&auml;minen tapahtuu aina t&auml;sm&auml;lleen samalla tavalla.</p>
		<p>Luokkarakennetta on my&ouml;s helppo laajentaa, esim. perim&auml;ll&auml; Kuvio-luokasta uusia kuviotyyppej&auml;: kolmio, piste, viiva, ym... Koostekuvio toimii ilman muutoksia my&ouml;s uusien kuviotyyppien kanssa, samoin piirtoalusta.</p>
	</div>
</div>
<p><!--
<hr />Viikko 5 loppuu<hr />
//--></p>
<div class="week" data-week-number="12">
	<h2>
		Muutamia hy&ouml;dyllisi&auml; tekniikoita</h2>
	<p>Kurssin l&auml;hestyess&auml; loppua katsomme viel&auml; muutamaa hy&ouml;dyllist&auml; Javan ominaisuutta.</p>
	<h3>
		S&auml;&auml;nn&ouml;lliset lausekkeet</h3>
	<p>S&auml;&auml;nn&ouml;llinen lauseke m&auml;&auml;rittelee tiiviiss&auml; muodossa joukon merkkijonoja. S&auml;&auml;nn&ouml;llisi&auml; lausekkeita k&auml;ytet&auml;&auml;n muunmuassa merkkijonojen oikeellisuuden tarkistamiseen. Tarkastellaan teht&auml;v&auml;&auml;, jossa t&auml;ytyy tarkistaa, onko k&auml;ytt&auml;j&auml;n antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa merkkijonolla &quot;01&quot;, jota seuraa 7 numeroa v&auml;lilt&auml; 0&ndash;9.</p>
	<p>Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi k&auml;ym&auml;ll&auml; opiskelijanumeroa esitt&auml;v&auml;n merkkijonon l&auml;pi merkki merkilt&auml; <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa ett&auml; ensimm&auml;inen merkki on &quot;0&quot;, ja k&auml;ytt&auml;&auml; <code>Integer.parseInt</code>metodikutsua merkkijonon muuntamiseen numeroksi. T&auml;m&auml;n j&auml;lkeen voisi tarkistaa ett&auml; <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.</p>
	<p>Oikeellisuuden tarkistus s&auml;&auml;nn&ouml;llisten lausekkeiden avulla vaatii ensin sopivan s&auml;&auml;nn&ouml;llisen lausekkeen m&auml;&auml;rittelyn. T&auml;m&auml;n j&auml;lkeen voimme k&auml;ytt&auml;&auml; <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako merkkijono parametrina annettua s&auml;&auml;nn&ouml;llist&auml; lauseketta. Opiskelijanumeron tapauksessa sopiva s&auml;&auml;nn&ouml;llinen lauseke on <code>"01[0-9]{7}"</code>, ja k&auml;ytt&auml;j&auml;n sy&ouml;tt&auml;m&auml;n opiskelijanumeron tarkistaminen k&auml;y seuraavasti:</p>
	<pre class="sh_java">

System.out.print(&quot;Anna opiskelijanumero: &quot;);
String numero = lukija.nextLine();

if (numero.matches(&quot;01[0-9]{7}&quot;)) {
    System.out.println(&quot;Muoto on oikea.&quot;);
} else {
    System.out.println(&quot;Muoto ei ole oikea.&quot;);
}
</pre>
	<p>K&auml;yd&auml;&auml;n seuraavaksi l&auml;pi eniten k&auml;ytettyj&auml; s&auml;&auml;nn&ouml;llisten lausekkeiden merkint&ouml;j&auml;.</p>
	<h4>
		Pystyviiva eli vaihtoehtoisuus</h4>
	<p>Pystyviiva tarkoittaa, ett&auml; s&auml;&auml;nn&ouml;llisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code>m&auml;&auml;rittelee merkkijonot <code>00</code>, <code>111</code>ja <code>0000</code>. Metodi <code>matches</code>palauttaa arvon <code>true</code>jos merkkijono vastaa jotain m&auml;&auml;ritellyist&auml; vaihtoehdoista.</p>
	<pre class="sh_java">

    String merkkijono = &quot;00&quot;;
    
    if(merkkijono.matches(&quot;00|111|0000&quot;)) {
        System.out.println(&quot;Merkkijonosta l&ouml;ytyi joku kolmesta vaihtoehdosta&quot;);
    } else {
        System.out.println(&quot;Merkkijonosta ei l&ouml;ytynyt yht&auml;k&auml;&auml;n vaihtoehdoista&quot;);
    }
</pre>
	<pre>

Merkkijonosta l&ouml;ytyi joku kolmesta vaihtoehdosta
</pre>
	<p>S&auml;&auml;nn&ouml;llinen lauseke <code>00|111|0000</code>vaatii ett&auml; merkkijono on t&auml;sm&auml;lleen m&auml;&auml;ritellyn muotoinen: se ei m&auml;&auml;rittele <em>&quot;contains&quot;</em>-toiminnallisuutta.</p>
	<pre class="sh_java">

    String merkkijono = &quot;1111&quot;;
    
    if(merkkijono.matches(&quot;00|111|0000&quot;)) {
        System.out.println(&quot;Merkkijonosta l&ouml;ytyi joku kolmesta vaihtoehdosta&quot;);
    } else {
        System.out.println(&quot;Merkkijonosta ei l&ouml;ytynyt yht&auml;k&auml;&auml;n vaihtoehdoista&quot;);
    }
</pre>
	<pre>

Merkkijonosta ei l&ouml;ytynyt yht&auml;k&auml;&auml;n vaihtoehdoista
</pre>
	<h4>
		Sulut, eli merkkijonon osaan rajattu vaikutusalue</h4>
	<p>Sulkujen avulla voi m&auml;&auml;ritt&auml;&auml;, mihin s&auml;&auml;nn&ouml;llisen lausekkeen osaan sulkujen sis&auml;ll&auml; olevat merkinn&auml;t vaikuttavat. Jos haluamme sallia merkkijonot <code>00000</code>ja <code>00001</code>, voimme m&auml;&auml;ritell&auml; ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan merkkijonoa. Lauseke <code>0000(0|1)</code>m&auml;&auml;rittelee merkkijonot <code>00000</code>ja <code>00001</code>.</p>
	<p>Vastaavasti s&auml;&auml;nn&ouml;llinen lauseke <code>auto(|n|a)</code>m&auml;&auml;rittelee sanan auto yksik&ouml;n nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).</p>
	<pre class="sh_java">

System.out.print(&quot;Kirjoita joku sanan auto yksik&ouml;n taivutusmuoto: &quot;);
String sana = lukija.nextLine();

if (sana.matches(&quot;auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)&quot;)) {
    System.out.println(&quot;Oikein meni!&quot;);
} else {
    System.out.println(&quot;Taivutusmuoto ei ole oikea.&quot;);
}
</pre>
	<h4>
		Toistomerkinn&auml;t</h4>
	<p>Usein halutaan, ett&auml; merkkijonossa toistuu jokin tietty alimerkkijono. S&auml;&auml;nn&ouml;llisiss&auml; lausekkeissa on k&auml;yt&ouml;ss&auml; seuraavat toistomerkinn&auml;t:</p>
	<ul>
		<li>
			Merkint&auml; <code>*</code>toisto 0... kertaa, esim<br />
			<pre class="sh_java">

    String merkkijono = &quot;trolololololo&quot;;
    
    if(merkkijono.matches(&quot;trolo(lo)*&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto on oikea.
</pre>
		</li>
		<li>
			Merkint&auml; <code>+</code>toisto 1... kertaa, esim<br />
			<pre class="sh_java">

    String merkkijono = &quot;trolololololo&quot;;
    
    if(merkkijono.matches(&quot;tro(lo)+&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto on oikea.
</pre>
			<pre class="sh_java">

    String merkkijono = &quot;n&auml;n&auml;n&auml;n&auml;n&auml;n&auml;n&auml;n&auml; B&auml;tm&auml;&auml;n!&quot;;
    
    if(merkkijono.matches(&quot;(n&auml;)+ B&auml;tm&auml;&auml;n!&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto on oikea.
</pre>
		</li>
		<li>
			Merkint&auml; <code>?</code>toisto 0 tai 1 kertaa, esim<br />
			<pre class="sh_java">

    String merkkijono = &quot;You have to accidentally the whole meme&quot;;
    
    if(merkkijono.matches(&quot;You have to accidentally (delete )?the whole meme&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto on oikea.
</pre>
		</li>
		<li>
			Merkint&auml; <code>{a}</code>toisto <code>a</code>kertaa, esim<br />
			<pre class="sh_java">

    String merkkijono = &quot;1010&quot;;
    
    if(merkkijono.matches(&quot;(10){2}&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto on oikea.
</pre>
		</li>
		<li>
			Merkint&auml; <code>{a,b}</code>toisto <code>a</code>... <code>b</code>kertaa, esim<br />
			<pre class="sh_java">

    String merkkijono = &quot;1&quot;;
    
    if(merkkijono.matches(&quot;1{2,4}&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto ei ole oikea.
</pre>
		</li>
		<li>
			Merkint&auml; <code>{a,}</code>toisto <code>a</code>... kertaa, esim<br />
			<pre class="sh_java">

    String merkkijono = &quot;11111&quot;;
    
    if(merkkijono.matches(&quot;1{2,}&quot;)) {
        System.out.println(&quot;Muoto on oikea.&quot;);
    } else {
        System.out.println(&quot;Muoto ei ole oikea.&quot;);
    }       
</pre>
			<pre>

Muoto on oikea.
</pre>
		</li>
	</ul>
	<p>Samassa s&auml;&auml;nn&ouml;llisess&auml; lausekkeessa voi k&auml;ytt&auml;&auml; my&ouml;s useampia toistomerkint&ouml;j&auml;. Esimerkiksi s&auml;&auml;nn&ouml;llinen lauseke <code>5{3}(1|0)*5{3}</code>m&auml;&auml;rittelee merkkijonot, jotka alkavat ja loppuvat kolmella vitosella. V&auml;liss&auml; saa tulla rajaton m&auml;&auml;r&auml; ykk&ouml;si&auml; ja nollia.</p>
	<h4>
		Hakasulut, eli merkkiryhm&auml;t</h4>
	<p>Merkkiryhm&auml;n avulla voi m&auml;&auml;ritell&auml; lyhyesti joukon merkkej&auml;. Merkit kirjoitetaan hakasulkujen sis&auml;&auml;n, ja merkkiv&auml;lin voi m&auml;&auml;ritt&auml;&auml; viivan avulla. Esimerkiksi merkint&auml; <code>[145]</code>tarkoittaa samaa kuin <code>(1|4|5)</code>ja merkint&auml; <code>[2-36-9]</code>tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkint&auml; <code>[a-c]*</code>m&auml;&auml;rittelee s&auml;&auml;nn&ouml;llisen lausekkeen, joka vaatii ett&auml; merkkijono sis&auml;lt&auml;&auml; vain merkkej&auml; <code>a</code>, <code>b</code>ja <code>c</code>.</p>
	<div class="tehtavat">
		<h3>
			S&auml;&auml;nn&ouml;lliset lausekkeet</h3>
		<p>Harjoitellaan hieman s&auml;&auml;nn&ouml;llisten lausekkeiden k&auml;ytt&ouml;&auml;. Teht&auml;v&auml;t tehd&auml;&auml;n oletuspakkauksessa olevaan luokkaan <code>Paaohjelma</code>.</p>
		<h4 class="req">
			Viikonp&auml;iv&auml;</h4>
		<p>Tee s&auml;&auml;nn&ouml;llisen lausekkeen avulla luokalle <code>Paaohjelma</code>metodi <code>public static boolean onViikonpaiva(String merkkijono)</code>, joka palauttaa <code>true</code>jos sen parametrina saama merkkijono viikonp&auml;iv&auml;n lyhenne (ma, ti, ke, to, pe, la tai su).</p>
		<p>Esimerkkitulostuksia metodia k&auml;ytt&auml;v&auml;st&auml; ohjelmasta:</p>
		<pre>

Anna merkkijono: ti
Muoto on oikea.
</pre>
		<pre>

Anna merkkijono: abc
Muoto ei ole oikea.
</pre>
		<h4 class="req">
			Vokaalitarkistus</h4>
		<p>Tee luokalle <code>Paaohjelma</code>metodi <code>public static boolean kaikkiVokaaleja(String merkkijono)</code>joka tarkistaa s&auml;&auml;nn&ouml;llisen lausekkeen avulla ovatko parametrina olevan merkkijonon kaikki merkit vokaaleja.</p>
		<p>Esimerkkitulostuksia metodia k&auml;ytt&auml;v&auml;st&auml; ohjelmasta:</p>
		<pre>

Anna merkkijono: aie
Muoto on oikea.
</pre>
		<pre>

Anna merkkijono: ane
Muoto ei ole oikea.
</pre>
		<h4 class="req">
			Kellonaika</h4>
		<p>Tee luokalle <code>Paaohjelma</code>metodi <code>public static boolean kellonaika(String merkkijono)</code>ohjelma, joka tarkistaa s&auml;&auml;nn&ouml;llisen lausekkeen avulla onko parametrina oleva merkkijono muotoa <code>tt:mm:ss</code>oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina).</p>
		<p>Esimerkkitulostuksia metodia k&auml;ytt&auml;v&auml;st&auml; ohjelmasta:</p>
		<pre>

Anna merkkijono: 17:23:05
Muoto on oikea.
</pre>
		<pre>

Anna merkkijono: abc
Muoto ei ole oikea.
</pre>
		<pre>

Anna merkkijono: 33:33:33
Muoto ei ole oikea.
</pre>
	</div>
	<h3>
		Enum eli lueteltu tyyppi</h3>
	<p>Toteutimme aiemmin pelikorttia mallintavan luokan <code>Kortti</code>suunilleen seuraavasti:</p>
	<pre class="sh_java">

public class Kortti {

    public static final int RUUTU = 0;
    public static final int PATA = 1;
    public static final int RISTI = 2;
    public static final int HERTTA = 3;

    private int arvo;
    private int maa;

    public Kortti(int arvo, int maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maanNimi() + &quot; &quot;+arvo;
    }

    private String maanNimi() {
        if (maa == 0) {
            return &quot;RUUTU&quot;;
        } else if (maa == 1) {
            return  &quot;PATA&quot;;
        } else if (maa == 2) {
            return &quot;RISTI&quot;;
        }
        return &quot;HERTTA&quot;;
    }

    public int getMaa() {
        return maa;
    }
}
</pre>
	<p>Kortin maa tallennetaan kortissa olevaan oliomuuttujaan kokonaislukuna. Maan ilmaisemiseen on m&auml;&auml;ritelty luettavuutta helpottavat vakiot. Kortteja ja maita ilmaisevia vakioita k&auml;ytet&auml;&auml;n seuraavasti:</p>
	<pre class="sh_java">

public static void main(String[] args) {
        Kortti kortti = new Kortti(10, Kortti.HERTTA);

        System.out.println(kortti);

        if (kortti.getMaa() == Kortti.PATA) {
            System.out.println(&quot;on pata&quot;);
        } else {
            System.out.println(&quot;ei ole pata&quot;);
        }

}
</pre>
	<p>Maan esitt&auml;minen numerona on hiukan ik&auml;v&auml;, sill&auml; esimerkiksi seuraavat &quot;j&auml;rjenvastaiset&quot; tavat k&auml;ytt&auml;&auml; korttia ovat mahdollisia:</p>
	<pre class="sh_java">

        Kortti jarjetonKortti = new Kortti(10, 55);

        System.out.println(jarjetonKortti);

        if (jarjetonKortti.getMaa() == 34) {
            System.out.println(&quot;kortin maa on 34&quot;);
        } else {
            System.out.println(&quot;kortin maa on jotain muuta kun 34&quot;);
        }

        int maaPotenssiinKaksi = jarjetonKortti.getMaa() * jarjetonKortti.getMaa();

        System.out.println(&quot;kortin maa potenssiin kaksi on &quot; + maaPotenssiinKaksi);
</pre>
	<p>Jos tied&auml;mme muuttujien mahdolliset arvot ennalta, voimme k&auml;ytt&auml;&auml; niiden esitt&auml;miseen <em>enum</em>-tyyppist&auml; muuttujaa eli &quot;lueteltua tyyppi&auml;&quot;. Luetellut tyypit ovat oma luokkatyyppins&auml; rajapinnan ja normaalin luokan lis&auml;ksi. Lueteltu tyyppi m&auml;&auml;ritell&auml;&auml;n avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka m&auml;&auml;rittelee nelj&auml; vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code>ja <code>HERTTA</code>.</p>
	<pre class="sh_java">

public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
}
</pre>
	<p>Yksinkertaisimmassa muodossaan <em>enum</em> luettelee pilkulla erotettuina m&auml;&auml;rittelem&auml;ns&auml; vakioarvot. Enumien vakiot on yleens&auml; tapana kirjoittaa kokonaan isoin kirjaimin.</p>
	<p>Enum luodaan (yleens&auml;) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>.</p>
	<p>Seuraavassa luokka <code>Kortti</code>jossa maa esitet&auml;&auml;n enumin avulla:</p>
	<pre class="sh_java">

public class Kortti {

    private int arvo;
    private Maa maa;

    public Kortti(int arvo, Maa maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maa + &quot; &quot;+arvo;
    }

    public Maa getMaa() {
        return maa;
    }

    public int getArvo() {
        return arvo;
    }
}
</pre>
	<p>Kortin uutta versiota k&auml;ytet&auml;&auml;n seuraavasti:</p>
	<pre class="sh_java">

public class Paaohjelma {

    public static void main(String[] args) {
        Kortti eka = new Kortti(10, Maa.HERTTA);

        System.out.println(eka);

        if (eka.getMaa() == Maa.PATA) {
            System.out.println(&quot;on pata&quot;);
        } else {
            System.out.println(&quot;ei ole pata&quot;);
        }

    }
}
</pre>
	<p>Tulostuu:</p>
	<pre>

HERTTA 10
ei ole pata
</pre>
	<p>Huomaamme, ett&auml; enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppi&auml; <code>Maa</code>ei ylemm&auml;n esimerkin &quot;j&auml;rjenvastaiset&quot; kummallisuudet, esim. &quot;maan korottaminen toiseen potenssiin&quot; onnistu. Oraclella on <code>enum</code>-tyyppiin liittyv&auml; sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.</p>
	<h3>
		Iteraattori</h3>
	<p>Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyss&auml; korttipeliss&auml; pelaajan k&auml;dess&auml; olevien korttien joukkoa:</p>
	<pre class="sh_java">

public class Kasi {
    private ArrayList&lt;Kortti&gt; kortit;

    public Kasi() {
        kortit = new ArrayList&lt;Kortti&gt;();
    }

    public void lisaa(Kortti kortti){
        kortit.add(kortti);
    }

    public void tulosta(){
        for (Kortti kortti : kortit) {
            System.out.println( kortti );
        }
    }
}
</pre>
	<p>Luokan metodi <code>tulosta</code>tulostaa jokaisen k&auml;dess&auml; olevan kortin tutuksi tullutta &quot;for each&quot;-lausetta k&auml;ytt&auml;m&auml;ll&auml;. ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat &quot;olios&auml;ili&ouml;t&quot; toteuttavat rajapinnan <em>Iterable</em>. Rajapinnan <em>Iterable</em> toteuttavat oliot on mahdollista k&auml;yd&auml; l&auml;pi eli &quot;iteroida&quot; esimerkiksi. for each -tyyppisell&auml; komennolla.</p>
	<p>Olios&auml;ili&ouml; voidaan k&auml;yd&auml; l&auml;pi my&ouml;s k&auml;ytt&auml;en ns. <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman l&auml;pik&auml;yntiin. Seuraavassa on iteraattoria k&auml;ytt&auml;v&auml; versio korttien tulostamisesta:</p>
	<pre class="sh_java">

public void tulosta() {
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        System.out.println( iteraattori.next() );
    }
}
</pre>
	<p>Iteraattori pyydet&auml;&auml;n kortteja sis&auml;lt&auml;v&auml;lt&auml; arraylistilt&auml; <code>kortit</code>. Iteraattori on ik&auml;&auml;nkuin &quot;sormi&quot;, joka osoittaa aina tietty&auml; listan sis&auml;ll&auml; olevaa olioa, ensin ensimm&auml;ist&auml; ja sitten seuraavaa jne... kunnes &quot;sormen&quot; avulla on k&auml;yty jokainen olio l&auml;pi.</p>
	<p>Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code>kysyt&auml;&auml;n onko l&auml;pik&auml;yt&auml;vi&auml; olioita viel&auml; j&auml;ljell&auml;. Jos on, voidaan iteraattorilta pyyt&auml;&auml; seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana l&auml;pik&auml;yntivuorossa olevan olion ja laittaa iteraattorin eli &quot;sormen&quot; osoittamaan seuraavana vuorossa olevaa l&auml;pik&auml;yt&auml;v&auml;&auml; olioa.</p>
	<p>Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen my&ouml;s muuttujaan, eli metodi <code>tulosta</code>voitaisiin muotoilla my&ouml;s seuraavasti:</p>
	<pre class="sh_java">

public void tulosta(){
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        Kortti seuraavanaVuorossa = iteraattori.next();
        System.out.println( seuraavanaVuorossa );
    }
}
</pre>
	<p>Teemme metodin jonka avulla k&auml;dest&auml; voi poistaa tietty&auml; arvoa pienemm&auml;t kortit:</p>
	<pre class="sh_java">

public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        for (Kortti kortti : kortit) {
            if ( kortti.getArvo() &lt; arvo ) {
                kortit.remove(kortti);
            }
        }
    }
}
</pre>
	<p>Huomaamme ett&auml; metodin suoritus aiheuttaa kummallisen virheen:</p>
	<pre>

Exception in thread &quot;main&quot; java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Kasi.poistaHuonommat(Kasi.java:26)
        at Paaohjelma.main(Paaohjelma.java:20)
Java Result: 1
</pre>
	<p>Virheen syyn&auml; on se, ett&auml; for-each:illa listaa l&auml;pik&auml;ydess&auml; ei ole sallittua poistaa listalta olioita: komento for-each menee t&auml;st&auml; &quot;sekaisin&quot;.</p>
	<p>Jos listalta halutaan poistaa osa olioista l&auml;pik&auml;ynnin aikana osa, tulee t&auml;m&auml; tehd&auml; iteraattoria k&auml;ytt&auml;en. Iteraattori-olion metodia <code>remove</code>kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisell&auml; metodin <code>next</code>kutsulla. Toimiva versio metodista seuraavassa:</p>
	<pre class="sh_java">

public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

        while (iteraattori.hasNext()) {
            if (iteraattori.next().getArvo() &lt; arvo) {
                // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
                iteraattori.remove();   
            }
        }
    }
}
</pre>
	<div class="tehtavat">
		<h3>
			Enum ja Iteraattori</h3>
		<p>Tehd&auml;&auml;n ohjelma pienen yrityksen henkil&ouml;st&ouml;n hallintaan.</p>
		<h4>
			Koulutus</h4>
		<p>Tee pakkaukseen <code>henkilosto</code>lueteltu tyyppi eli enum <code>Koulutus</code>jolla on tunnukset <code>FT, FM, LuK, FilYO</code></p>
		<h4>
			Henkilo</h4>
		<p>Tee pakkaukseen <code>henkilosto</code>luokka Luokka <code>Henkilo</code>. Henkil&ouml;lle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkil&ouml;ll&auml; on my&ouml;s koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code>sek&auml; allaolevan esimerkin mukaista j&auml;lke&auml; tekev&auml; <code>toString</code>-metodi.</p>
		<pre class="sh_java">

    Henkilo arto = new Henkilo(&quot;Arto&quot;, Koulutus.FT);
    System.out.println(arto);
</pre>
		<pre>

Arto, FT
</pre>
		<h4>
			Tyontekijat</h4>
		<p>Tee pakkaukseen <code>henkilosto</code>luokka Luokka <code>Tyontekijat</code>. Ty&ouml;ntekij&auml;t-olio sis&auml;lt&auml;&auml; listan Henkilo-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:</p>
		<ul>
			<li>
				<code>public void lisaa(Henkilo lisattava)</code>lis&auml;&auml; parametrina olevan henkil&ouml;n ty&ouml;ntekij&auml;ksi</li>
			<li>
				<code>public void lisaa(List&lt;Henkilo&gt; lisattavat)</code>lis&auml;&auml; parametrina olevan listan henkil&ouml;it&auml; ty&ouml;ntekij&ouml;iksi</li>
			<li>
				<code>public void tulosta()</code>tulostaa kaikki ty&ouml;ntekij&auml;t</li>
			<li>
				<code>public void tulosta(Koulutus koulutus)</code>tulostaa ty&ouml;ntekij&auml;t joiden koulutus on sama kuin parametrissa m&auml;&auml;ritelty koulutus</li>
		</ul>
		<p>HUOM: Luokan <code>Tyontekijat</code><code>tulosta</code>-metodit on toteutettava iteraattoria k&auml;ytt&auml;en!</p>
		<h4>
			Irtisanominen</h4>
		<p>Tee luokalle <code>Tyontekijat</code>metodi <code>public void irtisano(Koulutus koulutus)</code>joka poistaa Ty&ouml;ntekij&ouml;iden joukosta kaikki henkil&ouml;t joiden koulutus on sama kuin metodin parametrina annettu.</p>
		<p>HUOM: toteuta metodi iteraattoria k&auml;ytt&auml;en!</p>
		<p>Seuraavassa esimerkki luokan k&auml;yt&ouml;st&auml;:</p>
		<pre class="sh_java">

Public class Paaohjelma {

    public static void main(String[] args) {
        Tyontekijat yliopisto = new Tyontekijat();
        yliopisto.lisaa(new Henkilo(&quot;Matti&quot;, Koulutus.FT));
        yliopisto.lisaa(new Henkilo(&quot;Pekka&quot;, Koulutus.FilYO));
        yliopisto.lisaa(new Henkilo(&quot;Arto&quot;, Koulutus.FT));

        yliopisto.tulosta();

        yliopisto.irtisano(Koulutus.FilYO);

        System.out.println(&quot;==&quot;);

        yliopisto.tulosta();
}
</pre>
		<p>Tulostuu:</p>
		<pre>

Matti, FT
Pekka, FilYO
Arto, FT
==
Matti, FT
Arto, FT
</pre>
	</div>
	<h3>
		Toistolauseet ja continue</h3>
	<p>Toistolauseissa on komennon <code>break</code>lis&auml;ksi k&auml;yt&ouml;ss&auml; komento <code>continue</code>, joka mahdollistaa seuraavaan toistokierrokseen hypp&auml;&auml;misen.</p>
	<pre class="sh_java">

    List&lt;String&gt; nimet = Arrays.asList(&quot;Matti&quot;, &quot;Pekka&quot;, &quot;Arto&quot;);
    
    for(String nimi: nimet) {
        if (nimi.equals(&quot;Arto&quot;)) {
            continue;
        }

        System.out.println(nimi);
    }
</pre>
	<pre>

Matti
Pekka
</pre>
	<p>Komentoa <code>continue</code>k&auml;ytet&auml;&auml;n esimerkiksi silloin, kun tiedet&auml;&auml;n ett&auml; toistolauseessa iteroitavilla muuttujilla on arvoja, joita ei haluta k&auml;sitell&auml; lainkaan. Klassinen l&auml;hestymistapa olisi if-lauseen k&auml;ytt&ouml;, mutta komento <code>continue</code>mahdollistaa sisennyksi&auml; v&auml;ltt&auml;v&auml;n, ja samalla ehk&auml; luettavamman l&auml;hestymistavan k&auml;sitelt&auml;vien arvojen v&auml;ltt&auml;miseen. Alla on kaksi esimerkki&auml;, jossa k&auml;yd&auml;&auml;n listalla olevia lukuja l&auml;pi. Jos luku on alle 5, se on jaollinen sadalla, tai se on jaollinen nelj&auml;ll&auml;kymmenell&auml;, niin sit&auml; ei tulosteta, muulloin se tulostetaan.</p>
	<pre class="sh_java">

    List&lt;Integer&gt; luvut = Arrays.asList(1, 3, 11, 6, 120);
    
    for(int luku: luvut) {
        if (luku &gt; 4 &amp;&amp; luku % 100 != 0 &amp;&amp; luku % 40 != 0) {
            System.out.println(luku);
        }
    }

    for(int luku: luvut) {
        if (luku &lt; 5) {
            continue;
        }

        if (luku % 100 == 0) {
            continue;
        }

        if (luku % 40 == 0) {
            continue;
        }
        
        System.out.println(luku);
    }
</pre>
	<pre>

11
6
11
6
</pre>
	<h3>
		Lis&auml;&auml; enumeista</h3>
	<p>Luodaan seuraavaksi lueteltuja tyyppej&auml; jotka sis&auml;lt&auml;v&auml;t oliomuuttujia ja toteuttavat rajapinnan.</p>
	<h4>
		Luetellun tyypin konstruktorin parametrit</h4>
	<p>Luetellut tyypit voivat sis&auml;lt&auml;&auml; oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin m&auml;&auml;rittelev&auml;n luokan sis&auml;isess&auml; konstruktorissa. Enum-tyyppisill&auml; luokilla ei saa olla <code>public</code>-konstruktoria.</p>
	<pre class="sh_java">

public enum Vari {
    PUNAINEN(&quot;punainen&quot;), // konstruktorin parametrit m&auml;&auml;ritell&auml;&auml;n vakioarvoja lueteltaessa
    VIHREA(&quot;vihre&auml;&quot;),
    SININEN(&quot;sininen&quot;);

    private String nimi; // oliomuuttuja

    private Vari(String nimi) { // konstruktori
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }
}  
</pre>
	<p>Lueteltua tyyppi&auml; <code>Vari</code>voidaan k&auml;ytt&auml;&auml; esimerkiksi seuraavasti:</p>
	<pre class="sh_java">

    System.out.println(Vari.VIHREA.getNimi());
</pre>
	<pre>

vihre&auml;
</pre>
	<h4>
		Lueteltu tyyppi ja rajapinnat</h4>
	<p>Luetellut tyypit voivat toteuttaa rajapintoja samalla tavoin kuin muutkin luokat toteuttavat rajapintoja. Luodaan rajapinta <code>Nimetty</code></p>
	<pre class="sh_java">

public interface Nimetty {
    String getNimi();
}
</pre>
	<p>ja m&auml;&auml;ritell&auml;&auml;n luokka <code>Vari</code>toteuttamaan rajapinta <code>Nimetty</code>. Rajapinnan toteutus tapahtuu <code>implements</code>-avainsanalla.</p>
	<pre class="sh_java">

public enum Vari implements Nimetty {
    PUNAINEN(&quot;punainen&quot;),
    VIHREA(&quot;vihre&auml;&quot;),
    SININEN(&quot;sininen&quot;);

    private String nimi; 

    private Vari(String nimi) {
        this.nimi = nimi;
    }

    @Override
    public String getNimi() {
        return nimi;
    }
}
</pre>
	<p>Kun lueteltu tyyppi toteuttaa rajapinnan, on se my&ouml;s rajapinnan m&auml;&auml;rittelem&auml;&auml; tyyppi&auml;.</p>
	<pre class="sh_java">

    Vari vari = Vari.PUNAINEN;
    Nimetty nimetty = Vari.VIHREA;

    System.out.println(&quot;Vari: &quot; + vari.getNimi());
    System.out.println(&quot;Nimetty: &quot; + nimetty.getNimi());
</pre>
	<pre>

Vari: punainen
Nimetty: vihre&auml;
</pre>
	<div class="tehtavat">
		<h3>
			Elokuvien suosittelija</h3>
		<p><a href="http://en.wikipedia.org/wiki/Netflix" target="_blank">Netflix</a>-niminen yritys lupasi lokakuussa 2006 miljoona dollaria henkil&ouml;lle tai ryhm&auml;lle, joka kehitt&auml;isi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heid&auml;n oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank">http://www.netflixprize.com/</a>) -- emme valitettavasti voittaneet.</p>
		<p>Rakennetaan t&auml;ss&auml; teht&auml;v&auml;ss&auml; ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:</p>
		<pre class="sh_java">

    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva(&quot;Tuulen viem&auml;&auml;&quot;);
    Elokuva hiljaisetSillat = new Elokuva(&quot;Hiljaiset sillat&quot;);
    Elokuva eraserhead = new Elokuva(&quot;Eraserhead&quot;);

    Henkilo matti = new Henkilo(&quot;Matti&quot;);
    Henkilo pekka = new Henkilo(&quot;Pekka&quot;);
    Henkilo mikke = new Henkilo(&quot;Mikke&quot;);
    Henkilo thomas = new Henkilo(&quot;Thomas&quot;);

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + &quot; suositus: &quot; + 
            suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + &quot; suositus: &quot; + 
            suosittelija.suositteleElokuva(mikke));
</pre>
		<pre>

Thomas suositus: Hiljaiset sillat
Mikke suositus: Tuulen viem&auml;&auml;
</pre>
		<p>Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sek&auml; henkil&ouml;kohtaisten henkil&ouml;n antaminen arvioiden perusteella. L&auml;hdet&auml;&auml;n rakentamaan ohjelmaa.</p>
		<h4>
			Henkilo ja Elokuva</h4>
		<p>Luo pakkaus <code>suosittelija.domain</code>ja lis&auml;&auml; sinne luokat <code>Henkilo</code>ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String nimi)</code>, sek&auml; metodi <code>public String getNimi()</code>, joka palauttaa konstruktorissa saadun nimen.</p>
		<pre class="sh_java">

    Henkilo henkilo = new Henkilo(&quot;Pekka&quot;);
    Elokuva elokuva = new Elokuva(&quot;Eraserhead&quot;);

    System.out.println(henkilo.getNimi() + &quot; ja &quot; + elokuva.getNimi());
</pre>
		<pre>

Pekka ja Eraserhead
</pre>
		<p>Lis&auml;&auml; luokille my&ouml;s <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sek&auml; korvaa metodit <code>equals</code>ja <code>hashCode</code>.</p>
		<p>Korvaa <code>equals</code>siten ett&auml; samuusvertailu tapahtuu oliomuuttujan <code>nimi</code>perusteella. Katso mallia luvusta 45.1. Luvussa 45.2. on ohje metodin <code>hashCode</code>korvaamiselle. Ainakin HashCode kannattaa generoida automaattisesti luvun lopussa olevan ohjeen mukaan:</p>
		<p><em>NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -&gt; Insert Code, ja valita aukeavasta listasta equals() and hashCode(). T&auml;m&auml;n j&auml;lkeen NetBeans kysyy oliomuuttujat joita metodeissa k&auml;ytet&auml;&auml;n.</em></p>
		<h4>
			Arvio</h4>
		<p>Luo pakkaukseen <code>suosittelija.domain</code>lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code>on julkinen metodi <code>public int getArvosana()</code>, joka palauttaa arvioon liittyv&auml;n arvosanan. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:</p>
		<p>&nbsp;</p>
		<table style="padding-left:20px">
			<tbody>
				<tr>
					<th>
						Tunnus</th>
					<th>
						Arvosana</th>
				</tr>
				<tr>
					<td>
						HUONO</td>
					<td>
						-5</td>
				</tr>
				<tr>
					<td>
						VALTTAVA</td>
					<td>
						-3</td>
				</tr>
				<tr>
					<td>
						EI_NAHNYT</td>
					<td>
						0</td>
				</tr>
				<tr>
					<td>
						NEUTRAALI</td>
					<td>
						1</td>
				</tr>
				<tr>
					<td>
						OK</td>
					<td>
						3</td>
				</tr>
				<tr>
					<td>
						HYVA</td>
					<td>
						5</td>
				</tr>
			</tbody>
		</table>
		<p>&nbsp;</p>
		<p>Luokkaa voi k&auml;ytt&auml;&auml; seuraavasti:</p>
		<pre class="sh_java">

    Arvio annettu = Arvio.HYVA;
    System.out.println(&quot;Arvio &quot; + annettu + &quot;, arvosana &quot; + annettu.getArvosana());
    annettu = Arvio.NEUTRAALI;
    System.out.println(&quot;Arvio &quot; + annettu + &quot;, arvosana &quot; + annettu.getArvosana());
</pre>
		<pre>

Arvio HYVA, arvosana 5
Arvio NEUTRAALI, arvosana 1
</pre>
		<h4>
			ArvioRekisteri, osa 1</h4>
		<p>Aloitetaan arvioiden varastointiin liittyv&auml;n palvelun toteutus.</p>
		<p>Luo pakkaukseen <code>suosittelija</code>luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code>sek&auml; seuraavat metodit:</p>
		<ul>
			<li>
				<code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code>lis&auml;&auml; arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
			<li>
				<code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>palauttaa hajautustaulun, joka sis&auml;lt&auml;&auml; arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sis&auml;lt&auml;&auml; elokuvaan lisatyt arviot.</li>
			<li>
				<code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code>palauttaa elokuvalle lis&auml;tyt arviot listana.</li>
		</ul>
		<p>Testaa metodien toimintaa seuraavalla l&auml;hdekoodilla:</p>
		<pre class="sh_java">

    Elokuva hiljaisetSillat = new Elokuva(&quot;Hiljaiset sillat&quot;);
    Elokuva eraserhead = new Elokuva(&quot;Eraserhead&quot;);

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println(&quot;Kaikki arviot: &quot; + rekisteri.elokuvienArviot());
    System.out.println(&quot;Arviot Eraserheadille: &quot; + rekisteri.annaArviot(eraserhead));
</pre>
		<pre>

Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
Arviot Eraserheadille: [HUONO, HUONO, HYVA]
</pre>
		<h4>
			ArvioRekisteri, osa 2</h4>
		<p>Lis&auml;t&auml;&auml;n seuraavaksi mahdollisuus henkil&ouml;kohtaisten arvioiden lis&auml;&auml;iseen.</p>
		<p>Lis&auml;&auml; luokkaan <code>ArvioRekisteri</code>seuraavat metodit:</p>
		<ul>
			<li>
				<code>public void lisaaArvio(Henkilo henkilo, Elokuva elokuva, Arvio arvio)</code>lis&auml;&auml; parametrina annetulle elokuvalle tietyn henkil&ouml;n tekem&auml;n arvion. Sama henkil&ouml; voi arvioida tietyn elokuvan vain kertaalleen. Henkil&ouml;n tekem&auml; arvio tulee my&ouml;s lis&auml;t&auml; kaikkiin elokuviin liittyviin arvioihin.</li>
			<li>
				<code>public Map&lt;Elokuva, Arvio&gt; annaHenkilonArviot(Henkilo henkilo)</code>palauttaa hajautustaulun, joka sis&auml;lt&auml;&auml; henkil&ouml;n tekem&auml;t arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyv&auml;t arviot.</li>
			<li>
				<code>public Arvio haeArvio(Henkilo henkilo, Elokuva elokuva)</code>palauttaa parametrina annetun henkil&ouml;n tekem&auml;n arvion parametrina annetulle elokuvalle. Jos henkil&ouml; ei ole arvioinut kyseist&auml; elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
			<li>
				<code>public List&lt;Henkilo&gt; arvioijat()</code>palauttaa listan henkil&ouml;ist&auml; jotka ovat arvioineet elokuvia.</li>
		</ul>
		<p>Henkil&ouml;iden tekem&auml;t arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkil&ouml;. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.</p>
		<p>Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla l&auml;hdekoodip&auml;tk&auml;ll&auml;:</p>
		<pre class="sh_java">

    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva(&quot;Tuulen viem&auml;&auml;&quot;);
    Elokuva eraserhead = new Elokuva(&quot;Eraserhead&quot;);

    Henkilo matti = new Henkilo(&quot;Matti&quot;);
    Henkilo pekka = new Henkilo(&quot;Pekka&quot;);

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println(&quot;Arviot Eraserheadille: &quot; + arviot.annaArviot(eraserhead));
    System.out.println(&quot;Matin arviot: &quot; + arviot.annaHenkilonArviot(matti));
    System.out.println(&quot;Arvioijat: &quot; + arviot.arvioijat());
</pre>
		<pre>

Arviot Eraserheadille: [OK, OK]
Matin arviot: {Tuulen viem&auml;&auml;=HUONO, Eraserhead=OK}
Arvioijat: [Pekka, Matti]
</pre>
		<p>Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.</p>
		<h4>
			HenkiloComparator</h4>
		<p>Luo pakkaukseen <code>suosittelija.comparator</code>luokka <code>HenkiloComparator</code>. Luokan <code>HenkiloComparator</code>tulee toteuttaa rajapinta <code>Comparator&lt;Henkilo&gt;</code>, ja sill&auml; pit&auml;&auml; olla konstruktori <code>public HenkiloComparator(Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>HenkiloComparator</code>k&auml;ytet&auml;&auml;n my&ouml;hemmin henkil&ouml;iden j&auml;rjest&auml;miseen henkil&ouml;&ouml;n liittyv&auml;n luvun perusteella.</p>
		<p>HenkiloComparator-luokan tulee mahdollistaa henkil&ouml;iden j&auml;rjest&auml;minen henkil&ouml;&ouml;n liittyv&auml;n luvun perusteella.</p>
		<p>Testaa luokan toimintaa seuraavalla l&auml;hdekoodilla:</p>
		<pre class="sh_java">

    Henkilo matti = new Henkilo(&quot;Matti&quot;);
    Henkilo pekka = new Henkilo(&quot;Pekka&quot;);
    Henkilo mikke = new Henkilo(&quot;Mikke&quot;);
    Henkilo thomas = new Henkilo(&quot;Thomas&quot;);

    Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet = new HashMap&lt;Henkilo, Integer&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);
    
    List&lt;Henkilo&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println(&quot;Henkil&ouml;t ennen j&auml;rjest&auml;mist&auml;: &quot; + henkilot);

    Collections.sort(henkilot, new HenkiloComparator(henkiloidenSamuudet));
    System.out.println(&quot;Henkil&ouml;t j&auml;rjest&auml;misen j&auml;lkeen: &quot; + henkilot);
</pre>
		<pre>

Henkil&ouml;t ennen j&auml;rjest&auml;mist&auml;: [Matti, Pekka, Mikke, Thomas]
Henkil&ouml;t j&auml;rjest&auml;misen j&auml;lkeen: [Pekka, Thomas, Matti, Mikke]
</pre>
		<h4>
			ElokuvaComparator</h4>
		<p>Luo pakkaukseen <code>suosittelija.comparator</code>luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code>tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sill&auml; pit&auml;&auml; olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code>k&auml;ytet&auml;&auml;n my&ouml;hemmin elokuvien j&auml;rjest&auml;miseen niiden arvioiden perusteella.</p>
		<p>ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien j&auml;rjest&auml;minen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimm&auml;isen&auml;, matalimman keskiarvon saanut viimeisen&auml;.</p>
		<p>Testaa luokan toimintaa seuraavalla l&auml;hdekoodilla:</p>
		<pre class="sh_java">

    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva(&quot;Tuulen viem&auml;&auml;&quot;);
    Elokuva hiljaisetSillat = new Elokuva(&quot;Hiljaiset sillat&quot;);
    Elokuva eraserhead = new Elokuva(&quot;Eraserhead&quot;);

    Henkilo matti = new Henkilo(&quot;Matti&quot;);
    Henkilo pekka = new Henkilo(&quot;Pekka&quot;);
    Henkilo mikke = new Henkilo(&quot;Mikke&quot;);

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println(&quot;Elokuvat ennen j&auml;rjest&auml;mist&auml;: &quot; + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println(&quot;Elokuvat j&auml;rjest&auml;misen j&auml;lkeen: &quot; + elokuvat);
</pre>
		<pre>

Elokuvat ennen j&auml;rjest&auml;mist&auml;: [Tuulen viem&auml;&auml;, Hiljaiset sillat, Eraserhead]
Elokuvat j&auml;rjest&auml;misen j&auml;lkeen: [Hiljaiset sillat, Tuulen viem&auml;&auml;, Eraserhead]
</pre>
		<h4>
			Suosittelija, osa 1</h4>
		<p>Toteuta pakkaukseen <code>suosittelija</code>luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code>konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija k&auml;ytt&auml;&auml; arviorekisteriss&auml; olevia arvioita suositusten tekemiseen.</p>
		<p>Toteuta luokalle <code>ArvioRekisteri</code>metodi <code>public Elokuva suositteleElokuva(Henkilo henkilo)</code>, joka suosittelee henkil&ouml;lle elokuvia. Toteuta metodi ensin siten, ett&auml; se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvitt&auml;miseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code>metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sek&auml; listaa olemassaolevista elokuvista.</p>
		<p>Testaa ohjelman toimimista seuraavalla l&auml;hdekoodilla:</p>
		<pre class="sh_java">

    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva(&quot;Tuulen viem&auml;&auml;&quot;);
    Elokuva hiljaisetSillat = new Elokuva(&quot;Hiljaiset sillat&quot;);
    Elokuva eraserhead = new Elokuva(&quot;Eraserhead&quot;);

    Henkilo matti = new Henkilo(&quot;Matti&quot;);
    Henkilo pekka = new Henkilo(&quot;Pekka&quot;);
    Henkilo mikke = new Henkilo(&quot;Mikael&quot;);

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println(&quot;Mikaelille suositeltu elokuva oli: &quot; + suositeltu); 
</pre>
		<pre>

Mikaelille suositeltu elokuva oli: Hiljaiset sillat
</pre>
		<h4>
			Suosittelija, osa 2</h4>
		<p><em>Huom! Teht&auml;v&auml; on haastava. Kannattaa tehd&auml; ensin muut teht&auml;v&auml;t ja palata t&auml;h&auml;n my&ouml;hemmin. Voit palauttaa teht&auml;v&auml;sarjan TMC:hen vaikket saakaan t&auml;t&auml; teht&auml;v&auml;&auml; tehdyksi -- aivan kuten muidenkin teht&auml;vien kohdalla.</em></p>
		<p>Jos henkil&ouml;t ovat lis&auml;nneet omia suosituksia suosituspalveluun, tied&auml;mme jotain heid&auml;n elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, ett&auml; se luo henkil&ouml;kohtaisen suosituksen jos henkil&ouml; on jo arvioinut elokuvia. Edellisess&auml; osassa toteutettu toiminnallisuus tulee s&auml;ilytt&auml;&auml;: Jos henkil&ouml; ei ole arvioinut yht&auml;k&auml;&auml;n elokuvaa, h&auml;nelle suositellaan elokuva arvosanojen perusteella.</p>
		<p>Henkil&ouml;kohtaiset suositukset perustuvat henkil&ouml;n tekemien arvioiden samuuteen muiden henkil&ouml;iden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, miss&auml; yl&auml;rivill&auml; on elokuvat, ja vasemmalla on arvioita tehneet henkil&ouml;t. Taulukon solut kuvaavat annettuja arvioita.</p>
		<p>&nbsp;</p>
		<table border="1" style="padding-left:20px">
			<tbody>
				<tr>
					<th>
						Henkilo \ Elokuva</th>
					<td>
						Tuulen viem&auml;&auml;</td>
					<td>
						Hiljaiset sillat</td>
					<td>
						Eraserhead</td>
					<td>
						Blues Brothers</td>
				</tr>
				<tr>
					<td>
						Matti</td>
					<td>
						HUONO (-5)</td>
					<td>
						HYVA (5)</td>
					<td>
						OK (3)</td>
					<td>
						-</td>
				</tr>
				<tr>
					<td>
						Pekka</td>
					<td>
						OK (3)</td>
					<td>
						-</td>
					<td>
						HUONO (-5)</td>
					<td>
						VALTTAVA (-3)</td>
				</tr>
				<tr>
					<td>
						Mikael</td>
					<td>
						-</td>
					<td>
						-</td>
					<td>
						HUONO (-5)</td>
					<td>
						-</td>
				</tr>
				<tr>
					<td>
						Thomas</td>
					<td>
						-</td>
					<td>
						HYVA (5)</td>
					<td>
						-</td>
					<td>
						HYVA (5)</td>
				</tr>
			</tbody>
		</table>
		<p>&nbsp;</p>
		<p>Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eiv&auml;t ole katsoneet yht&auml;k&auml;&auml;n samaa elokuvaa.</p>
		<p>Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).</p>
		<pre>

-5 * -5 = 25
</pre>
		<p>Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat my&ouml;s katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).</p>
		<pre>

-5 * 3 = -15
</pre>
		<p>N&auml;iden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viem&auml;&auml;.</p>
		<p>Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteist&auml; elokuvaa. Matti antoi Tuulen viem&auml;lle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.</p>
		<pre>

-5 * 3 + 3 * -5 = -30
</pre>
		<p>Matin ja Mikaelin samuus on edellisest&auml; laskusta tiedetty -15. Samuudet ovat symmetrisia.</p>
		<p>Matti ja Thomas ovat katsoneet Tuulen viem&auml;&auml;, ja kumpikin antoi sille arvosanan hyv&auml; (5). Matin ja Thomaksen samuus on siis 25.</p>
		<pre>

5 * 5 = 25
</pre>
		<p>Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.</p>
		<p>Toteuta yll&auml; kuvattu suosittelumekanismi. Jos henkil&ouml;lle ei l&ouml;ydy yht&auml;&auml;n suositeltavaa elokuvaa, tai henkil&ouml;, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkil&ouml; ei ole viel&auml; katsonut huonoiksi, v&auml;ltt&auml;viksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code>arvo <code>null</code>. Edellisess&auml; teht&auml;v&auml;ss&auml; m&auml;&auml;ritellyn l&auml;hestymistavan tulee toimia jos henkil&ouml; ei ole lis&auml;nnyt yht&auml;k&auml;&auml;n arviota.</p>
		<p>&Auml;l&auml; suosittele elokuvia, jonka henkil&ouml; on jo n&auml;hnyt.</p>
		<p>Voit testata ohjelmasi toimintaa seuraavalla l&auml;hdekoodilla:</p>
		<pre class="sh_java">

    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva(&quot;Tuulen viem&auml;&auml;&quot;);
    Elokuva hiljaisetSillat = new Elokuva(&quot;Hiljaiset sillat&quot;);
    Elokuva eraserhead = new Elokuva(&quot;Eraserhead&quot;);
    Elokuva bluesBrothers = new Elokuva(&quot;Blues Brothers&quot;);

    Henkilo matti = new Henkilo(&quot;Matti&quot;);
    Henkilo pekka = new Henkilo(&quot;Pekka&quot;);
    Henkilo mikke = new Henkilo(&quot;Mikael&quot;);
    Henkilo thomas = new Henkilo(&quot;Thomas&quot;);
    Henkilo arto = new Henkilo(&quot;Arto&quot;);

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);
    
    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    
    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + &quot; suositus: &quot; + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + &quot; suositus: &quot; + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + &quot; suositus: &quot; + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + &quot; suositus: &quot; + suosittelija.suositteleElokuva(arto));
</pre>
		<pre>

Thomas suositus: Eraserhead
Mikael suositus: Tuulen viem&auml;&auml;
Matti suositus: Blues Brothers
Arto suositus: Hiljaiset sillat
</pre>
		<p>Miljoona k&auml;siss&auml;? :) -- ei ehk&auml; viel&auml;. Kursseilla Johdatus teko&auml;lyyn ja Johdatus koneoppimiseen opitaan lis&auml;&auml; tekniikoita oppivien j&auml;rjestelmien rakentamiseen.</p>
	</div>
	<h3>
		Ennalta m&auml;&auml;rittelem&auml;t&ouml;n m&auml;&auml;r&auml; parametrin arvoja</h3>
	<p>Olemme t&auml;h&auml;n menness&auml; luoneet metodimme siten, ett&auml; niiden parametrien m&auml;&auml;r&auml;t ovat olleet selke&auml;sti m&auml;&auml;ritelty. Java tarjoaa tavan antaa metodille rajoittamattoman m&auml;&auml;r&auml;n m&auml;&auml;r&auml;tyntyyppisi&auml; parametreja asettamalla metodim&auml;&auml;rittelyss&auml; parametrin tyypille kolme pistett&auml; per&auml;&auml;n. Esimerkiksi metodille <code>public int summa(int... luvut)</code>voi antaa summattavaksi niin monta <code>int</code>-tyyppist&auml; kokonaislukua kuin k&auml;ytt&auml;j&auml; haluaa. Metodin sis&auml;ll&auml; parametrin arvoja voi k&auml;sitell&auml; taulukosta.</p>
	<pre class="sh_java">

    public int summa(int... luvut) {
        int summa = 0;
        for (int i = 0; i &lt; luvut.length; i++) {
            summa += luvut[i];
        }
        return summa;
    }
</pre>
	<pre class="sh_java">

    System.out.println(summa(3, 5, 7, 9));
</pre>
	<pre>

24
</pre>
	<p>Metodille voi m&auml;&auml;ritell&auml; vain yhden parametrin joka saa rajattoman m&auml;&auml;r&auml;n arvoja, ja sen tulee olla metodim&auml;&auml;rittelyn viimeinen parametri. Esimerkiksi seuraavanlainen metodim&auml;&auml;rittely ei ole sallittu.</p>
	<pre class="sh_java">

    public void tulosta(String... merkkijonot, int kertaa)
</pre>
	<p>Seuraava metodim&auml;&auml;rittely on sallittu.</p>
	<pre class="sh_java">

    public void tulosta(int kertaa, String... merkkijonot)
</pre>
	<p>Ennalta m&auml;&auml;rittelem&auml;t&ouml;nt&auml; parametrien arvojen m&auml;&auml;r&auml;&auml; k&auml;ytet&auml;&auml;n esimerkiksi silloin, kun halutaan tarjota rajapinta, joka ei rajoita sen k&auml;ytt&auml;j&auml;&auml; tiettyyn parametrien m&auml;&auml;r&auml;&auml;n. Vaihtoehtoinen l&auml;hestymistapa on metodim&auml;&auml;rittely, jolla on parametrina tietyn tyyppinen lista. T&auml;ll&ouml;in oliot voidaan asettaa listaan ennen metodikutsua, ja kutsua metodia antamalla lista sille parametrina.</p>
	<div class="tehtavat">
		<h3>
			Demografiapalvelu</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;sarjassa toteutetaan henkil&ouml;tietopalvelu, johon voi tehd&auml; hakuja k&auml;ytt&auml;j&auml;n m&auml;&auml;rittelemien hakukriteerien avulla. Teht&auml;v&auml;pohjan mukana tulee graafinen k&auml;ytt&ouml;liittym&auml;, jonka avulla omaa toteutusta voi kokeilla helposti.</p>
		<p><b>Huom:</b> Graafinen k&auml;ytt&ouml;liittym&auml; k&auml;ynnistyy vasta ensimm&auml;isess&auml; aliteht&auml;v&auml;ss&auml; k&auml;sitelt&auml;vien <code>PersonAttribute</code>- ja <code>Gender</code>-enumeraatioiden luomisen j&auml;lkeen.</p>
		<h4>
			Henkil&ouml;iden tiedot lueteltuina tyyppein&auml;</h4>
		<p>Lueteltu tyyppi PersonAttribute</p>
		<p>Luo pakkaukseen <code>demographics.logic</code><code>Attribute</code>-rajapinnan toteuttava lueteltu tyyppi <code>PersonAttribute</code>. PersonAttribute m&auml;&auml;rittelee tiedot, joita henkil&ouml;ist&auml; talletetaan henkil&ouml;tietopalveluun. <code>Attribute</code>-rajapinnassa on seuraavat metodit:</p>
		<ul>
			<li>
				<code>public String getId()</code>m&auml;&auml;rittelee attribuutille uniikin, ohjelman koodissa sis&auml;isesti k&auml;ytett&auml;v&auml;n merkkijonotunnuksen -- n&auml;m&auml; tunnukset ovat teht&auml;v&auml;ss&auml; ennaltam&auml;&auml;r&auml;tyt</li>
			<li>
				<code>public String getDisplayName()</code>m&auml;&auml;rittelee attribuutille k&auml;ytt&ouml;liittym&auml;ss&auml; n&auml;ytett&auml;v&auml;n merkkijonokuvauksen -- t&auml;m&auml;n merkkijonon voit m&auml;&auml;ritell&auml; itse</li>
		</ul>
		<p>M&auml;&auml;rittele lueteltuun tyyppiin <code>demographics.logic.PersonAttribute</code>seuraavat vakiot: (suluissa <code>getId()</code>-metodin palauttama merkkijono):</p>
		<ul>
			<li>
				<code>SOCIAL_SECURITY_NUMBER</code>(<code>ssn</code>) - henkil&ouml;tunnus</li>
			<li>
				<code>AGE</code>(<code>age</code>) - ik&auml;</li>
			<li>
				<code>GENDER</code>(<code>gender</code>) - sukupuoli</li>
			<li>
				<code>YEARLY_INCOME</code>(<code>yearlyIncome</code>) - vuositulot</li>
			<li>
				<code>STUDENT</code>(<code>student</code>) - opiskelija</li>
		</ul>
		<pre class="sh_java">

    Attribute attr = PersonAttribute.AGE;
    System.out.println(attr.getId());
</pre>
		<pre>

age
</pre>
		<p>Lueteltu tyyppi Gender</p>
		<p>Luo pakkaukseen <code>demographics.logic</code>sukupuolta kuvaava lueteltuna tyyppin&auml; <code>Gender</code>. Tyypin <code>Gender</code>tulee toteuttaa rajapinta <code>EnumeratedValue</code>. Rajapinnalla <code>EnumeratedValue</code>on vastaavat metodit kuin <code>Attribute</code>-rajapinnalla.</p>
		<p>M&auml;&auml;rittele lueteltuun tyyppiin <code>Gender</code>tunnukset (ID suluissa):</p>
		<ul>
			<li>
				<code>MALE</code>(<code>M</code>)</li>
			<li>
				<code>FEMALE</code>(<code>F</code>)</li>
		</ul>
		<pre class="sh_java">

    EnumeratedValue value = Gender.MALE;
    System.out.println(value.getId());
</pre>
		<pre>

M
</pre>
		<h4>
			PersonImpl</h4>
		<p>Luo pakkaukseen <code>demographics.logic</code>luokka <code>PersonImpl</code>, joka toteuttaa teht&auml;v&auml;pohjasta l&ouml;ytyv&auml;n henkil&ouml;&auml; kuvaavan rajapinnan <code>Person</code>. Henkil&ouml;luokka sis&auml;lt&auml;&auml; attribuutteja, joiden arvot kuvaavat henkil&ouml;n tietoja.</p>
		<p><b>Vinkki!</b> Luokan <code>PersonImpl</code>sis&auml;inen toteutus kannattaa tehd&auml; esimerkiksi hajautustaulun avulla.</p>
		<p><code>Person</code>-rajapinnalla on seuraavat metodit:</p>
		<ul>
			<li>
				<code>Object get(Attribute attribute)</code>palauttaa parametriksi annetun attribuutin arvon</li>
			<li>
				<code>void set(Attribute attribute, Object value)</code>asettaa attribuutin arvon</li>
			<li>
				<code>Collection&lt;Attribute&gt; getDefinedAttributes()</code>palauttaa henkil&ouml;lle m&auml;&auml;riteltyjen attribuuttien tunnukset</li>
		</ul>
		<p><code>PersonImpl</code>-luokkaa voi k&auml;ytt&auml;&auml; esimerkiksi n&auml;in:</p>
		<pre class="sh_java">

    Person person = new PersonImpl();
    person.set(PersonAttribute.SOCIAL_SECURITY_NUMBER, &quot;190481-1871&quot;);
    person.set(PersonAttribute.GENDER, Gender.FEMALE);
    person.set(PersonAttribute.AGE, 28);
    person.set(PersonAttribute.YEARLY_INCOME, 27580);
    person.set(PersonAttribute.STUDENT, true);

    System.out.println(person.get(PersonAttribute.YEARLY_INCOME));
    System.out.println(person.get(PersonAttribute.STUDENT));
</pre>
		<p>Ohjelma tulostaa:</p>
		<pre>

27580
true
</pre>
		<h4>
			Yht&auml;suuruuspredikaatin toteuttaminen</h4>
		<p>Jotta hakukriteereit&auml; voisi k&auml;ytt&auml;&auml; j&auml;rkev&auml;sti, t&auml;ytyy niit&auml; voida yhdistell&auml; melko vapaasti. T&auml;t&auml; varten teht&auml;v&auml;pohjassa on runko luokalle <code>CriteriaBuilderImpl</code>, joka toteuttaa <code>CriteriaBuilder</code>-rajapinnan. Luokan avulla voi luoda <i>predikaatteja</i>. Predikaatti sis&auml;lt&auml;&auml; tiedot hakukriteerist&auml; tai niiden yhdistelm&auml;st&auml; ja sen avulla voidaan selvitt&auml;&auml; onko henkil&ouml; kriteerin mukainen vai ei.</p>
		<p>Predikaatti on m&auml;&auml;ritelty teht&auml;v&auml;pohjassa <code>Predicate</code>-rajapintana:</p>
		<ul>
			<li>
				<code>boolean matches(Person person)</code>palauttaa <code>true</code>, jos parametriksi annettu henkil&ouml; on predikaatin sis&auml;lt&auml;mien kriteerien mukainen, muutoin metodi palauttaa <code>false</code></li>
		</ul>
		<pre class="sh_java">

package demographics.logic;

public interface Predicate {
    boolean matches(Person person);
}
</pre>
		<p><code>CriteriaBuilder</code>-rajapinnan koodi:</p>
		<pre class="sh_java">

package demographics.logic;

public interface CriteriaBuilder {
    Predicate allOf(Predicate... predicates);
    Predicate oneOf(Predicate... predicates);
    Predicate not(Predicate predicate);

    Predicate equalTo(Attribute attribute, Object value);

    Predicate greaterThan(Attribute attribute, int value);
    Predicate lessThan(Attribute attribute, int value);
    Predicate greaterThanOrEqualTo(Attribute attribute, int value);
    Predicate lessThanOrEqualTo(Attribute attribute, int value);
}
</pre>
		<p>Toteutetaan <code>CriteriaBuilderImpl</code>-luokan runkoon metodi <code>equalTo</code>. Muut metodit voi j&auml;tt&auml;&auml; viel&auml; toteuttamatta, koska niit&auml; tarvitaan vasta my&ouml;hemmin.</p>
		<ul>
			<li>
				<code>Predicate equalTo(Attribute attribute, Object value)</code>palauttaa predikaatin ehdon, joka toteutuu kun henkil&ouml;ll&auml; olevan attribuutin arvo vastaa parametrina mainittua arvoa</li>
		</ul>
		<p>Metodia <code>equalTo</code>varten tarvitset uuden <code>Predicate</code>-rajapinnan toteuttavan luokan. Toteuta uusi predikaattiluokka siten, ett&auml; se saa konstruktorissa parametrina <code>Attribute</code>-rajapinnan toteuttavan attribuutin, sek&auml; halutun arvon. Predikaatin metodin <code>matches</code>tulee palauttaa <code>true</code>jos sille parametrina annettu <code>Person</code>-luokan ilmentym&auml;n arvot sopivat predikaattiluokassa m&auml;&auml;riteltyyn attribuuttiin ja sen arvoon.</p>
		<p>Palauta uusi predikaattiluokan ilmentym&auml; <code>CriteriaBuilderImpl</code>-luokan metodissa <code>equalTo</code>metodin saamilla parametreilla.</p>
		<p>Kun ensimm&auml;inen predikaatti on toteutettu, sen toteuttamaa ehtoa voi kokeilla <code>matches()</code>-metodin avulla esimerkiksi seuraavalla tavalla:</p>
		<pre class="sh_java">

    Person person1 = new PersonImpl();
    person1.set(PersonAttribute.SOCIAL_SECURITY_NUMBER, &quot;213821871&quot;);
    person1.set(PersonAttribute.GENDER, Gender.FEMALE);
    person1.set(PersonAttribute.AGE, 28);
    person1.set(PersonAttribute.YEARLY_INCOME, 27580);
    person1.set(PersonAttribute.STUDENT, true);

    CriteriaBuilder is = new CriteriaBuilderImpl();

    System.out.println(is.equalTo(PersonAttribute.STUDENT, false).matches(person1));
    System.out.println(is.equalTo(PersonAttribute.GENDER, Gender.FEMALE).matches(person1));
</pre>
		<p>Ohjelma tulostaa:</p>
		<pre>

false
true
</pre>
		<h4>
			Henkil&ouml;rekisteri</h4>
		<p>Henkil&ouml;tietojen tutkimiseen tarvitaan tiedoille s&auml;ilytyspaikka, jota varten teht&auml;v&auml;ss&auml; luodaan henkil&ouml;rekisteri. T&auml;ydenn&auml; luokkaa <code>PersonRegistryImpl</code>siten, ett&auml; se toteuttaa rajapinnan <code>PersonRegistry</code>alla kuvatusti.</p>
		<ul>
			<li>
				<code>void add(Person person)</code>lis&auml;&auml; henkil&ouml;n rekisteriin</li>
			<li>
				<code>void remove(Person person)</code>poistaa henkil&ouml;n rekisterist&auml;</li>
			<li>
				<code>void clear()</code>tyhjent&auml;&auml; rekisterin</li>
			<li>
				<code>List&lt;Person&gt; getPersons()</code>palauttaa rekisteriss&auml; olevat henkil&ouml;t</li>
			<li>
				<code>List&lt;Person&gt; query(Predicate predicate)</code>palauttaa kaikki rekisterin henkil&ouml;t, kun parametrina annettu predikaatti on <code>null</code>-- t&auml;ss&auml; vaiheessa ei viel&auml; tarvitse toteuttaa muuta toiminnallisuutta metodille</li>
			<li>
				<code>List&lt;Person&gt; remove(Predicate predicate)</code>palauttaa tyhj&auml;n listan, kun parametrina annettu predikaatti on <code>null</code>-- t&auml;ss&auml; vaiheessa ei viel&auml; tarvitse toteuttaa muuta toiminnallisuutta metodille</li>
			<li>
				<code>CriteriaBuilder getCriteriaBuilder()</code>palauttaa <code>CriteriaBuilder</code>-olion, jolla voi luoda predikaatteja -- metodi palauttaa aina saman CriteriaBuilder-olion</li>
		</ul>
		<pre class="sh_java">

package demographics.logic;

import java.util.List;

public interface PersonRegistry {
    void add(Person person);
    void remove(Person person);
    void clear();

    List&lt;Person&gt; getPersons();

    List&lt;Person&gt; query(Predicate predicate);
    List&lt;Person&gt; remove(Predicate predicate);

    CriteriaBuilder getCriteriaBuilder();
}
</pre>
		<h4>
			Henkil&ouml;tietokyselyjen tekeminen</h4>
		<p>Laajenna <code>PersonRegistryImpl</code>-henkil&ouml;rekisteriluokan metodeita seuraavasti:</p>
		<ul>
			<li>
				<code>List&lt;Person&gt; query(Predicate predicate)</code>palauttaa rekisterin henkil&ouml;t, joiden attribuutit toteuttavat annetun predikaatin ehdon -- aiemmin toteutettu toiminnallisuus parametrin <code>null</code>-arvolla tulee my&ouml;s s&auml;ilytt&auml;&auml;</li>
			<li>
				<code>List&lt;Person&gt; remove(Predicate predicate)</code>hakee rekisterist&auml; henkil&ouml;t, joiden attribuutit toteuttavat annetun predikaatin ehdon. L&ouml;ydetyt henkil&ouml;t poistetaan rekisterist&auml; ja palautetaan listassa -- aiemmin toteutettu toiminnallisuus parametrin <code>null</code>-arvolla tulee my&ouml;s s&auml;ilytt&auml;&auml;</li>
		</ul>
		<p>Henkil&ouml;rekisteriin tulee my&ouml;s pysty&auml; tehd&auml; hakuja yht&auml;suuruuspredikaatin avulla esimerkiksi seuraavalla tavalla:</p>
		<pre class="sh_java">

    Person person1 = new PersonImpl();
    person1.set(PersonAttribute.SOCIAL_SECURITY_NUMBER, &quot;213821871&quot;);
    person1.set(PersonAttribute.GENDER, Gender.FEMALE);
    person1.set(PersonAttribute.AGE, 28);
    person1.set(PersonAttribute.YEARLY_INCOME, 27580);
    person1.set(PersonAttribute.STUDENT, true);

    Person person2 = new PersonImpl();
    person2.set(PersonAttribute.SOCIAL_SECURITY_NUMBER, &quot;98423874&quot;);
    person2.set(PersonAttribute.GENDER, Gender.MALE);
    person2.set(PersonAttribute.AGE, 54);
    person2.set(PersonAttribute.YEARLY_INCOME, 45200);
    person2.set(PersonAttribute.STUDENT, false);

    PersonRegistry registry = new PersonRegistryImpl();
    registry.add(person1);
    registry.add(person2);

    CriteriaBuilder is = registry.getCriteriaBuilder();

    List&lt;Person&gt; results1 = registry.query(is.equalTo(PersonAttribute.STUDENT, false));

    List&lt;Person&gt; results2 = registry.query(is.equalTo(PersonAttribute.GENDER, Gender.FEMALE));

    List&lt;Person&gt; removed = registry.remove(is.equalTo(PersonAttribute.GENDER, Gender.MALE));
</pre>
		<h4>
			<code>allOf</code>-predikaatin toteuttaminen</h4>
		<p>Jotta hakuehtojen k&auml;ytt&ouml; olisi mielek&auml;st&auml;, t&auml;ytyy niit&auml; voida yhdistell&auml;. <code>allOf</code>-predikaatti yhdist&auml;&auml; kaikki sille parametreina annetut predikaatit siten, ett&auml; kaikkien predikaattien ehtojen on toteuduttava, jotta yhdistelm&auml;predikaatin ehto toteutuisi.</p>
		<p>Esimerkiksi seuraava predikaatti toteutuu vain, jos henkil&ouml; on mies <b>ja</b> h&auml;n ei ole opiskelija:</p>
		<pre class="sh_java">

    CriteriaBuilder is = registry.getCriteriaBuilder();

    Predicate predicate = is.allOf(is.equalTo(PersonAttribute.STUDENT, false), is.equalTo(PersonAttribute.Gender, Gender.MALE));
</pre>
		<p>Toteuta <code>CriteriaBuilderImpl</code>-luokalle allOf-predikaatti:</p>
		<ul>
			<li>
				<code>Predicate allOf(Predicate... predicates)</code>palauttaa JA-ehdon mukaisen predikaatin, jolloin predikaatin ehto toteutuu vain jos kaikkien parametriksi annettujen predikaattien ehdot toteutuvat</li>
		</ul>
		<p><b>Huom:</b> allOf-predikaatin toteuttamisen j&auml;lkeen k&auml;ytt&ouml;liittym&auml;n <i>Filter...</i>- ja <i>Remove...</i>-ominaisuudet alkavat toimia. T&auml;ss&auml; vaiheessa voit tosin k&auml;ytt&auml;&auml; vasta yht&auml;suuruusehtoa (=) ja &quot;matching&quot;-vaihtoehtoa (eli &quot;non-matching&quot; ei toimi), koska n&auml;m&auml; toiminnot toteutetaan vasta my&ouml;hemmin.</p>
		<p><b>Vinkki!</b> T&auml;ss&auml; kohdassa kannattaa esimerkiksi muistella miten teht&auml;v&auml;n 164 koostekuvio koostui...</p>
		<h4>
			Kokonaislukujen vertailuun tarkoitettujen predikaattien toteuttaminen</h4>
		<p>Toteuta <code>CriteriaBuilderImpl</code>-luokalle seuraavat metodit:</p>
		<ul>
			<li>
				<code>Predicate greaterThan(Attribute attribute, Object value)</code>palauttaa predikaatin ehdon, joka toteutuu kun henkil&ouml;ll&auml; olevan attribuutin kokonaislukuarvo on suurempi kuin parametrina mainittu arvo</li>
			<li>
				<code>Predicate lessThan(Attribute attribute, Object value)</code>palauttaa predikaatin ehdon, joka toteutuu kun henkil&ouml;ll&auml; olevan attribuutin kokonaislukuarvo on pienempi kuin parametrina mainittu arvo</li>
			<li>
				<code>Predicate greaterThanOrEqualTo(Attribute attribute, Object value)</code>palauttaa predikaatin ehdon, joka toteutuu kun henkil&ouml;ll&auml; olevan attribuutin kokonaislukuarvo on yht&auml; suuri tai suurempi kuin parametrina mainittu arvo</li>
			<li>
				<code>Predicate lessThanOrEqualTo(Attribute attribute, Object value)</code>palauttaa predikaatin ehdon, joka toteutuu kun henkil&ouml;ll&auml; olevan attribuutin kokonaislukuarvo on yht&auml; suuri tai pienempi kuin parametrina mainittu arvo</li>
		</ul>
		<p>Henkil&ouml;rekisteriin voi tehd&auml; hakuja kokonaislukujen vertailupredikaateilla esimerkiksi n&auml;in:</p>
		<pre class="sh_java">

    Person person1 = new PersonImpl();
    person1.set(PersonAttribute.SOCIAL_SECURITY_NUMBER, &quot;94726823&quot;);
    person1.set(PersonAttribute.GENDER, Gender.FEMALE);
    person1.set(PersonAttribute.AGE, 37);
    person1.set(PersonAttribute.YEARLY_INCOME, 17500);
    person1.set(PersonAttribute.STUDENT, false);

    Person person2 = new PersonImpl();
    person2.set(PersonAttribute.SOCIAL_SECURITY_NUMBER, &quot;38271623&quot;);
    person2.set(PersonAttribute.GENDER, Gender.MALE);
    person2.set(PersonAttribute.AGE, 60);
    person2.set(PersonAttribute.YEARLY_INCOME, 50000);
    person2.set(PersonAttribute.STUDENT, false);

    PersonRegistry registry = new PersonRegistryImpl();
    registry.add(person1);
    registry.add(person2);

    CriteriaBuilder is = registry.getCriteriaBuilder();

    List&lt;Person&gt; results1 = registry.query(is.greaterThan(PersonAttribute.AGE, 40));

    List&lt;Person&gt; results2 = registry.query(is.lessThanOrEqualTo(PersonAttribute.YEARLY_INCOME, 50000));
</pre>
		<p><b>Huom:</b> Nyt voit k&auml;ytt&auml;&auml; k&auml;ytt&ouml;liittym&auml;ss&auml; vertailuoperaatioita: &gt;, &lt;, &gt;= ja &lt;=.</p>
		<h4>
			<code>not</code>-predikaatin toteuttaminen</h4>
		<p>Jatketaan predikaattien toteuttamista. <code>not</code>-predikaatti yksinkertaisesti vaihtaa sille annetun predikaatin totuusarvon p&auml;invastaiseksi.</p>
		<p><code>not</code>-predikaatti toimii n&auml;in:</p>
		<pre class="sh_java">

    CriteriaBuilder is = registry.getCriteriaBuilder();
 
    // Predikaatti toteutuu, jos henkil&ouml; ei ole 6-vuotias
    Predicate predicate1 = is.not(is.equalTo(PersonAttribute.AGE, 6));

    // Predikaatti toteutuu, jos henkil&ouml; ei ole alle 18-vuotias
    Predicate predicate2 = is.not(is.lessThan(PersonAttribute.AGE, 18));

    // Predikaatti toteutuu, jos henkil&ouml; ei ole mies
    Predicate predicate3 = is.not(is.equalTo(PersonAttribute.GENDER, Gender.MALE));
</pre>
		<p>Toteuta <code>CriteriaBuilderImpl</code>-luokalle metodi:</p>
		<ul>
			<li>
				<code>Predicate not(Predicate predicate)</code>k&auml;&auml;nt&auml;&auml; parametriksi annetun predikaatin ehdon, eli kun annetun predikaatin ehto toteutuu, not-predikaatti ei toteudu, ja toisinp&auml;in</li>
		</ul>
		<p><b>Huom:</b> <code>not</code>-predikaatin toteuttamisen j&auml;lkeen k&auml;ytt&ouml;liittym&auml;n kaikki toiminnot ovat k&auml;ytett&auml;viss&auml;.</p>
		<h4>
			<code>oneOf</code>-predikaatin toteuttaminen</h4>
		<p><code>oneOf</code>-predikaatin ehto toteutuu, jos v&auml;hint&auml;&auml;n yksi sille annetuista predikaateista toteutuu.</p>
		<p>Esimerkiksi seuraava <code>oneOf</code>-predikaatti toteutuu, jos henkil&ouml; on <b>joko</b> nainen (opiskelijastatuksella ei ole v&auml;li&auml;) <b>tai</b> opiskelija (jolloin sukupuolella ei ole v&auml;li&auml;):</p>
		<pre class="sh_java">

    CriteriaBuilder is = registry.getCriteriaBuilder();

    Predicate predicate = is.oneOf(is.equalTo(PersonAttribute.STUDENT, true), 
is.equalTo(PersonAttribute.Gender, Gender.FEMALE));
</pre>
		<p>Predikaatteja voidaan my&ouml;s yhdistell&auml; l&auml;hes mielivaltaisesti. Edellinen ehto voidaan k&auml;&auml;nt&auml;&auml; p&auml;invastaiseksi <code>not</code>-predikaatilla, jolloin se toteutuu vain, jos henkil&ouml; <b>ei</b> ole nainen <b>eik&auml;</b> opiskelija:</p>
		<pre class="sh_java">

    CriteriaBuilder is = registry.getCriteriaBuilder();

    Predicate predicate = is.not(is.oneOf(is.equalTo(PersonAttribute.STUDENT, true), 
is.equalTo(PersonAttribute.Gender, Gender.FEMALE)));
</pre>
		<p>Toteuta <code>CriteriaBuilderImpl</code>-luokalle metodi:</p>
		<ul>
			<li>
				<code>Predicate oneOf(Predicate... predicates)</code>palauttaa TAI-ehdon mukaisen predikaatin, jolloin predikaatin ehto toteutuu, jos parametriksi annettujen predikaattien ehdoista ainakin yksi toteutuu</li>
		</ul>
		<p><b>Huom:</b> <code>oneOf</code>-predikaattia ei voi testata k&auml;ytt&ouml;liittym&auml;n kautta.</p>
		<h3>
			Nopeustesti</h3>
		<!--
<p>Tässä tehtäväsarjassa toteutetaan seuraavan tapainen peli:</p>

<p>
<iframe title="YouTube video player" width="480" height="390" src="http://www.youtube.com/embed/IsQhEw33ULY" frameborder="0" allowfullscreen></iframe>
</p>
//-->
		<p>Luodaan ohjelma, joka mittaa kliksutteluvauhtia. K&auml;ytt&ouml;liittym&auml; tulee n&auml;ytt&auml;m&auml;&auml;n esimerkiksi seuraavalta.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/169-nopeustesti.png" /></p>
		<h4 class="req">
			Oma luokka JButtonille</h4>
		<p>Toteuta pakkaukseen <code>nopeustesti</code>luokka <code>Nappi</code>, joka perii JButtonin. Luokalla <code>Nappi</code>tulee olla konstruktori <code>public Nappi(String text, Color aktiivinen, Color passiivinen)</code>. Konstruktorin parametrina saama merkkijono <code>text</code>tulee antaa parametrina yl&auml;luokan konstruktorille (kutsu <code>super(text)</code>).</p>
		<p>Korvaa luokasta JButton peritty metodi <code>protected void paintComponent(Graphics g)</code>siten, ett&auml; piirr&auml;t metodissa napin kokoisen v&auml;rillisen ympyr&auml;n. Saat napin leveyden ja korkeuden JButton-luokalta perityist&auml; metodeista <code>getWidth()</code>ja <code>getHeight()</code>. Kutsu korvatun metodin alussa yl&auml;luokan <code>paintComponent</code>-metodia.</p>
		<p>Ympyr&auml;n v&auml;rin tulee riippua Napin tilasta: jos nappi on aktiivinen (metodi <code>isEnabled</code>palauttaa <code>true</code>tulee ympyr&auml;n v&auml;ri olla konstruktorin parametrina saatu <code>aktiivinenVari</code>. Muulloin k&auml;ytet&auml;&auml;n v&auml;ri&auml; <code>passiivinenVari</code>.</p>
		<h4 class="req">
			Perustoiminta</h4>
		<p>Toteuta luokkaan <code>Nopeustesti</code>k&auml;ytt&ouml;liittym&auml;, jossa on nelj&auml; nappulaa ja teksti. K&auml;yt&auml; asettelussa napeille omaa JPanel-alustaa, joka asetetaan BorderLayout-asettelijan keskelle. Teksti tulee BorderLayout-asettelijan alaosaan.</p>
		<p>K&auml;yt&auml; edellisess&auml; osassa luomaasi <code>Nappi</code>-luokkaa. Napeille tulee antaa konstruktorissa tekstit 1, 2, 3 ja 4.</p>
		<h4 class="req">
			Nappuloiden aktiivisuus</h4>
		<p>Vain yhden nappulan kerrallaan tulee olla painettavissa (eli aktiivisena). Voit tehd&auml; nappulasta ei-aktiivisen metodikutsulla <code>nappi.setEnabled(false)</code>. Vastaavasti nappi muutetaan aktiiviseksi kutsulla <code>nappi.setEnabled(true)</code>.</p>
		<p>Kun aktiivisena olevaa nappulaa painetaan, tulee k&auml;ytt&ouml;liittym&auml;n arpoa uusi aktiivinen nappi.</p>
		<h4 class="req">
			Pisteytys</h4>
		<p>Tehd&auml;&auml;n peliin pisteytys: mitataan 20 painallukseen kuluva aika. Helpoin tapa ajan mittaamiseen on metodin <code>System.currentTimeMillis()</code>kutsuminen. Metodi palauttaa kokonaisluvunu, joka laskee millisekunteja (tuhannesosasekunteja) jostain tietysti ajanhetkest&auml; l&auml;htien. Siisp&auml; voit mitata kulunutta aikaa kutsumalla <code>currentTimeMillis</code>pelin alussa ja lopussa ja laskemalla erotuksen.</p>
		<p>Toteuta siis seuraava: peli laskee napinpainallusten m&auml;&auml;r&auml;n, ja 20. painalluksen j&auml;lkeen asettaa kaikki nappulat ep&auml;aktiivisiksi ja n&auml;ytt&auml;&auml; <code>JLabel</code>-komponentissa viestin <code>"Pisteesi: XXXX"</code>, jossa <code>XXXX</code>on painalluksiin kulunut aika (millisekunteina) jaettuna 20:lla. Pienempi pistem&auml;&auml;r&auml; on siis parempi.</p>
		<h3>
			Matopeli</h3>
		<p>T&auml;ss&auml; teht&auml;v&auml;ss&auml; luodaan rakenteet ja osa toiminnallisuudesta seuraavann&auml;k&ouml;iseen matopeliin.</p>
		<p><img src="http://www.cs.helsinki.fi/group/java/k12/ohja/img-ohja/kali/170-matopeli.png" /></p>
		<h4>
			Yleisk&auml;ytt&ouml;inen luokka Pala ja Omena</h4>
		<p>Luo pakkaukseen <code>matopeli.domain</code>luokka <code>Pala</code>. Luokalla <code>Pala</code>on konstruktori <code>public Pala(int x, int y)</code>, joka saa palan sijainnin parametrina. Lis&auml;ksi luokalla <code>Pala</code>on seuraavat metodit.</p>
		<ul>
			<li>
				<code>public int getX()</code>palauttaa Palan konstruktorissa saadun x-koordinaatin.</li>
			<li>
				<code>public int getY()</code>palauttaa Palan konstruktorissa saadun y-koordinaatin.</li>
			<li>
				<code>public boolean osuu(Pala pala)</code>palauttaa true jos oliolla on sama x- ja y-koordinaatti kuin parametrina saadulla Pala-luokan ilmentym&auml;ll&auml;.</li>
			<li>
				<code>public String toString()</code>palauttaa palan sijainnin muodossa <code>(x,y)</code>. Esim. <code>(5,2)</code>kun x-koordinaatin arvo on 5 ja y-koordinaatin arvo on 2.</li>
		</ul>
		<p>Toteuta pakkaukseen <code>matopeli.domain</code>my&ouml;s luokka <code>Omena</code>. Peri luokalla Omena luokka <code>Pala</code>.</p>
		<h4>
			Mato</h4>
		<p>Toteuta pakkaukseen <code>matopeli.domain</code>luokka <code>Mato</code>. Luokalla <code>Mato</code>on konstruktori <code>public Mato(int alkuX, int alkuY, Suunta alkusuunta)</code>, joka luo uuden madon jonka suunta on parametrina annettu <code>alkusuunta</code>. Mato koostuu listasta <code>Pala</code>-luokan ilmentymi&auml;.</p>
		<p>Mato luodaan yhden palan pituisena, mutta madon &quot;aikuispituus&quot; on kolme. Madon tulee kasvaa yhdell&auml; aina kun se liikkuu. Kun madon pituus on kolme, se kasvaa isommaksi vain sy&ouml;dess&auml;&auml;n.</p>
		<p>Toteuta madolle seuraavat metodit</p>
		<ul>
			<li>
				<code>public Suunta getSuunta()</code>palauttaa madon suunnan.</li>
			<li>
				<code>public void setSuunta(Suunta suunta)</code>asettaa madolle uuden suunnan. Mato liikkuu uuteen suuntaan kun metodia <code>liiku</code>kutsutaan seuraavan kerran.</li>
			<li>
				<code>public List&lt;Pala&gt; getPalat()</code>palauttaa listan pala-olioita, joista mato koostuu.</li>
			<li>
				<code>public int getPituus()</code>palauttaa madon pituuden. Madon pituuden tulee olla sama kuin <code>getPalat()</code>-metodikutsun palauttaman listan alkioiden m&auml;&auml;r&auml;.</li>
			<li>
				<code>public void liiku()</code>liikuttaa matoa yhden palan verran eteenp&auml;in.</li>
			<li>
				<code>public void kasva()</code>kasvattaa madon kokoa yhdell&auml;. Madon kasvaminen tapahtuu seuraavan <code>liiku</code>-metodikutsun yhteydess&auml;.</li>
			<li>
				<code>public boolean osuu(Pala pala)</code>tarkistaa osuuko mato parametrina annettuun palaan. Jos mato osuu palaan, eli joku madon pala osuu metodille parametrina annettuun palaan, tulee metodin palauttaa arvo <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
			<li>
				<code>public boolean osuuItseensa()</code>tarkistaa osuuko mato itseens&auml;. Jos mato osuu itseens&auml;, eli joku sen pala osuu johonkin toiseen sen palaan, metodi palauttaa arvon <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
		</ul>
		<p>Metodien <code>public void kasva()</code>ja <code>public void liiku()</code>toiminnallisuus tulee toteuttaa siten, ett&auml; mato kasvaa vasta seuraavalla liikkumiskerralla.</p>
		<p>Liikkuminen kannattaa toteuttaa siten, ett&auml; madolle luodaan liikkuessa aina uusi pala. Uuden palan sijainti riippuu madon kulkusuunnasta: vasemmalle menness&auml; uuden palan sijainti on edellisen p&auml;&auml;palan sijainnista yksi vasemmalle, eli sen x-koordinaatti on yht&auml; pienempi. Jos uuden palan sijainti on edellisen p&auml;&auml;palan alapuolella, eli madon suunta on alas, tulee uuden palan y-koordinaatin olla yht&auml; isompi kuin p&auml;&auml;palan y-koordinaatti (k&auml;yt&auml;mme siis piirt&auml;misest&auml; tuttua koordinaattij&auml;rjestelm&auml;&auml;, jossa y-akseli on k&auml;&auml;ntynyt).</p>
		<p>Liikkuessa uusi pala lis&auml;t&auml;&auml;n listalle, ja viimeisin poistetaan listan lopusta. T&auml;ll&ouml;in jokaisen palan koordinaatteja ei tarvitse p&auml;ivitt&auml;&auml; erikseen. Toteuta kasvaminen siten, ett&auml; palaa viimeisint&auml; palaa ei poisteta jos metodia <code>kasva</code>on juuri kutsuttu.</p>
		<p>Huom! Kasvata matoa aina sen liikkuessa jos sen pituus on pienempi kuin 3.</p>
		<pre class="sh_java">

        Mato mato = new Mato(5, 5, Suunta.OIKEA);
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        
        mato.kasva();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());

        mato.setSuunta(Suunta.VASEN);
        System.out.println(mato.osuuItseensa());
        mato.liiku();
        System.out.println(mato.osuuItseensa());
</pre>
		<pre>

[(5,5)]
[(6,5), (5,5)]
[(7,5), (6,5), (5,5)]
[(8,5), (7,5), (6,5)]
[(8,5), (7,5), (6,5)]
[(9,5), (8,5), (7,5), (6,5)]
false
true
</pre>
		<h4>
			Matopeli, osa 1</h4>
		<p>Muokataan seuraavaksi pakkauksessa <code>matopeli.peli</code>olevaa matopelin toiminnallisuutta kapseloivaa luokka <code>Matopeli</code>. Matopeli-luokka perii luokan <code>Timer</code>, joka tarjoaa ajastustoiminnallisuuden pelin p&auml;ivitt&auml;miseen. Luokka <code>Timer</code>vaatii toimiakseen <code>ActionListener</code>-rajapinnan toteuttavan luokan. Olemme toteuttaneet luokalla <code>Matopeli</code>rajapinnan <code>ActionListener</code>.</p>
		<p>Muokkaa matopelin konstruktorin toiminnallisuutta siten, ett&auml; konstruktorissa luodaan peliin liittyv&auml; <code>Mato</code>. Luo mato siten, ett&auml; sijainti riippuu Matopeli-luokan konstruktorissa saaduista parametreista. Madon x-koordinaatin tulee olla <code>leveys / 2</code>, y-koordinaatin <code>korkeus / 2</code>ja suunnan <code>Suunta.ALAS</code>.</p>
		<p>Luo konstruktorissa my&ouml;s omena. Konstruktorissa luotavan omenan sijainnin tulee olla satunnainen, kuitenkin niin ett&auml; omenan x-koordinaatti on aina v&auml;lill&auml; <code>[0, leveys[</code>, ja y-koordinaatti v&auml;lill&auml; <code>[0, korkeus[</code>.</p>
		<p>Lis&auml;&auml; matopeliin lis&auml;ksi seuraavat metodit</p>
		<ul>
			<li>
				<code>public Mato getMato()</code>palauttaa matopelin madon.</li>
			<li>
				<code>public void setMato(Mato mato)</code>asettaa matopeliin metodin parametrina olevan madon. Jos metodia <code>getMato</code>kutsutaan madon asetuksen j&auml;lkeen, tulee metodin <code>getMato</code>palauttaa viite <em>samaan</em> matoon.</li>
			<li>
				<code>public Omena getOmena</code>palauttaa matopelin omenan.</li>
			<li>
				<code>public void setOmena(Omena omena)</code>asettaa matopeliin metodin parametrina olevan omenan. Jos metodia <code>getOmena</code>kutsutaan omenan asetuksen j&auml;lkeen, tulee metodin <code>getOmena</code>palauttaa viite <em>samaan</em> omenaan.</li>
		</ul>
		<h4>
			Matopeli, osa 2</h4>
		<p>Muokkaa metodin <code>actionPerformed</code>-toiminnallisuutta siten, ett&auml; metodissa toteutetaan seuraavat askeleet annetussa j&auml;rjestyksess&auml;.</p>
		<ol>
			<li>
				Liikuta matoa</li>
			<li>
				Jos mato osuu omenaan, sy&ouml; omena ja kutsu madon kasva-metodia. Arvo peliin uusi omena.</li>
			<li>
				Jos mato t&ouml;rm&auml;&auml; itseens&auml;, aseta muuttujan <code>jatkuu</code>arvoksi <code>false</code></li>
			<li>
				Kutsu rajapinnan <code>Paivitettava</code>toteuttavan muuttujan <code>paivitettava</code>metodia <code>paivita</code>.</li>
			<li>
				Kutsu Timer-luokalta peritty&auml; <code>setDelay</code>-metodia siten, ett&auml; pelin nopeus kasvaa suhteessa madon pituuteen. Kutsu <code>setDelay(1000 / <em>mato</em>.getPituus());</code>k&auml;y hyvin: kutsussa oletetaan ett&auml; olet m&auml;&auml;ritellyt oliomuuttujan nimelt&auml; <code>mato</code>.</li>
		</ol>
		<p>Aletaan seuraavaksi rakentamaan k&auml;ytt&ouml;liittym&auml;komponentteja.</p>
		<h4>
			N&auml;pp&auml;imist&ouml;n kuuntelija</h4>
		<p>Toteuta pakkaukseen <code>matopeli.gui</code>luokka <code>Nappaimistonkuuntelija</code>. Luokalla on konstruktori <code>public Nappaimistonkuuntelija(Mato mato)</code>, ja se toteuttaa rajapinnan <code>KeyListener</code>. Korvaa metodi <code>keyPressed</code>siten, ett&auml; nuolin&auml;pp&auml;int&auml; yl&ouml;s painettaessa madolle asetetaan suunta yl&ouml;s. Nuolin&auml;pp&auml;int&auml; alas painettaessa madolle asetetaan suunta alas, vasemmalle painettaessa suunta vasen, ja oikealle painettaessa suunta oikea.</p>
		<h4>
			Piirtoalusta</h4>
		<p>Toteuta pakkaukseen <code>matopeli.gui</code>luokka <code>Piirtoalusta</code>, joka perii luokan <code>JPanel</code>. Piirtoalusta saa konstruktorin parametrina luokan <code>Matopeli</code>ilmentym&auml;n sek&auml; int-tyyppisen muuttujan <code>palanSivunPituus</code>. Muuttuja <code>palanSivunPituus</code>kertoo mink&auml; levyinen ja korkuinen yksitt&auml;inen pala on.</p>
		<p>Korvaa luokalta <code>JPanel</code>peritty metodi <code>paintComponent</code>siten, ett&auml; piirr&auml;t metodissa <code>paintComponent</code>madon ja omenan. K&auml;yt&auml; madon piirt&auml;miseen Graphics-olion tarjoamaa <code>fill3DRect</code>-metodia. Madon v&auml;rin tulee olla valkoinen (<code>Color.WHITE</code>). Omenan piirt&auml;misess&auml; tulee k&auml;ytt&auml;&auml; Graphics-olion tarjoamaa <code>fillOval</code>-metodia. Omenan v&auml;rin tulee olla punainen (<code>Color.RED</code>).</p>
		<p>Toteuta luokalla <code>Piirtoalusta</code>my&ouml;s rajapinta <code>Paivitettava</code>. Paivitettava-rajapinnan m&auml;&auml;rittelem&auml;n metodin <code>paivita</code>tulee kutsua JPanel-luokan <code>repaint</code>-metodia.</p>
		<h4>
			Kayttoliittyma</h4>
		<p>Muuta luokkaa <code>Kayttoliittyma</code>siten, ett&auml; k&auml;ytt&ouml;liittym&auml; sis&auml;lt&auml;&auml; piirtoalustan. Metodissa <code>luoKomponentit</code>tulee luoda piirtoalustan ilmentym&auml; ja lis&auml;t&auml; se container-olioon. Luo metodin <code>luoKomponentit</code>lopussa luokan <code>Nappaimistokuuntelija</code>ilmentym&auml;, ja lis&auml;&auml; se frame-olioon.</p>
		<p>Lis&auml;&auml; luokalle <code>Kayttoliittyma</code>my&ouml;s metodi <code>public Paivitettava getPaivitettava()</code>, joka palauttaa metodissa <code>luoKomponentit</code>luotavan piirtoalustan.</p>
		<p>Voit k&auml;ynnist&auml;&auml; k&auml;ytt&ouml;liittym&auml;n <code>Main</code>-luokassa seuraavasti. Ennen pelin k&auml;ynnistyst&auml; odotamme ett&auml; k&auml;ytt&ouml;liittym&auml; luodaan. Kun k&auml;ytt&ouml;liittym&auml; on luotu, se kytket&auml;&auml;n matopeliin ja matopeli k&auml;ynnistet&auml;&auml;n.</p>
	</div>
</div>
<p>&nbsp;</p>
    </div>

    
      </div><!-- /inner -->

  </div><!-- /node-139 -->
                                                                  </div><!-- /content-content -->
                                                              </div><!-- /content-inner-inner -->
                            </div><!-- /content-inner -->
                          </div><!-- /content-region-inner -->
                        </div><!-- /content-region -->

                        <div id="content-bottom" class="content-bottom row nested ">
<div id="content-bottom-inner" class="content-bottom-inner inner clearfix">

<div id="block-block-1" class="block block-block odd first last grid16-16">
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
      	<div class="inner-wrapper">
      <div class="inner-inner">
                <div class="content clearfix">
          <div id="header-top-block">
<p class="rtecenter">
IRCnet: #mooc.fi &nbsp;&nbsp; <a href="http://twitter.com/mooc1"><img src="http://a3.twimg.com/a/1325610970/images/logos/twitter_newbird_blue.png" height="50" style="vertical-align: middle;"> Twitter </a><a href="http://www.facebook.com/Moocfi"><img src="/sites/mooc.cs.helsinki.fi/files/f_logo-1.png" height="30" style="vertical-align: middle; padding: 10px;"> Facebook</a> &nbsp;&nbsp;<a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a><br>
<img alt="Helsingin yliopiston logo" src="/sites/mooc.cs.helsinki.fi/files/hy.png" style="width: 45px; height: 45px; vertical-align: middle;" /><a href="http://www.cs.helsinki.fi">&nbsp; </a> <a href="http://www.cs.helsinki.fi">Tietojenk&auml;sittelytieteen laitos</a> | <a href="http://www.helsinki.fi/yliopisto">Helsingin yliopisto</a></p>
	</div>
        </div>
      </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --></div><!-- /content-bottom-inner -->
</div><!-- /content-bottom -->
                      </div><!-- /content-group-inner -->
                    </div><!-- /content-group -->

                                      </div><!-- /main-content-inner -->
                </div><!-- /main-content -->

                              </div><!-- /main-group-inner -->
            </div><!-- /main-group -->
          </div><!-- /main-inner -->
        </div><!-- /main -->
      </div><!-- /main-wrapper -->

      <!-- postscript-bottom row: width = grid_width -->
      
      <!-- footer row: width = grid_width -->
      
      <!-- footer-message row: width = grid_width -->
      <div id="footer-message-wrapper" class="footer-message-wrapper full-width">
        <div id="footer-message" class="footer-message row grid16-16">
          <div id="footer-message-inner" class="footer-message-inner inner clearfix">
                              <div id="footer-message-text" class="footer-message-text block">
<div id="footer-message-text-inner" class="footer-message-text-inner inner clearfix">
<br />
</div><!-- /footer-message-text-inner -->
</div><!-- /footer-message-text -->
         
          </div><!-- /footer-message-inner -->
        </div><!-- /footer-message -->
      </div><!-- /footer-message-wrapper -->

    </div><!-- /page-inner -->
  </div><!-- /page -->
  </body>
</html>
